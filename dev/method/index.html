<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>The Voronoi finite volume method · VoronoiFVM.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.0/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">VoronoiFVM.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../changes/">Changes</a></li><li class="is-active"><a class="tocitem" href>The Voronoi finite volume method</a><ul class="internal"><li><a class="tocitem" href="#Construction-of-control-volumes"><span>Construction of control volumes</span></a></li><li><a class="tocitem" href="#The-discretization-approach"><span>The discretization approach</span></a></li><li><a class="tocitem" href="#Why-this-method-?"><span>Why this method ?</span></a></li><li><a class="tocitem" href="#Where-is-this-method-not-appropriate-?"><span>Where is this method not appropriate ?</span></a></li><li><a class="tocitem" href="#History-and-literature"><span>History and literature</span></a></li><li><a class="tocitem" href="#Software-API-and-implementation"><span>Software API and implementation</span></a></li></ul></li><li><span class="tocitem">API Documentation</span><ul><li><a class="tocitem" href="../physics/">Physics &amp; special functions</a></li><li><a class="tocitem" href="../system/">System</a></li><li><a class="tocitem" href="../solutions/">Solutions</a></li><li><a class="tocitem" href="../solver/">Solution methods</a></li><li><a class="tocitem" href="../post/">Postprocessing</a></li><li><a class="tocitem" href="../misc/">Miscellaneous</a></li><li><a class="tocitem" href="../allindex/">Index</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../runexamples/">About the examples</a></li><li><a class="tocitem" href="../examples/Example101_Laplace1D/">101: 1D Laplace equation</a></li><li><a class="tocitem" href="../examples/Example102_StationaryConvectionDiffusion1D/">102: 1D Stationary convection-diffusion equation</a></li><li><a class="tocitem" href="../examples/Example103_ConvectionDiffusion1D/">103: 1D Convection-diffusion equation</a></li><li><a class="tocitem" href="../examples/Example105_NonlinearPoisson1D/">105: 1D Nonlinear Poisson equation</a></li><li><a class="tocitem" href="../examples/Example106_NonlinearDiffusion1D/">106: 1D Nonlinear Diffusion equation</a></li><li><a class="tocitem" href="../examples/Example107_NonlinearStorage1D/">107: 1D Nonlinear Storage</a></li><li><a class="tocitem" href="../examples/Example110_ReactionDiffusion1D_TwoSpecies/">110: 1D Reaction Diffusion equation with two species</a></li><li><a class="tocitem" href="../examples/Example115_HeterogeneousCatalysis1D/">115: 1D heterogeneous catalysis</a></li><li><a class="tocitem" href="../examples/Example120_ThreeRegions1D/">120: Differing species sets in regions, 1D</a></li><li><a class="tocitem" href="../examples/Example121_PoissonPointCharge1D/">121: 1D Poisson with point charge</a></li><li><a class="tocitem" href="../examples/Example125_TestFunctions1D/">125: Terminal flux calculation via test functions</a></li><li><a class="tocitem" href="../examples/Example150_Impedance1D/">150: Impedance calculation</a></li><li><a class="tocitem" href="../examples/Example160_UnipolarDriftDiffusion1D/">160: Unipolar degenerate drift-diffusion</a></li><li><a class="tocitem" href="../examples/Example201_Laplace2D/">201: 2D Laplace equation</a></li><li><a class="tocitem" href="../examples/Example203_CoordinateSystems/">203: Various coordinate systems</a></li><li><a class="tocitem" href="../examples/Example204_HagenPoiseuille/">204: 2D Convection in Hagen-Poiseuille flow</a></li><li><a class="tocitem" href="../examples/Example205_NonlinearPoisson2D/">205: 2D Nonlinear Poisson equation</a></li><li><a class="tocitem" href="../examples/Example210_NonlinearPoisson2D_Reaction/">210: 2D Nonlinear Poisson with reaction</a></li><li><a class="tocitem" href="../examples/Example215_NonlinearPoisson2D_BoundaryReaction/">215: 2D Nonlinear Poisson with boundary reaction</a></li><li><a class="tocitem" href="../examples/Example220_NonlinearPoisson2D_BoundarySpecies/">220: 2D Nonlinear Poisson with boundary reaction and boundary species</a></li><li><a class="tocitem" href="../examples/Example225_TestFunctions2D/">225: Terminal flux calculation via test functions, nD</a></li><li><a class="tocitem" href="../examples/Example226_BoundaryIntegral/">226: Terminal flux calculation via test functions, nD, boundary reaction</a></li><li><a class="tocitem" href="../examples/Example301_Laplace3D/">301: 3D Laplace equation</a></li><li><a class="tocitem" href="../examples/Example405_GenericOperator/">405: Generic Operator: 1D Nonlinear Poisson equation</a></li><li><a class="tocitem" href="../examples/Example406_WeirdReaction/">406: 1D Weird Surface Reaction</a></li><li><a class="tocitem" href="../examples/TestDiffEq/">Comparison with DifferentialEquations.jl</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>The Voronoi finite volume method</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>The Voronoi finite volume method</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/j-fu/VoronoiFVM.jl" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="The-Voronoi-finite-volume-method"><a class="docs-heading-anchor" href="#The-Voronoi-finite-volume-method">The Voronoi finite volume method</a><a id="The-Voronoi-finite-volume-method-1"></a><a class="docs-heading-anchor-permalink" href="#The-Voronoi-finite-volume-method" title="Permalink"></a></h1><h2 id="Construction-of-control-volumes"><a class="docs-heading-anchor" href="#Construction-of-control-volumes">Construction of control volumes</a><a id="Construction-of-control-volumes-1"></a><a class="docs-heading-anchor-permalink" href="#Construction-of-control-volumes" title="Permalink"></a></h2><ul><li><p>Start with a boundary conforming Delaunay triangulation of a polygonal domain (intervals in 1D, triangles in 2D, tetrahedra in   3D). Such a triangulation can be generated by e.g. by the mesh generators triangle and TetGen. These are available in Julia via <a href="https://github.com/JuliaGeometry/Triangulate.jl">Triangulate.jl</a> and <a href="https://github.com/JuliaGeometry/TetGen.jl">TetGen.jl</a>. For simple geometries – tensor products of lower dimensional grids – such triangulation can be created more easily. The package <a href="https://github.com/j-fu/ExtendableGrids.jl">ExtendableGrids.jl</a> manages the grid data structure which is used in this package. <a href="https://github.com/j-fu/SimplexGridFactory.jl">SimplexGridFactory.jl</a> interfaces this grid structure with  <a href="https://github.com/JuliaGeometry/Triangulate.jl">Triangulate.jl</a> and <a href="https://github.com/JuliaGeometry/TetGen.jl">TetGen.jl</a> and provides an API for incrementally setting up geometry descriptions.</p></li><li><p>Join triangle circumcenters by lines <span>$\rightarrow$</span> create Voronoi cells which can serve as control volumes, akin to representative elementary volumes (REV) used to derive conservation laws. </p></li></ul><center>
<img src="../trivoro.png" width="50%">
</center><ul><li>Black + green: triangle nodes</li><li>Gray: triangle edges</li><li>Blue: triangle circumcenters</li><li>Red: Boundaries of Voronoi cells</li></ul><p>In order to make this construction possible, the triangulation must have the boundary conforming Delaunay property: </p><ul><li>The interior of any triangle circumcircle does not contain any other node of the triangulation</li><li>All circumcircle centers lay within the domain </li></ul><p>In 2D, an equivalent condition is:</p><ul><li>The sum of triangle angles opposite to a given interior edge is less than <span>$\pi$</span></li><li>Triangle angles opposite to boundary edges are less than <span>$\frac\pi2$</span>.</li></ul><p>As a consequence, there is a 1:1 incidence between triangulation nodes and Voronoi cells. Moreover, the angle between the interface between two neigboring  Voronoi cells and the edge between their corresponding nodes is <span>$\frac\pi2$</span>.  Therefore the edge direction is aligned with the normal direction with respect to the boundary of the Voronoi cell. This makes it easy to use these Voronoi cells as REVs aka control volumes aka finite volume cells and to derive a space discretization for a concervation law  based on very same balance rules used to derive this conservation law.</p><h2 id="The-discretization-approach"><a class="docs-heading-anchor" href="#The-discretization-approach">The discretization approach</a><a id="The-discretization-approach-1"></a><a class="docs-heading-anchor-permalink" href="#The-discretization-approach" title="Permalink"></a></h2><center>
<img src="../vor.png" width="50%">
</center><p>Given a continuity equation <span>$\nabla\cdot \vec j=f$</span> in a domain <span>$\Omega$</span>, integrate it over a contol volume <span>$\omega_k$</span> with associated node <span>$\vec x_k$</span> and apply Gauss theorem:</p><p class="math-container">\[\begin{aligned}
0&amp;=\int_{\omega_k} (\nabla\cdot  \vec j -f )\ d\omega
=\int_{\partial\omega_k} \vec j\cdot \vec n ds  - \int_{\omega_k} f d\omega\\
&amp;=\sum_{l\in N_k} \int_{\omega_k\cap \omega_l} \vec j\cdot \vec n ds + \int_{\partial\omega_k\cap \partial\Omega} \vec j\cdot \vec n ds   - \int_{\omega_k} f d\omega \\
&amp;\approx \sum_{l\in N_k} \frac{\sigma_{kl}}{h_{kl}}g(u_k, u_l) -  |\omega_k| f_k + \text{boundary terms}
\end{aligned}\]</p><p>Here, <span>$N_k$</span> is the set of neighbor control volumes, <span>$\sigma_{kl}=|\omega_k\cap \omega_l|$</span>, <span>$h_{kl}=|\vec x_k -\vec x_l|$</span>, where  <span>$|\cdot|$</span> denotes the measure (length resp. area) of a geometrical entity. In the approximation step, we replaced the normal flux integral over the interface between two control volumes by the measure of this interface multiplied by a function depending on the unknowns <span>$u_k, u_l$</span> associated to the respective nodes divided by the distance between these nodes.  The flux function <span>$g$</span> can be derived from usual finite difference formulas discretizing a particular flux law.</p><h3 id="Flux-laws"><a class="docs-heading-anchor" href="#Flux-laws">Flux laws</a><a id="Flux-laws-1"></a><a class="docs-heading-anchor-permalink" href="#Flux-laws" title="Permalink"></a></h3><p>For instance, for the diffusion flux <span>$\vec j=-D\vec\nabla u$</span>, we use <span>$g(u_k, u_l)=D(u_k -u_l)$</span>.</p><p>For a convective diffusion flux <span>$\vec j = -D\vec \nabla u + u \vec v$</span>, one can chose the upwind flux</p><p class="math-container">\[\begin{aligned}
g(u_k, u_l)=D(u_k -u_l) + 
v_{kl}\begin{cases}
u_k,&amp; v_{kl}&gt;0\\
u_l,&amp; v_{kl}\leq 0,
\end{cases}
\end{aligned}\]</p><p>where <span>$v_{kl}=\frac{h_{kl}}{\sigma_{kl}}\int_{\omega_k\cap \omega_l} \vec v \cdot \vec n_{kl} \ ds$</span> Fluxes also can depend nonlinearily on <span>$u$</span>.</p><h3 id="Boundary-conditions"><a class="docs-heading-anchor" href="#Boundary-conditions">Boundary conditions</a><a id="Boundary-conditions-1"></a><a class="docs-heading-anchor-permalink" href="#Boundary-conditions" title="Permalink"></a></h3><p>To implement a  Robin boundary condition on <span>$\Gamma=\partial\Omega$</span> </p><p class="math-container">\[- \vec j \cdot \vec n + a u = b,\]</p><p>we note that by the very construction, the discretization nodes associated to control volumes adjacent to the domain boundary are located at the domain boundary, thus we can assume that the boundary condition is valid in the corresponding collocation node <span>$u_k$</span>. We assume that <span>$\partial\omega_k\cap \partial_\Omega= \cup_{m\in\mathcal M_k} \gamma_{km}$</span> is the union of a finite number of line (plane) segments. For interior nodes, we set <span>$\mathcal M_k = \emptyset$</span> . Thus, for the boundary terms in the above equation, we have</p><p class="math-container">\[\begin{aligned}
\text{boundary terms}&amp;=\sum_{m\in\mathcal M_k} \int_{\gamma_{km}} \vec j \cdot \vec n d s
                     &amp;\approx \sum_{m\in\mathcal M_k} |\gamma_{km}| \vec j \cdot \vec n\\
                     &amp;\approx\sum_{m\in\mathcal M_k} |\gamma_{km}|  (au_k -b),
\end{aligned}\]</p><p>We observe that for <span>$\varepsilon\to 0$</span>, the Robin boundary condition </p><p class="math-container">\[- \vec j \cdot \vec n + \frac{1}{\varepsilon}u = \frac{1}{\varepsilon}g\]</p><p>tends to the Dirichlet bundary condition </p><p class="math-container">\[    u=g.\]</p><p>Therefore, a Dirichlet boundary condition can be approximated by choosing a small value of <span>$\varepsilon$</span> and implying the aforementioned Robin boundary conditions. This approach  called <em>penalty method</em>  is chosen for the implementation of Dirichlet boundary conditions in this package.</p><h3 id="Time-dependent-problems,-reaction-terms"><a class="docs-heading-anchor" href="#Time-dependent-problems,-reaction-terms">Time dependent problems, reaction terms</a><a id="Time-dependent-problems,-reaction-terms-1"></a><a class="docs-heading-anchor-permalink" href="#Time-dependent-problems,-reaction-terms" title="Permalink"></a></h3><p>This approach easily generalizes to time dependent nonlinear transport-reaction problems with storage terms <span>$s(u)$</span>, reaction terms <span>$r(u)$</span> and source terms <span>$f$</span>:</p><p class="math-container">\[\partial_t s(u) + \nabla \cdot \vec j + r(u) -f =0\]</p><p>Semidiscretization in time (for implicit Euler) leads to </p><p class="math-container">\[\frac{s(u)-s(u^\flat)}{\tau} + \nabla \cdot \vec j + r(u) -f =0\]</p><p>where <span>$\tau$</span> is the time step size and <span>$u^\flat$</span> is the solution from the old timestep. The approximation  approach then for each control volume gives</p><p class="math-container">\[|\omega_k|\frac{s(u_k)-s(u_k^\flat)}{\tau} + \sum_{l\in N_k} \frac{\sigma_{kl}}{h_{kl}}g(u_k, u_l)+ \sum_{m\in\mathcal M_k} |\gamma_{km}|  (au_k -b) + |\omega_k| (r(u_k)- f_k)=0\]</p><p>If <span>$n$</span> is the number of discretization nodes, we get a system of <span>$n$</span> equations with <span>$n$</span> unknowns which under proper conditions on <span>$r,g,s$</span> has a unique solution. </p><p>The implicit Euler method is the default solver for time dependent problems. Alternatively, ODE and DAE solvers from <a href="https://github.com/SciML/DifferentialEquations.jl">DifferentialEquations.jl</a> can be <a href="../solver/#diffeq">used</a>.</p><h3 id="Generalizations-to-systems"><a class="docs-heading-anchor" href="#Generalizations-to-systems">Generalizations to systems</a><a id="Generalizations-to-systems-1"></a><a class="docs-heading-anchor-permalink" href="#Generalizations-to-systems" title="Permalink"></a></h3><p>This approach generalizes to systems of partial differential equations, which formally can be written in the same way, but assuming that <span>$u$</span> is a vector function of <span>$\vec x,t$</span>, and <span>$r,g,s$</span> are vector functions of their arguments. The package allows to handle different sets of species in different subdomains of <span>$\Omega$</span>.</p><h3 id="Boundary-reactions,-boundary-species"><a class="docs-heading-anchor" href="#Boundary-reactions,-boundary-species">Boundary reactions, boundary species</a><a id="Boundary-reactions,-boundary-species-1"></a><a class="docs-heading-anchor-permalink" href="#Boundary-reactions,-boundary-species" title="Permalink"></a></h3><p>In addition to  <span>$r,g,s$</span>, the package allows to specify additional boundary species, boundary reaction terms and bondary storage terms.</p><h2 id="Why-this-method-?"><a class="docs-heading-anchor" href="#Why-this-method-?">Why this method ?</a><a id="Why-this-method-?-1"></a><a class="docs-heading-anchor-permalink" href="#Why-this-method-?" title="Permalink"></a></h2><p>Independent of space dimension, the method (with properly chosen flux functions) is able to preserve a number of physical quantities if they are present on the continuous level:</p><ul><li>local and global mass conservation</li><li>positivity of solutions</li><li>maximum principle: in the absence of source and reaction terms, local extrema of the stationary solution are located at the domain boudaries, never in the interior. For transient problems, local extrema in the interior can only come from the initial value. </li><li>Consistency to thermodynamics: entropy production etc.</li></ul><p>Many of these properties are hard to prove for finite element methods, in particular for the convection-diffusion case.</p><h2 id="Where-is-this-method-not-appropriate-?"><a class="docs-heading-anchor" href="#Where-is-this-method-not-appropriate-?">Where is this method not appropriate ?</a><a id="Where-is-this-method-not-appropriate-?-1"></a><a class="docs-heading-anchor-permalink" href="#Where-is-this-method-not-appropriate-?" title="Permalink"></a></h2><p>There are a number of cases where this method needs to be replaced by something else or at least to be applied with great care:</p><ul><li>Anisotropic diffusion only works with proper mesh alignment </li><li>Strongly varying capacity (in the function s) at domain interfaces lead to inexact breaktrough curves</li><li>Sharp moving convection fronts are smeared out too strongly</li></ul><h2 id="History-and-literature"><a class="docs-heading-anchor" href="#History-and-literature">History and literature</a><a id="History-and-literature-1"></a><a class="docs-heading-anchor-permalink" href="#History-and-literature" title="Permalink"></a></h2><p>The following list  is work in progress and incomplete, but it references some sources behind the ideas in this package.</p><ul><li>Macneal, R. H. (1953). An asymmetrical finite difference network. Quarterly of Applied Mathematics, 11(3), 295-310.  (<a href="https://www.jstor.org/stable/pdf/43634052.pdf">pdf</a> via JSTOR). Perhaps this is the earliest mentioning of the method. Note that it  was used on an electrical analog computer. </li><li>Gärtner, K., &amp; Kamenski, L. (2019). Why do we need Voronoi cells and Delaunay meshes? <a href="https://arxiv.org/pdf/1905.01738">arXiv preprint arXiv:1905.01738</a>. A recent overview on the merits of the method. One of the authors belongs to the pioneers of its application in 3D.</li><li>Fuhrmann, J., &amp; Langmach, H. (2001). Stability and existence of solutions of time-implicit finite volume schemes for viscous nonlinear conservation laws. Applied Numerical Mathematics, 37(1-2), 201-230. A discussion of the method applied to rather general nonlinear scalar problems.</li><li>Si, H., Gärtner, K., &amp; Fuhrmann, J. (2010). Boundary conforming Delaunay mesh generation. Computational Mathematics and Mathematical Physics, 50(1), 38-53. Definition of the boundary conforming Delaunay property. </li><li>Eymard, R., Fuhrmann, J., &amp; Gärtner, K. (2006). A finite volume scheme for nonlinear parabolic equations derived from one-dimensional local Dirichlet problems. Numerische Mathematik, 102(3), 463-495. General concept of the derivation of upwind fluxes for nonlinear problems.</li><li>Farrell, P., Rotundo, N., Doan, D. H., Kantner, M., Fuhrmann, J., &amp; Koprucki, T. (2017). Drift-diffusion models. In Handbook of Optoelectronic Device Modeling and Simulation (pp. 733-772). CRC Press. Overview and introduction to the method applied to semiconductor device simulation. This problem class profits most from the desirable properties of the method.</li></ul><h2 id="Software-API-and-implementation"><a class="docs-heading-anchor" href="#Software-API-and-implementation">Software API and implementation</a><a id="Software-API-and-implementation-1"></a><a class="docs-heading-anchor-permalink" href="#Software-API-and-implementation" title="Permalink"></a></h2><p>The entities describing the discrete system can be subdivided into two categories:</p><ul><li>Geometrical data: <span>$|\omega_k|, \gamma_k, \sigma_{kl}, h_{kl}$</span> together with the connectivity information simplex grid. These data are calculated  from the discretization grid.</li><li><a href="../physics/#VoronoiFVM.Physics"><code>VoronoiFVM.Physics</code></a>: the number of species and the functions <span>$s,g,r,f$</span> etc. describing the particular problem.</li></ul><p>The solution of the nonlinear systems of equations is performed by Newton&#39;s method combined with various direct and iterative linear solvers. The Jacobi matrices used in Newton&#39;s method are assembled from the constitutive functions whith the help of forward mode automatic differentiation implemented in  <a href="https://github.com/JuliaDiff/ForwardDiff.jl">ForwardDiff.jl</a>.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../changes/">« Changes</a><a class="docs-footer-nextpage" href="../physics/">Physics &amp; special functions »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Thursday 22 April 2021 21:28">Thursday 22 April 2021</span>. Using Julia version 1.6.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
