var documenterSearchIndex = {"docs":
[{"location":"system/#System","page":"System","title":"System","text":"","category":"section"},{"location":"system/","page":"System","title":"System","text":"The computational grid required is assumed to correspond to a domain Omega=cup_r=1^n_Omega Omega_r ","category":"page"},{"location":"system/","page":"System","title":"System","text":"Grids for VoronoiFVM are managed by the packages ExtendableGrids.jl and SimplexGridFactory.jl","category":"page"},{"location":"system/","page":"System","title":"System","text":"with boundary  partialOmega=Gamma=cup_b=1^n_Gamma Gamma_b.","category":"page"},{"location":"system/","page":"System","title":"System","text":"The subdomains Omega_r are called \"regions\" and the boundary subdomains Gamma_b are called \"boundary regions\".","category":"page"},{"location":"system/","page":"System","title":"System","text":"On this complex of domains \"lives\"  a number of species which are either attached to a number of regions or to a number of boundary regions.","category":"page"},{"location":"system/","page":"System","title":"System","text":"All these data, the matrix for the linear system and other things are hold together by a struct VoronoiFVM.System.  This type is not exported to avoid name clashes.","category":"page"},{"location":"system/#System-constructors","page":"System","title":"System constructors","text":"","category":"section"},{"location":"system/","page":"System","title":"System","text":"VoronoiFVM.System(grid::ExtendableGrid; kwargs...)\nVoronoiFVM.System(X::AbstractVector; kwargs...)\nVoronoiFVM.System(X::AbstractVector,Y::AbstractVector; kwargs...)\nVoronoiFVM.System(X::AbstractVector,Y::AbstractVector,Z::AbstractVector; kwargs...)\nupdate_grid!","category":"page"},{"location":"system/#VoronoiFVM.System-Tuple{ExtendableGrid}","page":"System","title":"VoronoiFVM.System","text":"System(grid; kwargs...)\n\nCreate structure of type VoronoiFVM.System{Tv,Ti, Tm, TSpecMat<:AbstractMatrix, TSolArray<:AbstractMatrix}  holding data for finite volume system solution. \n\nParameters: \n\ngrid::ExtendableGrid: 1, 2 or 3D computational grid\n\nKeyword arguments:\n\nspecies: vector of integer species indices. Added to all grid regions, avoiding the need to call enable_species! for this default case.             If it is kept empty, species have be added to the system after creation via  enable_species!.\nunknown_storage: string or symbol.     Information  on  species  distribution  is kept  in  sparse  or  dense   matrices matrices and, correspondingly, the  solution array is of type   SparseSolutionArray  or matrix,  respectively. In  the case  of sparse   unknown storage,  the system matrix  handles exactly those  degrees of   freedom which correspond to unknowns.  However, handling of the sparse   matrix  structures  for  the   bookkeeping  of  the  unknowns  creates   overhead.\n:dense :  solution vector is an  nspecies x nnodes  dense matrix\n:sparse :  solution vector is an nspecies x nnodes  sparse matrix\nmatrixindextype: Integer type. Index type for sparse matrices created in the system.\n\nPhysics keyword arguments:\n\nflux: Function.     Flux between neigboring control volumes: flux(f,u,edge) or flux(f,u,edge,data)   should return in f[i] the flux of species i along the edge joining circumcenters   of neigboring control volumes.  For species i,u[i,1] and u[i,2] contain the unknown values at the corresponding ends of the edge.\nstorage: Function.  Storage term (term under time derivative): storage(f,u,node) or storage(f,u,node,data)    It should return in f[i] the storage term for the i-th equation. u[i] contains the value of   the i-th unknown.\nreaction:  Function. Reaction term:  reaction(f,u,node) or reaction(f,u,node,data)    It should return in f[i] the reaction term for the i-th equation. u[i] contains the value of   the i-th unknown.\nsource:  Function. Source term: source(f,node) or source(f,node,data).   It should return the in f[i] the value of the source term for the i-th equation.\nbflux:  Function. Flux between neighboring control volumes on the boundary\nbreaction Function.  Boundary reaction term:  breaction(f,u,node) or breaction(f,u,node,data)    Similar to reaction, but restricted to the inner or outer boundaries.\nbcondition Function. Alias for breaction.\nbsource: Function. Boundary source term: bsource(f,node) or bsource(f,node,data).   It should return in f[i] the value of the source term for the i-th equation.\nbstorage: Function.  Boundary storage term: bstorage(f,u,node) or bstorage(f,u,node,data)    Similar to storage, but restricted to the inner or outer boundaries.\ngeneric_operator: Funtion.  Generic operator  generic_operator(f,u,sys).    This operator acts on the full solution u of a system. Sparsity   is detected automatically  unless generic_operator_sparsity is given.\ngeneric_operator_sparsity:  Function defining the sparsity structure of the generic operator.   This should return the sparsity pattern of the generic_operator.\nnparams: number of parameters the system is depending on, and with respect to which the derivatives   need to be obtained\ndata:  User data (parameters).   This allows to pass various parameters to the callback functions. If data is given, all callback functions   should accept a last data argument. Otherwise, no data are passed explicitely, and constitutive callbacks can   take parameters from the closure where the function is defined.\n\n\n\n\n\n","category":"method"},{"location":"system/#VoronoiFVM.System-Tuple{AbstractVector}","page":"System","title":"VoronoiFVM.System","text":"System(X; kwargs...)\n\nCreate an 1D grid from vector X and call  VoronoiFVM.System(grid::ExtendableGrid; kwargs...).\n\n\n\n\n\n","category":"method"},{"location":"system/#VoronoiFVM.System-Tuple{AbstractVector, AbstractVector}","page":"System","title":"VoronoiFVM.System","text":"System(X,Y; kwargs...)\n\nCreate a 2D grid from vectors X,Y  and call  VoronoiFVM.System(grid::ExtendableGrid; kwargs...).\n\n\n\n\n\n","category":"method"},{"location":"system/#VoronoiFVM.System-Tuple{AbstractVector, AbstractVector, AbstractVector}","page":"System","title":"VoronoiFVM.System","text":"System(X,Y, Z; kwargs...)\n\nCreate a 3D grid from vectors X,Y,Z  and call  VoronoiFVM.System(grid::ExtendableGrid; kwargs...).\n\n\n\n\n\n","category":"method"},{"location":"system/#VoronoiFVM.update_grid!","page":"System","title":"VoronoiFVM.update_grid!","text":"update_grid!(system; grid=system.grid)\n\nUpdate grid (e.g. after rescaling of coordinates).\n\n\n\n\n\n","category":"function"},{"location":"system/#Adding-species-by-species-numbers","page":"System","title":"Adding species by species numbers","text":"","category":"section"},{"location":"system/","page":"System","title":"System","text":"enable_species!(system::VoronoiFVM.AbstractSystem,ispec::Integer, regions::AbstractVector)\nenable_species!(system::VoronoiFVM.AbstractSystem; kwargs...)\nenable_boundary_species!","category":"page"},{"location":"system/#VoronoiFVM.enable_species!-Tuple{VoronoiFVM.AbstractSystem, Integer, AbstractVector}","page":"System","title":"VoronoiFVM.enable_species!","text":"enable_species!(system,ispec,regions)\n\nAdd species ispec to a list of bulk regions. Species numbers for bulk and boundary species have to be distinct.  Once a species has been added, it cannot be removed.\n\n\n\n\n\n","category":"method"},{"location":"system/#VoronoiFVM.enable_species!-Tuple{VoronoiFVM.AbstractSystem}","page":"System","title":"VoronoiFVM.enable_species!","text":"enable_species!(system; kwargs...)\n\nKeyword arguments:\n\nspecies: Integer or vector of integers. Species to be added to the system.\nregions: Vector of integers. Regions, where these species shall be added.If nothing, they are added to all species.\n\nOnce a species has been added, it cannot be removed.\n\n\n\n\n\n","category":"method"},{"location":"system/#VoronoiFVM.enable_boundary_species!","page":"System","title":"VoronoiFVM.enable_boundary_species!","text":"enable_boundary_species!(system,ispec,regions)\n\nAdd species ispec to a list of boundary regions. Species numbers for bulk and boundary species have to be distinct. Once a species has been added, it cannot be removed.\n\n\n\n\n\n","category":"function"},{"location":"system/#Handling-boundary-conditions","page":"System","title":"Handling boundary conditions","text":"","category":"section"},{"location":"system/","page":"System","title":"System","text":"Boundary conditions are handeled in the  bcondition callback passed to the system constructor. For being called in this callback, the following  functions are availabel","category":"page"},{"location":"system/","page":"System","title":"System","text":"boundary_dirichlet!(y,u,bnode,ispec,ireg,val)\nboundary_dirichlet!(y,u,bnode;kwargs...)\nboundary_neumann!(y,u,bnode,ispec,ireg,val)\nboundary_neumann!(y,u,bnode;kwargs...)\nboundary_robin!(y,u,bnode,ispec,ireg,fac,val)\nboundary_robin!(y,u,bnode;kwargs...)\nramp","category":"page"},{"location":"system/#VoronoiFVM.boundary_dirichlet!-NTuple{6, Any}","page":"System","title":"VoronoiFVM.boundary_dirichlet!","text":" boundary_dirichlet!(y,u,bnode,ispec,ireg,val)\n\nSet Dirichlet boundary condition for species ispec at boundary ibc.\n\n\n\n\n\n","category":"method"},{"location":"system/#VoronoiFVM.boundary_dirichlet!-Tuple{Any, Any, Any}","page":"System","title":"VoronoiFVM.boundary_dirichlet!","text":" boundary_dirichlet!(y,u,bnode, args...; kwargs...)\n\nKeyword argument version:\n\nspecies: species number. Default: 1\nregion: boundary region number. By default, all boundary regions.\nvalue: value\n\n\n\n\n\n","category":"method"},{"location":"system/#VoronoiFVM.boundary_neumann!-NTuple{6, Any}","page":"System","title":"VoronoiFVM.boundary_neumann!","text":" boundary_neumann!(y,u,bnode,ispec,ireg,val)\n\nSet Neumann boundary condition for species ispec at boundary ibc.\n\n\n\n\n\n","category":"method"},{"location":"system/#VoronoiFVM.boundary_neumann!-Tuple{Any, Any, Any}","page":"System","title":"VoronoiFVM.boundary_neumann!","text":" boundary_neumann!(y,u,bnode, args...; kwargs...)\n\nKeyword argument version:\n\nspecies: species number. Default: 1\nregion: boundary region number. By default, all boundary regions.\nvalue: value\n\n\n\n\n\n","category":"method"},{"location":"system/#VoronoiFVM.boundary_robin!-NTuple{7, Any}","page":"System","title":"VoronoiFVM.boundary_robin!","text":" boundary_robin!(y,u,bnode,ispec,ireg,fac,val)\n\nSet Robin boundary condition for species ispec at boundary ibc.\n\n\n\n\n\n","category":"method"},{"location":"system/#VoronoiFVM.boundary_robin!-Tuple{Any, Any, Any}","page":"System","title":"VoronoiFVM.boundary_robin!","text":" boundary_robin!(y,u,bnode, args...; kwargs...)\n\nKeyword argument version:\n\nspecies: species number. Default: 1\nregion: boundary region number. By default, all boundary regions.\nfactor: factor\nvalue: value\n\n\n\n\n\n","category":"method"},{"location":"system/#VoronoiFVM.ramp","page":"System","title":"VoronoiFVM.ramp","text":"   ramp(t; kwargs...)\n\nRamp function for specifying time dependent boundary conditions\n\nKeyword arguments:\n\ndt: Tuple: start and end time of ramp. Default: (0,0.1)\ndu: Tuple: values at start and end time. Default: (0,0)\n\n\n\n\n\n","category":"function"},{"location":"system/#Various-tools","page":"System","title":"Various tools","text":"","category":"section"},{"location":"system/","page":"System","title":"System","text":"physics!","category":"page"},{"location":"system/#VoronoiFVM.physics!","page":"System","title":"VoronoiFVM.physics!","text":"physics!(system,physics)\n\nReplace System's physics data\n\n\n\n\n\nphysics!(system; kwargs...)\n\nReplace System's physics data.\n\n\n\n\n\n","category":"function"},{"location":"system/","page":"System","title":"System","text":"check_allocs!","category":"page"},{"location":"system/#VoronoiFVM.check_allocs!","page":"System","title":"VoronoiFVM.check_allocs!","text":"check_allocs!(system,true_or_false)\n\nEnable/disable checking for time-consuming allocations in the assembly loop.  By default,  this check  is switched off.  By setting  the environment variable ENV[\"VORONOIFVM_CHECK_ALLOCS\"]=\"true\", this  default can be changed.\n\nUnless  the   matrix  pattern  changes,  there   shouldn't  occur  any allocations in this loop. The check  method is aware of matrix pattern changes. As a consequence, allocations in the assembly loop are mostly due to type instabilities in physics callbacks, see the the discussion here.  Type instabilities can be debugged via the @time  macro applied to expressions in a physics callback.\n\nThe following  cases provide some ideas  where to look for  reasons of the problem and possible remedies:\n\nCase 1: a parameter changes its value, and Julia is not sure about the type.\n\neps=1.0\n\nflux(f,_u,edge)\n    u=unkowns(edge,_u)\n    f[1]=eps*(u[1,1]-[1,2])\nend\n... solve etc ...\neps=2.0\n\nRemedy: use a type annotation eps::Float64=... to signalize your intent to Julia. This behaviour is explained in the Julia documentation.\n\nCase 2: variables in the closure have the same name as a variable introduced in a callback.\n\nflux(f,_u,edge)\n    u=unkowns(edge,_u)\n    f[1]=(u[1,1]-[1,2])\nend\n\n... create etc ...\n\nu=solve(...)\n\nRemedy: rename e.g. u=solve() to sol=solve()\n\n\n\n\n\n","category":"function"},{"location":"system/","page":"System","title":"System","text":"num_dof\nunknowns(system::VoronoiFVM.AbstractSystem; kwargs...)\nVoronoiFVM.isunknownsof\nBase.reshape\nLinearAlgebra.norm(system::VoronoiFVM.AbstractSystem, u,p)","category":"page"},{"location":"system/#VoronoiFVM.num_dof","page":"System","title":"VoronoiFVM.num_dof","text":"num_dof(system)\n\n\nNumber of degrees of freedom for system.\n\n\n\n\n\n","category":"function"},{"location":"system/#VoronoiFVM.unknowns-Tuple{VoronoiFVM.AbstractSystem}","page":"System","title":"VoronoiFVM.unknowns","text":"unknowns(system; inival)\n\n\nCreate a solution vector for system. If inival is not specified, the entries of the returned vector are undefined.\n\n\n\n\n\n","category":"method"},{"location":"system/#VoronoiFVM.isunknownsof","page":"System","title":"VoronoiFVM.isunknownsof","text":"isunknownsof(u, sys)\n\n\nDetect if array fits to the system.\n\n\n\n\n\n","category":"function"},{"location":"system/#Base.reshape","page":"System","title":"Base.reshape","text":"reshape(v, system)\n\n\nReshape vector to fit as solution to system.\n\n\n\n\n\nreshape(ode_solution, system)\n\nCreate a TransientSolution from the output of the ode solver.\n\n\n\n\n\n","category":"function"},{"location":"system/#LinearAlgebra.norm-Tuple{VoronoiFVM.AbstractSystem, Any, Any}","page":"System","title":"LinearAlgebra.norm","text":"norm(system, u, p)\n\n\nCalculate norm, paying attention to species distribution over regions\n\n\n\n\n\n","category":"method"},{"location":"system/#Types","page":"System","title":"Types","text":"","category":"section"},{"location":"system/","page":"System","title":"System","text":"VoronoiFVM.AbstractSystem\nVoronoiFVM.System{Tv,Ti, Tm, TSpecMat<:AbstractMatrix, TSolArray<:AbstractMatrix}\nVoronoiFVM.DenseSystem\nVoronoiFVM.SparseSystem","category":"page"},{"location":"system/#VoronoiFVM.AbstractSystem","page":"System","title":"VoronoiFVM.AbstractSystem","text":"abstract type AbstractSystem{Tv<:Number, Ti<:Integer, Tm<:Integer}\n\nAbstract type for finite volume system structure.\n\n\n\n\n\n","category":"type"},{"location":"system/#VoronoiFVM.System","page":"System","title":"VoronoiFVM.System","text":"mutable struct System{Tv, Ti, Tm, TSpecMat<:(AbstractMatrix), TSolArray<:(AbstractMatrix)} <: VoronoiFVM.AbstractSystem{Tv, Ti, Tm}\n\nStructure holding data for finite volume system.\n\n\n\n\n\n","category":"type"},{"location":"system/#VoronoiFVM.DenseSystem","page":"System","title":"VoronoiFVM.DenseSystem","text":"const DenseSystem\n\nType alias for system with dense matrix based species management\n\n\n\n\n\n","category":"type"},{"location":"system/#VoronoiFVM.SparseSystem","page":"System","title":"VoronoiFVM.SparseSystem","text":"const SparseSystem\n\nType alias for system with sparse matrix based species management\n\n\n\n\n\n","category":"type"},{"location":"system/#Legacy-API","page":"System","title":"Legacy API","text":"","category":"section"},{"location":"system/","page":"System","title":"System","text":"boundary_dirichlet!(system::VoronoiFVM.AbstractSystem, ispec, ibc, v)\nboundary_dirichlet!(system::VoronoiFVM.AbstractSystem; kwargs...)\nboundary_neumann!(system::VoronoiFVM.AbstractSystem, ispec, ibc, v)\nboundary_neumann!(system::VoronoiFVM.AbstractSystem; kwargs...)\nboundary_robin!(system::VoronoiFVM.AbstractSystem, ispec, ibc,alpha, v)\nboundary_robin!(system::VoronoiFVM.AbstractSystem; kwargs...)","category":"page"},{"location":"system/#VoronoiFVM.boundary_dirichlet!-Tuple{VoronoiFVM.AbstractSystem, Any, Any, Any}","page":"System","title":"VoronoiFVM.boundary_dirichlet!","text":"boundary_dirichlet!(system, ispec, ibc, v)\n\n\nSet Dirichlet boundary condition for species ispec at boundary ibc:\n\nu_ispec=v on Gamma_ibc\n\ninfo: Info\nStarting with version 0.14, it is preferable to define boundary condtitions within the bcondition physics callback\n\n\n\n\n\n","category":"method"},{"location":"system/#VoronoiFVM.boundary_dirichlet!-Tuple{VoronoiFVM.AbstractSystem}","page":"System","title":"VoronoiFVM.boundary_dirichlet!","text":"  boundary_dirichlet!(system; kwargs...)\n\nKeyword argument version:\n\nspecies: species number\nregion: region number\nvalue: value\n\ninfo: Info\nStarting with version 0.14, it is preferable to define boundary condtitions within the bcondition physics callback\n\n\n\n\n\n","category":"method"},{"location":"system/#VoronoiFVM.boundary_neumann!-Tuple{VoronoiFVM.AbstractSystem, Any, Any, Any}","page":"System","title":"VoronoiFVM.boundary_neumann!","text":"boundary_neumann!(system, ispec, ibc, v)\n\n\nSet Neumann boundary condition for species ispec at boundary ibc:\n\nmathrmflux_ispeccdot vec n=v on Gamma_ibc\n\ninfo: Info\nStarting with version 0.14, it is preferable to define boundary condtitions within the bcondition physics callback\n\n\n\n\n\n","category":"method"},{"location":"system/#VoronoiFVM.boundary_neumann!-Tuple{VoronoiFVM.AbstractSystem}","page":"System","title":"VoronoiFVM.boundary_neumann!","text":"  boundary_neumann!(system; kwargs...)\n\nKeyword argument version:\n\nspecies: species number\nregion: region number\nvalue: value\n\ninfo: Info\nStarting with version 0.14, it is preferable to define boundary condtitions within the bcondition physics callback\n\n\n\n\n\n","category":"method"},{"location":"system/#VoronoiFVM.boundary_robin!-Tuple{VoronoiFVM.AbstractSystem, Any, Any, Any, Any}","page":"System","title":"VoronoiFVM.boundary_robin!","text":"boundary_robin!(system, ispec, ibc, α, v)\n\n\nSet Robin boundary condition for species ispec at boundary ibc:\n\nmathrmflux_ispeccdot vec n + alpha u_ispec=v on Gamma_ibc\n\ninfo: Info\nStarting with version 0.14, it is preferable to define boundary condtitions within the bcondition physics callback\n\n\n\n\n\n","category":"method"},{"location":"system/#VoronoiFVM.boundary_robin!-Tuple{VoronoiFVM.AbstractSystem}","page":"System","title":"VoronoiFVM.boundary_robin!","text":"  boundary_robin!(system; kwargs...)\n\nKeyword argument version:\n\nspecies: species number\nregion: region number\nfactor: factor\nvalue: value\n\ninfo: Info\nStarting with version 0.14, it is preferable to define boundary condtitions within the bcondition physics callback\n\n\n\n\n\n","category":"method"},{"location":"notebooks/#About-the-notebooks","page":"About the notebooks","title":"About the notebooks","text":"","category":"section"},{"location":"notebooks/","page":"About the notebooks","title":"About the notebooks","text":"Pluto.jl notebooks provide a great opportunity to put together code, text and graphics  in a reproducible and accessible way. Therefore, the examples for this package are being  amended by a series of Pluto notebooks. Like the example code, the notebook code is tested during CI.","category":"page"},{"location":"notebooks/","page":"About the notebooks","title":"About the notebooks","text":"The notebooks use an updated and simplified version of the VoronoiFVM API. ","category":"page"},{"location":"notebooks/","page":"About the notebooks","title":"About the notebooks","text":"Plese note, that in the html version, interactive elements like sliders are disabled. Navigation via the table of contents does work, though.","category":"page"},{"location":"examples/Example110_ReactionDiffusion1D_TwoSpecies/#:-1D-Reaction-Diffusion-equation-with-two-species","page":"110: 1D Reaction Diffusion equation with two species","title":"110: 1D Reaction Diffusion equation with two species","text":"","category":"section"},{"location":"examples/Example110_ReactionDiffusion1D_TwoSpecies/","page":"110: 1D Reaction Diffusion equation with two species","title":"110: 1D Reaction Diffusion equation with two species","text":"(source code)","category":"page"},{"location":"examples/Example110_ReactionDiffusion1D_TwoSpecies/","page":"110: 1D Reaction Diffusion equation with two species","title":"110: 1D Reaction Diffusion equation with two species","text":"Solve the nonlinear coupled reaction diffusion problem","category":"page"},{"location":"examples/Example110_ReactionDiffusion1D_TwoSpecies/","page":"110: 1D Reaction Diffusion equation with two species","title":"110: 1D Reaction Diffusion equation with two species","text":"-nabla (001+2u_2)nabla u_1 + u_1u_2= 00001(001+x)","category":"page"},{"location":"examples/Example110_ReactionDiffusion1D_TwoSpecies/","page":"110: 1D Reaction Diffusion equation with two species","title":"110: 1D Reaction Diffusion equation with two species","text":"-nabla (001+2u_1)nabla u_2 - u_1u_2 = 00001(101-x)","category":"page"},{"location":"examples/Example110_ReactionDiffusion1D_TwoSpecies/","page":"110: 1D Reaction Diffusion equation with two species","title":"110: 1D Reaction Diffusion equation with two species","text":"in Omega=(01) with boundary condition u_1(0)=1, u_2(0)=0 and u_1(1)=1, u_2(1)=1.","category":"page"},{"location":"examples/Example110_ReactionDiffusion1D_TwoSpecies/","page":"110: 1D Reaction Diffusion equation with two species","title":"110: 1D Reaction Diffusion equation with two species","text":"module Example110_ReactionDiffusion1D_TwoSpecies\n\nusing Printf\nusing VoronoiFVM\nusing ExtendableGrids\nusing GridVisualize\n\nfunction main(;n=100,Plotter=nothing,verbose=false,unknown_storage=:sparse)\n    h=1/n\n    grid=VoronoiFVM.Grid(collect(0:h:1))\n\n\n    eps::Vector{Float64}=[1.0,1.0]\n\n    physics=VoronoiFVM.Physics(\n\n                               reaction=function(f,u,node)\n                               f[1]=u[1]*u[2]\n                               f[2]=-u[1]*u[2]\n                               end,\n\n                               flux=function(f,u,edge)\n\n                               nspecies=2\n                               f[1]=eps[1]*(u[1,1]-u[1,2])*(0.01+u[2,1]+u[2,2])\n                               f[2]=eps[2]*(u[2,1]-u[2,2])*(0.01+u[1,1]+u[1,2])\n                               end,\n\n                               source=function(f,node)\n                               f[1]=1.0e-4*(0.01+node[1])\n                               f[2]=1.0e-4*(0.01+1.0-node[1])\n                               end,\n\n                               storage=function(f,u,node)\n                               f[1]=u[1]\n                               f[2]=u[2]\n                               end\n                               )\n\n    sys=VoronoiFVM.System(grid,physics,unknown_storage=unknown_storage)\n\n    enable_species!(sys,1,[1])\n    enable_species!(sys,2,[1])\n\n    boundary_dirichlet!(sys,1,1,1.0)\n    boundary_dirichlet!(sys,1,2,0.0)\n\n    boundary_dirichlet!(sys,2,1,1.0)\n    boundary_dirichlet!(sys,2,2,0.0)\n\n    inival=unknowns(sys)\n    U=unknowns(sys)\n    inival.=0\n\n    control=VoronoiFVM.NewtonControl()\n    control.verbose=verbose\n    control.damp_initial=0.1\n    u5=0\n    p=GridVisualizer(Plotter=Plotter,layout=(2,1))\n    for xeps in [1.0,0.5,0.25,0.1,0.05,0.025,0.01]\n        eps=[xeps,xeps]\n        solve!(U,inival,sys,control=control)\n        inival.=U\n        scalarplot!(p[1,1],grid,U[1,:],clear=true,title=\"U1, eps=$(xeps)\")\n        scalarplot!(p[2,1],grid,U[2,:],clear=true,title=\"U2, eps=$(xeps)\",reveal=true)\n        sleep(0.2)\n        u5=U[5]\n    end\n    return u5\nend\n\nfunction test()\n    testval=0.7117546972922056\n    main(unknown_storage=:sparse) ≈ testval && main(unknown_storage=:dense) ≈ testval\nend\nend","category":"page"},{"location":"examples/Example110_ReactionDiffusion1D_TwoSpecies/","page":"110: 1D Reaction Diffusion equation with two species","title":"110: 1D Reaction Diffusion equation with two species","text":"","category":"page"},{"location":"examples/Example110_ReactionDiffusion1D_TwoSpecies/","page":"110: 1D Reaction Diffusion equation with two species","title":"110: 1D Reaction Diffusion equation with two species","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/Example204_HagenPoiseuille/#:-2D-Convection-in-Hagen-Poiseuille-flow","page":"204: 2D Convection in Hagen-Poiseuille flow","title":"204: 2D Convection in Hagen-Poiseuille flow","text":"","category":"section"},{"location":"examples/Example204_HagenPoiseuille/","page":"204: 2D Convection in Hagen-Poiseuille flow","title":"204: 2D Convection in Hagen-Poiseuille flow","text":"(source code)","category":"page"},{"location":"examples/Example204_HagenPoiseuille/","page":"204: 2D Convection in Hagen-Poiseuille flow","title":"204: 2D Convection in Hagen-Poiseuille flow","text":"Solve the equation","category":"page"},{"location":"examples/Example204_HagenPoiseuille/","page":"204: 2D Convection in Hagen-Poiseuille flow","title":"204: 2D Convection in Hagen-Poiseuille flow","text":"partial_t u -nabla ( D nabla u - v u) = 0","category":"page"},{"location":"examples/Example204_HagenPoiseuille/","page":"204: 2D Convection in Hagen-Poiseuille flow","title":"204: 2D Convection in Hagen-Poiseuille flow","text":"in Omega=(0L)times (0H) with dirichlet boundary conditions at x=0 and outflow boundary condition at x=L.","category":"page"},{"location":"examples/Example204_HagenPoiseuille/","page":"204: 2D Convection in Hagen-Poiseuille flow","title":"204: 2D Convection in Hagen-Poiseuille flow","text":"module Example204_HagenPoiseuille\nusing Printf\nusing VoronoiFVM\nusing ExtendableGrids\nusing GridVisualize\n\n\nfunction main(;nref=0,Plotter=nothing,D=0.01,v=1.0,tend=100,cin=1.0)\n    H=1.0\n    L=5.0\n    grid=simplexgrid(range(0,L,length=20*2^nref),\n                     range(0,H,length=5*2^nref))\n\n\n    function fhp(x,y)\n        yh=y/H\n        return v*4*yh*(1.0-yh),0\n    end\n\n    evelo=edgevelocities(grid,fhp)\n    bfvelo=bfacevelocities(grid,fhp)\n\n\n    function flux!(f,u,edge)\n        vd=evelo[edge.index]/D\n        bp=fbernoulli(vd)\n        bm=fbernoulli(-vd)\n        f[1]=D*(bp*u[1] - bm*u[2])\n    end\n\n    function outflow!(f,u,node)\n        if node.region==2\n            f[1]=bfvelo[node.ibnode,node.ibface]*u[1]\n        end\n    end\n\n    ispec=1\n    physics=VoronoiFVM.Physics(flux=flux!,breaction=outflow!)\n    sys=VoronoiFVM.DenseSystem(grid,physics)\n    enable_species!(sys,ispec,[1])\n\n    boundary_dirichlet!(sys,ispec,4,cin)\n\n    # Create a solution array\n    inival=unknowns(sys,inival=0)\n\n    # Transient solution of the problem\n    control=VoronoiFVM.NewtonControl()\n    control.Δt=0.01*2.0^(-nref)\n    control.Δt_min=0.01*2.0^(-nref)\n    control.Δt_max=0.1*tend\n    control.force_first_step=true\n    tsol=solve(inival,sys,[0,tend],control=control)\n\n    vis=GridVisualizer(Plotter=Plotter)\n    for i=1:length(tsol.t)\n        scalarplot!(vis[1,1],grid,tsol[1,:,i],flimits=(0,cin+1.0e-5),title=@sprintf(\"time=%3f\",tsol.t[i]),show=true)\n    end\n    tsol\nend\n\nfunction test()\n    tsol=main()\n    all(tsol[end].≈1)\nend\n\nend","category":"page"},{"location":"examples/Example204_HagenPoiseuille/","page":"204: 2D Convection in Hagen-Poiseuille flow","title":"204: 2D Convection in Hagen-Poiseuille flow","text":"","category":"page"},{"location":"examples/Example204_HagenPoiseuille/","page":"204: 2D Convection in Hagen-Poiseuille flow","title":"204: 2D Convection in Hagen-Poiseuille flow","text":"This page was generated using Literate.jl.","category":"page"},{"location":"misc/#Miscellaneous","page":"Miscellaneous","title":"Miscellaneous","text":"","category":"section"},{"location":"misc/#Form-factor-calculatione","page":"Miscellaneous","title":"Form factor calculatione","text":"","category":"section"},{"location":"misc/","page":"Miscellaneous","title":"Miscellaneous","text":"Modules = [VoronoiFVM]\nPages = [\"vfvm_formfactors.jl\"]","category":"page"},{"location":"misc/#VoronoiFVM.edgevelocities-Tuple{Any, Any}","page":"Miscellaneous","title":"VoronoiFVM.edgevelocities","text":"edgevelocities(grid, velofunc)\n\n\nProject velocity onto grid edges,\n\n\n\n\n\n","category":"method"},{"location":"misc/#Additional-grid-methods","page":"Miscellaneous","title":"Additional grid methods","text":"","category":"section"},{"location":"misc/","page":"Miscellaneous","title":"Miscellaneous","text":"Modules = [VoronoiFVM]\nPages = [\"vfvm_xgrid.jl\"]","category":"page"},{"location":"misc/#VoronoiFVM.Grid","page":"Miscellaneous","title":"VoronoiFVM.Grid","text":"Grid=ExtendableGrids.simplexgrid\n\nRe-Export of ExtendableGrids.simplexgrid\n\n\n\n\n\n","category":"function"},{"location":"examples/Example210_NonlinearPoisson2D_Reaction/#:-2D-Nonlinear-Poisson-with-reaction","page":"210: 2D Nonlinear Poisson with reaction","title":"210: 2D Nonlinear Poisson with reaction","text":"","category":"section"},{"location":"examples/Example210_NonlinearPoisson2D_Reaction/","page":"210: 2D Nonlinear Poisson with reaction","title":"210: 2D Nonlinear Poisson with reaction","text":"(source code)","category":"page"},{"location":"examples/Example210_NonlinearPoisson2D_Reaction/","page":"210: 2D Nonlinear Poisson with reaction","title":"210: 2D Nonlinear Poisson with reaction","text":"module Example210_NonlinearPoisson2D_Reaction\n\nusing Printf\nusing VoronoiFVM\nusing ExtendableGrids\nusing GridVisualize\n\nfunction main(;n=10,Plotter=nothing,verbose=false, unknown_storage=:sparse)\n\n    h=1.0/convert(Float64,n)\n    X=collect(0.0:h:1.0)\n    Y=collect(0.0:h:1.0)\n\n    grid=VoronoiFVM.Grid(X,Y)\n    data = (eps=1.0e-2, k=1.0)\n\n    function reaction!(f,u,node,data)\n        f[1]=data.k*(u[1]-u[2])\n        f[2]=data.k*(u[2]-u[1])\n    end\n\n    function flux!(f,u,edge,data)\n        f[1]=data.eps*(u[1,1]-u[1,2])\n        f[2]=data.eps*(u[2,1]-u[2,2])\n    end\n\n    function source!(f,node,data)\n        x1=node[1]-0.5\n        x2=node[2]-0.5\n        f[1]=exp(-20*(x1^2+x2^2))\n    end\n\n    function storage!(f,u,node,data)\n        f[1]=u[1]\n        f[2]=u[2]\n    end\n\n\n    physics=VoronoiFVM.Physics(data=data,\n                               flux=flux!,\n                               storage=storage!,\n                               reaction=reaction!,\n                               source=source!)\n\n\n    sys=VoronoiFVM.System(grid,physics,unknown_storage=unknown_storage)\n\n    enable_species!(sys,1,[1])\n    enable_species!(sys,2,[1])\n\n    inival=unknowns(sys)\n    U=unknowns(sys)\n    inival.=0.0\n\n\n    control=VoronoiFVM.NewtonControl()\n    control.verbose=verbose\n    control.tol_linear=1.0e-5\n    control.max_lureuse=0\n    tstep=0.01\n    time=0.0\n    istep=0\n    u15=0\n    p=GridVisualizer(Plotter=Plotter,layout=(2,1))\n    while time<1\n        time=time+tstep\n        solve!(U,inival,sys,control=control,tstep=tstep)\n        inival.=U\n        if verbose\n            @printf(\"time=%g\\n\",time)\n        end\n        u15=U[15]\n        tstep*=1.0\n        istep=istep+1\n        scalarplot!(p[1,1],grid,U[1,:],clear=true)\n        scalarplot!(p[2,1],grid,U[2,:],show=true)\n    end\n    return u15\nend\n\nfunction test()\n    main(unknown_storage=:sparse) ≈ 0.014566189535134827 &&\n        main(unknown_storage=:dense) ≈ 0.014566189535134827\nend\nend","category":"page"},{"location":"examples/Example210_NonlinearPoisson2D_Reaction/","page":"210: 2D Nonlinear Poisson with reaction","title":"210: 2D Nonlinear Poisson with reaction","text":"","category":"page"},{"location":"examples/Example210_NonlinearPoisson2D_Reaction/","page":"210: 2D Nonlinear Poisson with reaction","title":"210: 2D Nonlinear Poisson with reaction","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/Example108_NonlinearDiffusion1D_ODE/#:-1D-Nonlinear-Diffusion-with-OrdinaryDiffEq","page":"108: 1D Nonlinear Diffusion with OrdinaryDiffEq","title":"108: 1D Nonlinear Diffusion with OrdinaryDiffEq","text":"","category":"section"},{"location":"examples/Example108_NonlinearDiffusion1D_ODE/","page":"108: 1D Nonlinear Diffusion with OrdinaryDiffEq","title":"108: 1D Nonlinear Diffusion with OrdinaryDiffEq","text":"(source code)","category":"page"},{"location":"examples/Example108_NonlinearDiffusion1D_ODE/","page":"108: 1D Nonlinear Diffusion with OrdinaryDiffEq","title":"108: 1D Nonlinear Diffusion with OrdinaryDiffEq","text":"Solve the nonlinear diffusion equation","category":"page"},{"location":"examples/Example108_NonlinearDiffusion1D_ODE/","page":"108: 1D Nonlinear Diffusion with OrdinaryDiffEq","title":"108: 1D Nonlinear Diffusion with OrdinaryDiffEq","text":"partial_t u -Delta u^m = 0","category":"page"},{"location":"examples/Example108_NonlinearDiffusion1D_ODE/","page":"108: 1D Nonlinear Diffusion with OrdinaryDiffEq","title":"108: 1D Nonlinear Diffusion with OrdinaryDiffEq","text":"in Omega=(-11) with homogeneous Neumann boundary conditons using the implicit Euler method.","category":"page"},{"location":"examples/Example108_NonlinearDiffusion1D_ODE/","page":"108: 1D Nonlinear Diffusion with OrdinaryDiffEq","title":"108: 1D Nonlinear Diffusion with OrdinaryDiffEq","text":"This equation is also called  \"porous medium equation\". The Barenblatt solution is an exact solution of this problem which for m>1 has a finite support. We initialize this problem with the exact solution for t=t_0=0001.","category":"page"},{"location":"examples/Example108_NonlinearDiffusion1D_ODE/","page":"108: 1D Nonlinear Diffusion with OrdinaryDiffEq","title":"108: 1D Nonlinear Diffusion with OrdinaryDiffEq","text":"(see Barenblatt, G. I. \"On nonsteady motions of gas and fluid in porous medium.\" Appl. Math. and Mech.(PMM) 16.1 (1952): 67-78.)","category":"page"},{"location":"examples/Example108_NonlinearDiffusion1D_ODE/","page":"108: 1D Nonlinear Diffusion with OrdinaryDiffEq","title":"108: 1D Nonlinear Diffusion with OrdinaryDiffEq","text":"Here, we compare the implicit Euler approach in VoronoiFVM with the ODE solvers in DifferentialEquations.jl and demonstrate the possibility to use VoronoiFVM to define differential operators compatible with its ODEFunction interface.","category":"page"},{"location":"examples/Example108_NonlinearDiffusion1D_ODE/","page":"108: 1D Nonlinear Diffusion with OrdinaryDiffEq","title":"108: 1D Nonlinear Diffusion with OrdinaryDiffEq","text":"At the moment, this code needs OrdinaryDiffEq v6.0.3.","category":"page"},{"location":"examples/Example108_NonlinearDiffusion1D_ODE/","page":"108: 1D Nonlinear Diffusion with OrdinaryDiffEq","title":"108: 1D Nonlinear Diffusion with OrdinaryDiffEq","text":"module Example108_NonlinearDiffusion1D_ODE\n\nusing VoronoiFVM\nusing DifferentialEquations\nusing LinearAlgebra\nusing Printf\nusing GridVisualize\n\nimport Base:push!\n\n\n\n\n\nfunction barenblatt(x,t,m)\n    tx=t^(-1.0/(m+1.0))\n    xx=x*tx\n    xx=xx*xx\n    xx=1- xx*(m-1)/(2.0*m*(m+1));\n    if xx<0.0\n        xx=0.0\n    end\n    return tx*xx^(1.0/(m-1.0))\nend\n\n\nfunction create_porous_medium_problem(n,m,unknown_storage)\n    h=1.0/convert(Float64,n/2)\n    X=collect(-1:h:1)\n    grid=VoronoiFVM.Grid(X)\n\n    function flux!(f,u,edge)\n        f[1]=u[1,1]^m-u[1,2]^m\n    end\n\n    storage!(f,u,node)= f[1]=u[1]\n    sys=VoronoiFVM.System(grid,flux=flux!,storage=storage!, species=1,unknown_storage=unknown_storage)\n    sys,X\nend\n\n\nfunction run_vfvm(;n=20,m=2,t0=0.001, tend=0.01,tstep=1.0e-6,unknown_storage=:dense)\n    sys,X=create_porous_medium_problem(n,m,unknown_storage)\n    inival=unknowns(sys)\n    inival[1,:].=map(x->barenblatt(x,t0,m),X)\n    sol=VoronoiFVM.solve(sys;inival,times=(t0,tend),Δt=tstep,Δu_opt=0.01,Δt_min=tstep,store_all=true,log=true)\n    err=norm(sol[1,:,end]-map(x->barenblatt(x,tend,m),X))\n    sol,sys,err\nend\n\n\nfunction run_diffeq(;n=20,m=2, t0=0.001,tend=0.01, unknown_storage=:dense,solver=nothing)\n    sys,X=create_porous_medium_problem(n,m,unknown_storage)\n    inival=unknowns(sys)\n    inival[1,:].=map(x->barenblatt(x,t0,m),X)\n    problem = ODEProblem(sys,inival,(t0,tend))\n    odesol = DifferentialEquations.solve(problem,Rodas5(linsolve=UMFPACKFactorization()))\n    sol=reshape(odesol,sys)\n    err=norm(sol[1,:,end]-map(x->barenblatt(x,tend,m),X))\n    sol, sys,err\nend\n\n\nfunction main(;m=2,n=20, solver=nothing, unknown_storage=:dense, Plotter=nothing)\n\n    vis=GridVisualizer(Plotter=Plotter,layout=(1,2),resolution=(800,400))\n    t=@elapsed begin\n        sol1,sys,err1=run_vfvm(m=m,n=n, unknown_storage=unknown_storage)\n    end\n    println(history_summary(sys))\n    title=@sprintf(\"VoronoiFVM: %.0f ms e=%.2e\",t*1000,err1)\n    println(title)\n    scalarplot!(vis[1,1],sys,sol1,title=title,aspect=400)\n\n    t=@elapsed begin\n        sol2,sys,err2=run_diffeq(m=m,n=n,solver=solver, unknown_storage=unknown_storage)\n    end\n    println(history_summary(sys))\n    title=@sprintf(\"    DiffEq: %.0f ms, e=%.2e\",t*1000,err2)\n    println(title)\n    scalarplot!(vis[1,2],sys,sol2,title=title,aspect=400)\n    reveal(vis)\n    norm(sol2[end]-sol1[end],Inf)<0.01\n\nend\n\ntest()=main()\n\n#test()=true\n\nend","category":"page"},{"location":"examples/Example108_NonlinearDiffusion1D_ODE/","page":"108: 1D Nonlinear Diffusion with OrdinaryDiffEq","title":"108: 1D Nonlinear Diffusion with OrdinaryDiffEq","text":"","category":"page"},{"location":"examples/Example108_NonlinearDiffusion1D_ODE/","page":"108: 1D Nonlinear Diffusion with OrdinaryDiffEq","title":"108: 1D Nonlinear Diffusion with OrdinaryDiffEq","text":"This page was generated using Literate.jl.","category":"page"},{"location":"changes/#Changes","page":"Changes","title":"Changes","text":"","category":"section"},{"location":"changes/#v0.17.1-August-20-2022","page":"Changes","title":"v0.17.1 August 20 2022","text":"","category":"section"},{"location":"changes/","page":"Changes","title":"Changes","text":"Fix DifferentialEquations interface, start transition to LinearSolve","category":"page"},{"location":"changes/#v0.17.0-July-1-2022","page":"Changes","title":"v0.17.0 July 1 2022","text":"","category":"section"},{"location":"changes/","page":"Changes","title":"Changes","text":"ensure not to assemble data for species where they are not enabled  This change should be breaking only for incorrect code where physics callbacks write into degrees of freedom which are not enabled","category":"page"},{"location":"changes/#v0.16.5-June-30,-2022","page":"Changes","title":"v0.16.5 June 30, 2022","text":"","category":"section"},{"location":"changes/","page":"Changes","title":"Changes","text":"add iteration to solver options, allow to choose :cg, :bicgstab.\nallow setting penalty with boundary_dirichlet!","category":"page"},{"location":"changes/#v0.16.4-May-25,-2022","page":"Changes","title":"v0.16.4 May 25, 2022","text":"","category":"section"},{"location":"changes/","page":"Changes","title":"Changes","text":"fix x-t plots ","category":"page"},{"location":"changes/#v0.16.3-March-18,-2022","page":"Changes","title":"v0.16.3 March 18, 2022","text":"","category":"section"},{"location":"changes/","page":"Changes","title":"Changes","text":"Linearization API\nrelax some type constraints","category":"page"},{"location":"changes/#v0.16.2-Feb-18,-2022","page":"Changes","title":"v0.16.2 Feb 18, 2022","text":"","category":"section"},{"location":"changes/","page":"Changes","title":"Changes","text":"ExtendableGrids 0.9","category":"page"},{"location":"changes/#v0.16.1-Feb-17,-2022","page":"Changes","title":"v0.16.1 Feb 17, 2022","text":"","category":"section"},{"location":"changes/","page":"Changes","title":"Changes","text":"fix quantity postprocessing\ndefine unknown access for abstract vectors instead of vectors\npass rhs/unknowns wrappers in postprocessing methods\nintegrals as a wrapper type with proper quantity handling","category":"page"},{"location":"changes/#v0.16.0-Feb-13,-2022","page":"Changes","title":"v0.16.0 Feb 13, 2022","text":"","category":"section"},{"location":"changes/","page":"Changes","title":"Changes","text":"Expose ODEProblem (and possibly ODEFunc) from VoronoiFVM.System.\nBreaking: Remove solve wrapper for DifferentialEquations.solve, instead recommend to call that directly\nBreaking: Handle DifferentialEquations.jl via Requires.jl.","category":"page"},{"location":"changes/#v0.15.1-Jan-15,-2022","page":"Changes","title":"v0.15.1 Jan 15, 2022","text":"","category":"section"},{"location":"changes/","page":"Changes","title":"Changes","text":"Documentation fixes\nFix OrdinaryDiffEq interface\nadded example for current calculation with Quantities\nFixed type instabilities in quantities interface ","category":"page"},{"location":"changes/#v0.15.0-Jan-1,-2022","page":"Changes","title":"v0.15.0 Jan 1, 2022","text":"","category":"section"},{"location":"changes/","page":"Changes","title":"Changes","text":"Breaking: History is not anymore returned by solve, instead it can be accessed via history after the solution.\nCleaned API:\nVoronoiFVM.solve(system::VoronoiFVM.AbstractSystem; kwargs...) is now the main method of solve which allows to  access stationary, transient, embedding and DifferentialEquations based solvers.\nJoint implementation for implicit Euler timestepping and parameter embedding\nHandle more kwargs via SolverControl (e.g. log)\nUse Parameters.jl in struct definition\nAdd history types NewtonSolverHistory, TransientSolverHistory\ndetailed and summary methods for both history types\nNonlinear solver example notebook (under development): nonlinear-solvers.jl\nOrdinaryDiffEq solver now in CI\nscalarplot for 1D transient solutions\nSparsity detection via Symbolics.jl instead of the sunsetted SparsityDetection.jl","category":"page"},{"location":"changes/#v0.14.0-Dec-24,-2021","page":"Changes","title":"v0.14.0 Dec 24, 2021","text":"","category":"section"},{"location":"changes/","page":"Changes","title":"Changes","text":"Backward compatible, hopefully nonbreaking API simplification","category":"page"},{"location":"changes/","page":"Changes","title":"Changes","text":"Boundary conditions are now specified in breaction. Advantages:\neasy x/t dependency\nunified (upcoming) interface for parameters\nunified handling of standard and nonstandard boundary conditions\nsimpler documentation\nMade NewtonControl alias of SolverControl, continue to work with SolverControl\nSystem constructor now directly takes physics callback functions, no need anymore to work with extra physics struct\nsolve() now takes \"SolverControl\" parameters as kwargs,no need anymore to work with extra NewtonControl/SolverControl struct\nNotebooks as part of documentation and CI\nSee also the pluto notebook api-update.jl","category":"page"},{"location":"changes/#v0.13.2-Oct-29,-2021","page":"Changes","title":"v0.13.2 Oct 29, 2021","text":"","category":"section"},{"location":"changes/","page":"Changes","title":"Changes","text":"Bernoulli function overhaul","category":"page"},{"location":"changes/#v0.13.1","page":"Changes","title":"v0.13.1","text":"","category":"section"},{"location":"changes/","page":"Changes","title":"Changes","text":"sorted things with ExtendableGrids\nnodal flux reconstruction (e.g. for visualization)","category":"page"},{"location":"changes/#v0.13.0,-Oct-13,-2021","page":"Changes","title":"v0.13.0, Oct 13, 2021","text":"","category":"section"},{"location":"changes/","page":"Changes","title":"Changes","text":"various bug fixes, explicit numbering of edge nodes","category":"page"},{"location":"changes/#v0.12.3,-July-7,-2021","page":"Changes","title":"v0.12.3, July 7, 2021","text":"","category":"section"},{"location":"changes/","page":"Changes","title":"Changes","text":"Add quantity id\nDocument quantities","category":"page"},{"location":"changes/#v0.12.2,-July-7,-2021","page":"Changes","title":"v0.12.2, July 7, 2021","text":"","category":"section"},{"location":"changes/","page":"Changes","title":"Changes","text":"Introduce the notion of quantities which can be continuous or discontinuous at interfaces.","category":"page"},{"location":"changes/","page":"Changes","title":"Changes","text":"Quantity handling is implemented on top of species handling\nUnknowns u and rhs y now passed to callbacks as wrapper types,  and can be indexed by quantity or by species numbers.  Moreover, this will allow to abstract parameters, gradients etc. in future versions.","category":"page"},{"location":"changes/#v0.12.0,-July-2-2021","page":"Changes","title":"v0.12.0, July 2 2021","text":"","category":"section"},{"location":"changes/","page":"Changes","title":"Changes","text":"By default, the u parameter in flux callbacks is now a  nspec x 2 array\nunknowns(edge,u), viewK, viewL are obsolete, they still work for backward compatibility\nphysics.num_species is now meaningless, num_species is automatically detected.\nSparseSystem and DenseSystem are now type aliases of a parametrized type instead of two  independent subtypes of System","category":"page"},{"location":"changes/#v0.11.8","page":"Changes","title":"v0.11.8","text":"","category":"section"},{"location":"changes/","page":"Changes","title":"Changes","text":"increase chunk size threshold to match argument length in calls to vectormodejacobian","category":"page"},{"location":"changes/#v0.11.7","page":"Changes","title":"v0.11.7","text":"","category":"section"},{"location":"changes/","page":"Changes","title":"Changes","text":"First attempts on surface flux","category":"page"},{"location":"changes/#v0.11.1,-April-13,-2021","page":"Changes","title":"v0.11.1, April 13, 2021","text":"","category":"section"},{"location":"changes/","page":"Changes","title":"Changes","text":"Assembly loops cleaned from type instabilities\nOptionally check for allocations due to type instabilities introduced in physics callbacks. See check_allocs! for more information.","category":"page"},{"location":"changes/#v0.11,-April-12,-2021","page":"Changes","title":"v0.11, April 12, 2021","text":"","category":"section"},{"location":"changes/","page":"Changes","title":"Changes","text":"Depending on Julia 1.5 now\nLineaer solvers now based on factorize! from ExtendableSparse 0.5\nDocumentation overhaul\nRe-checking impedance calculation","category":"page"},{"location":"changes/#v0.10.13-April-1,-2021","page":"Changes","title":"v0.10.13 April 1, 2021","text":"","category":"section"},{"location":"changes/","page":"Changes","title":"Changes","text":"Outflow boundary conditions","category":"page"},{"location":"changes/#v0.10.8-March-22,-2021","page":"Changes","title":"v0.10.8 March 22, 2021","text":"","category":"section"},{"location":"changes/","page":"Changes","title":"Changes","text":"TransientSolution structure, transient solve\nSolve compatible with DifferentialEquations.jl","category":"page"},{"location":"changes/#v0.10.3-Feb-11,-2021","page":"Changes","title":"v0.10.3 Feb 11, 2021","text":"","category":"section"},{"location":"changes/","page":"Changes","title":"Changes","text":"Introduce non-mutating solve\nOptionally record history if log kw is true in solve.","category":"page"},{"location":"changes/#v0.10.0-Jan-9-2021","page":"Changes","title":"v0.10.0 Jan 9 2021","text":"","category":"section"},{"location":"changes/","page":"Changes","title":"Changes","text":"Moving visualization to the package GridVisualize.jl, emerging from  the visualization methods in ExtendableGrids","category":"page"},{"location":"changes/#v0.9.0-Dec-21-2020","page":"Changes","title":"v0.9.0 Dec 21 2020","text":"","category":"section"},{"location":"changes/","page":"Changes","title":"Changes","text":"Add the possibility to interface with DifferentialEquations.jl\nBreaking: The API change to passing the unknowns to the an edge callback as a matrix turned out to be a dead end in the strategic sense. In order to extend functionality, we need to be able to pass more data to  which we can apply differetiation. Particular plans involve bifurcation parameters and reconstructed gradients. So we return to the viewK/viewL pattern we had before. However,  these are now aliases:\nviewK(edge,u)=unknowns(edge,u,1)\nviewL(edge,u)=unknowns(edge,u,2)\nIn order to ease refactoring in the case where models have been implemented with Matrix access to the unknowns, unknowns(edge,u) returns a matrix of the edge unknowns.    For refactoring, just rewrite e.g.","category":"page"},{"location":"changes/","page":"Changes","title":"Changes","text":"    function flux(y,u,edge)\n        for ispec=1:nspec\n            y[ispec]=u[ispec,1]-u[ispec,2]\n        end\n    end","category":"page"},{"location":"changes/","page":"Changes","title":"Changes","text":"to","category":"page"},{"location":"changes/","page":"Changes","title":"Changes","text":"    function flux(y,u0,edge)\n        u=unknowns(edge,u0)\n        for ispec=1:nspec\n            y[ispec]=u[ispec,1]-u[ispec,2]\n        end\n    end","category":"page"},{"location":"changes/#v0.8.5-Sep-1-2020","page":"Changes","title":"v0.8.5 Sep 1 2020","text":"","category":"section"},{"location":"changes/","page":"Changes","title":"Changes","text":"allow any object in Physics.data  (thanks Jan Weidner)\nadd generic operator for non-canonical problem structures","category":"page"},{"location":"changes/#v0.8.4-July-25-2020","page":"Changes","title":"v0.8.4 July 25 2020","text":"","category":"section"},{"location":"changes/","page":"Changes","title":"Changes","text":"Update ExtendableGrids + ExtendableSparse","category":"page"},{"location":"changes/#v0.8.3-June-25-2020","page":"Changes","title":"v0.8.3 June 25 2020","text":"","category":"section"},{"location":"changes/","page":"Changes","title":"Changes","text":"Replace splatting by dispatch on availability of data record","category":"page"},{"location":"changes/#v0.8.2-May-15-2020","page":"Changes","title":"v0.8.2 May 15 2020","text":"","category":"section"},{"location":"changes/","page":"Changes","title":"Changes","text":"Form factors are now pre-calculated and stored\nIntroduced update_grid! for triggering re-calculation if coordinates have changed","category":"page"},{"location":"changes/#v0.8.1-May-2-2020","page":"Changes","title":"v0.8.1 May 2 2020","text":"","category":"section"},{"location":"changes/","page":"Changes","title":"Changes","text":"Introduce evolve! : time solver with automatic timestep control","category":"page"},{"location":"changes/#v0.8-Apr-28,-2020","page":"Changes","title":"v0.8 Apr 28, 2020","text":"","category":"section"},{"location":"changes/","page":"Changes","title":"Changes","text":"Replaced VoronoiFVM grid module by  ExtendableGrids.jl\nMoved grid generation, modification, plotting  over to ExtendableGrids\nNecessary changes in codes using VoronoiFVM:\nReplace grid.coord by coord obtained via coord=coordinates(grid) or  coord=grid[Coordinates] after importing ExtendableGrids\nReplace VoronoiFVM.plot by ExtendableGrids.plot.\nIn the plot method, Plotter is now a keyword argument\nVoronoiFVM.Grid() now returns a ExtendableGrids.ExtendableGrid,  in fact it is just an alias to ExtendableGrids.simplexgrid\nFor using any methods on grids like cellmask! one nees to use ExtendableGrids\nSubgrids now are of the same type ExtendableGrids,  views are currently defined for vectors only.","category":"page"},{"location":"changes/#v0.7-Feb-28-2020","page":"Changes","title":"v0.7 Feb 28 2020","text":"","category":"section"},{"location":"changes/","page":"Changes","title":"Changes","text":"API modification:\nBreaking:\ndata parameter passed to physics callbacks only if Physics object is created with data parameter.\nThis makes the API more consistent in the case that parameters are just taken from the closure (the scope where the physics functions are defined) and no data object has been created.\nReplace node.coord[i] by  node[i].\nReplace edge.coordK[i] by  edge[i,1].\nReplace edge.coordL[i] by  edge[i,2].\nThis now directly accesses the coordinate field of the grid and avoids copying of the coordinates\nBackward compatible:  \nNo need for viewK and viewL in edge callbacks (they also make trouble with allocations...)\nReplace uk[i] by u[i,1]\nReplace ul[i] by u[i,2]\nReplace VoronoiFVM.DenseSystem(...)  by VoronoiFVM.System(..., unknown_storage=:dense)\nReplace VoronoiFVM.SparseSystem(...) by VoronoiFVM.System(..., unknown_storage=:sparse)\nNo allocations anymore in assembly loop:\nReplaced ElasticArray in Grid by normal one - this was the largest regression\nReturn nothing from mutating methods to avoid some allocations \nIndexing in formfactors.jl with Int","category":"page"},{"location":"changes/#v0.6.5-Jan-25-2020","page":"Changes","title":"v0.6.5 Jan 25 2020","text":"","category":"section"},{"location":"changes/","page":"Changes","title":"Changes","text":"use updateindex! for matrix, depend on ExtendableSparse 0.2.6","category":"page"},{"location":"changes/#v0.6.4-2020-01-20","page":"Changes","title":"v0.6.4 2020-01-20","text":"","category":"section"},{"location":"changes/","page":"Changes","title":"Changes","text":"Rearranged + commented boundary assembly loop\nReworked + renamed some examples\nDocument that unknowns doesn't initialize values.","category":"page"},{"location":"changes/#v0.6.3-2019-12-21","page":"Changes","title":"v0.6.3 2019-12-21","text":"","category":"section"},{"location":"changes/","page":"Changes","title":"Changes","text":"remove xcolptrs call Update dependency on ExtendableSparse","category":"page"},{"location":"changes/#v0.6.2-2019-12-20","page":"Changes","title":"v0.6.2 2019-12-20","text":"","category":"section"},{"location":"changes/","page":"Changes","title":"Changes","text":"Updated dependency list (Triangulate ^0.4.0)","category":"page"},{"location":"changes/#v0.6.1,-2019-12-17","page":"Changes","title":"v0.6.1, 2019-12-17","text":"","category":"section"},{"location":"changes/","page":"Changes","title":"Changes","text":"return \"plotted\" for being able to  place colormap\nrequire Triangulate >= 0.3.0","category":"page"},{"location":"changes/#v0.6.0,-Dec-15-2019","page":"Changes","title":"v0.6.0, Dec 15 2019","text":"","category":"section"},{"location":"changes/","page":"Changes","title":"Changes","text":"Removed Triangle submodule, depend on new Triangulate.jl Triangle wrapper\nlink to source code in examples\nboundary_dirichlet! etc methods for setting boundary conditions","category":"page"},{"location":"changes/#v0.5.6-Dec-5-2019","page":"Changes","title":"v0.5.6 Dec 5 2019","text":"","category":"section"},{"location":"changes/","page":"Changes","title":"Changes","text":"Bug fixes\ncheck triangle input for min 3 points\ncheck triangle edgelist for C_NULL\nvoronoi plot","category":"page"},{"location":"changes/#v0.5.5-Dec-4-2019","page":"Changes","title":"v0.5.5 Dec 4 2019","text":"","category":"section"},{"location":"changes/","page":"Changes","title":"Changes","text":"(Temporary) Copy of TriangleRaw as Triangle submodule. To be replaced by dependency on evisioned package","category":"page"},{"location":"changes/#v0.5.4-Dec-3-2019","page":"Changes","title":"v0.5.4 Dec 3 2019","text":"","category":"section"},{"location":"changes/","page":"Changes","title":"Changes","text":"Re-enabled ElasticArrays in grid structure (for the time being)\nAdded potkink example: this adds an inner boudary","category":"page"},{"location":"changes/#v0.5.3-Dec-1-2019","page":"Changes","title":"v0.5.3 Dec 1 2019","text":"","category":"section"},{"location":"changes/","page":"Changes","title":"Changes","text":"triangle in optional submodule\nModified API for plotting\nRemoved formal dependency on Plots and PyPlot\nUse Plotter module as first parameter to plot methods  - replaces fvmplot and fvmpyplot functions. Use VoronoiFVM.plot(PyPlot,...) resp.  VoronoiFVM.plot(Plots,...)\nNo more complaints when package is used in environment with plots or pyplot installed\nModified API for impedance","category":"page"},{"location":"changes/#v0.5.2-Nov-19,-2019","page":"Changes","title":"v0.5.2 Nov 19, 2019","text":"","category":"section"},{"location":"changes/","page":"Changes","title":"Changes","text":"Reorganized grid stuff\nIncluded triangle (after Ideas from TriangleMesh.jl)","category":"page"},{"location":"changes/#v0.5.1-Nov-13,-2019","page":"Changes","title":"v0.5.1 Nov 13, 2019","text":"","category":"section"},{"location":"changes/","page":"Changes","title":"Changes","text":"Fixed performance regression: AbstractArrays for Grid components were slow.\nAdded handling of cylindrical coordinates","category":"page"},{"location":"changes/#V0.5,-November-10,-2019","page":"Changes","title":"V0.5, November 10, 2019","text":"","category":"section"},{"location":"changes/","page":"Changes","title":"Changes","text":"Velocity projections\nAdded edge handling to grid struct","category":"page"},{"location":"changes/#V0.4.2,-November-6,-2019","page":"Changes","title":"V0.4.2, November 6, 2019","text":"","category":"section"},{"location":"changes/","page":"Changes","title":"Changes","text":"Replaced PyPlot by Plots\nBetter and more examples","category":"page"},{"location":"changes/#V0.4,-July-12,-2019","page":"Changes","title":"V0.4, July 12, 2019","text":"","category":"section"},{"location":"changes/","page":"Changes","title":"Changes","text":"Registered with Julia ecosystem\nEnhance Newton solver by embedding, exception handling\nReplace SparseMatrixCSC with ExtendableSparseMatrix\nfixed allocation issues in assembly\nassured that users get allocation stuff right via typed functions in physics structure\nmore julianic API","category":"page"},{"location":"changes/#V0.3,-April-9-2019","page":"Changes","title":"V0.3, April 9 2019","text":"","category":"section"},{"location":"changes/","page":"Changes","title":"Changes","text":"Renamed from TwoPointFluxFVM to  VoronoiFVM\nComplete rewrite of assembly allowing sparse or dense matrix  to store degree of freedom information\nSolution is a nnodes x nspecies sparse or dense matrix\nThe wonderful array interface of Julia still provides slicing etc in oder to access  species without need to write any bulk_solution stuff or whatever when using the sparse variant\nRe-export value() for debugging in physics functions\nTest function handling for flux calculation\nFirst working steps to impedance handling\nAbolished Graph in favor of  Grid, Graph was premature optimization...","category":"page"},{"location":"changes/#V0.2,-Feb-20,-2019","page":"Changes","title":"V0.2, Feb 20, 2019","text":"","category":"section"},{"location":"changes/","page":"Changes","title":"Changes","text":"Changed signature of all callback functions: This also allows to pass user defined arrays etc. to the callback functions. In particular, velocity vectors can be passed this way.\nBesides of flux!(), they now all have node::VoronoiFVM.Node as a second argument.\nflux!() has edge::VoronoiFVM.Edge as a second argument\nthe x argument in source!() is omitted, the same data  are now found in node.coord","category":"page"},{"location":"changes/","page":"Changes","title":"Changes","text":"New method edgelength(edge::VoronoiFVM.Edge)","category":"page"},{"location":"changes/#V0.1,-Dec.-2018","page":"Changes","title":"V0.1, Dec. 2018","text":"","category":"section"},{"location":"changes/","page":"Changes","title":"Changes","text":"Initial release","category":"page"},{"location":"runexamples/#About-the-examples","page":"About the examples","title":"About the examples","text":"","category":"section"},{"location":"runexamples/","page":"About the examples","title":"About the examples","text":"The examples have been designed with the following issues in mind:","category":"page"},{"location":"runexamples/","page":"About the examples","title":"About the examples","text":"they run from the Julia REPL\neach example is a Julia module named similar to the basename of the example file.\nan example can be used as the starting point for a project \nthe examples at the same time comprise the test suite for VoronoiFVM.","category":"page"},{"location":"runexamples/","page":"About the examples","title":"About the examples","text":"Since the creation of these examples, the API has been updated and simplified.","category":"page"},{"location":"runexamples/#Running-the-examples","page":"About the examples","title":"Running the examples","text":"","category":"section"},{"location":"runexamples/","page":"About the examples","title":"About the examples","text":"Plotting is performed using the GridVisualize.jl package which interfaces PyPlot.jl, Plots.jl, Makie.jl.","category":"page"},{"location":"runexamples/","page":"About the examples","title":"About the examples","text":"In order to run ExampleXXX, peform the following steps:","category":"page"},{"location":"runexamples/","page":"About the examples","title":"About the examples","text":"Download the example file (e.g. via the source code link at the top)\nCall Julia with  an Julia environment which contains VoronoiFVM.jl, ExtendableGrids.jl, GridVisualize.jl  and e.g. PyPlot.jl\ninclude(\"ExampleXXX.jl\")\nRun the example via ExampleXXX.main(Plotter=PyPlot)","category":"page"},{"location":"runexamples/","page":"About the examples","title":"About the examples","text":"Due to the encapsulation into modules, you can load as many examples as you like.","category":"page"},{"location":"runexamples/","page":"About the examples","title":"About the examples","text":"If you want to modifiy the example, consider using Revise.jl and includet. ","category":"page"},{"location":"runexamples/#Performance-with-closures","page":"About the examples","title":"Performance with  closures","text":"","category":"section"},{"location":"runexamples/","page":"About the examples","title":"About the examples","text":"VoronoiFVM provides two flavors of calbacks for constitutive functions: ","category":"page"},{"location":"runexamples/","page":"About the examples","title":"About the examples","text":"Callbacks with data parameoter. data is declared as part of Physics and passed down to the callbacks\nCallbacks without data parameter. Here, the parameters of the  physics callbacks are accessed via closures, i.e. from within the  scope of the definition of the particular function.","category":"page"},{"location":"runexamples/","page":"About the examples","title":"About the examples","text":"While the  second method is  very convenient to  use, it comes  with a serious performance pitfall: if a  variable in the closure is assigned twice, Julia becomes unsure about  it's type and therefore \"boxes\" it, i.e. it  creates a wrapper struct  around the variable value  which is able to track  its potentially changing type.  The serious consequence of this is that assignments to a boxed variable lead to allocations, which are a serious performance hit if they occur in loops over grid nodes or edges.","category":"page"},{"location":"runexamples/","page":"About the examples","title":"About the examples","text":"This behaviour is explained in the Julia documentation.","category":"page"},{"location":"runexamples/","page":"About the examples","title":"About the examples","text":"Here is an example which comes close to the situation in VoronoiFVM:","category":"page"},{"location":"runexamples/","page":"About the examples","title":"About the examples","text":"function ttype_boxed(n)\n    u=rand(n)\n    v=similar(u)\n    a=2.0\n    a=3.0\n    dostuff(u)=a*u\n    @allocated map!(dostuff,v,u)\nend\nttype_boxed(10) # hide\nttype_boxed(10)","category":"page"},{"location":"runexamples/","page":"About the examples","title":"About the examples","text":"The remedy is to type-annotate variables from closures:","category":"page"},{"location":"runexamples/","page":"About the examples","title":"About the examples","text":"function ttype_annotated(n)\n    u=rand(n)\n    v=similar(u)\n    a::Float64=2.0\n    a=3.0\n    dostuff(u)=a*u\n    @allocated map!(dostuff,v,u)\nend\nttype_annotated(10) # hide\nttype_annotated(10)","category":"page"},{"location":"runexamples/","page":"About the examples","title":"About the examples","text":"VoronoiFVM provides a mechanism to check for this situation with the check_allocs! method. After creating a system, set","category":"page"},{"location":"runexamples/","page":"About the examples","title":"About the examples","text":"check_allocs!(system,true)","category":"page"},{"location":"runexamples/","page":"About the examples","title":"About the examples","text":"and allocations inner assembly loops will throw an error.","category":"page"},{"location":"runexamples/","page":"About the examples","title":"About the examples","text":"To set this behavior as default for all systems you create, invoke ","category":"page"},{"location":"runexamples/","page":"About the examples","title":"About the examples","text":"ENV[\"VORONOIFVM_CHECK_ALLOCS\"]=\"true\"","category":"page"},{"location":"runexamples/","page":"About the examples","title":"About the examples","text":"before using VoronoiFVM, e.g. put it  into your startup.jl","category":"page"},{"location":"examples/Example107_NonlinearStorage1D/#:-1D-Nonlinear-Storage","page":"107: 1D Nonlinear Storage","title":"107: 1D Nonlinear Storage","text":"","category":"section"},{"location":"examples/Example107_NonlinearStorage1D/","page":"107: 1D Nonlinear Storage","title":"107: 1D Nonlinear Storage","text":"(source code)","category":"page"},{"location":"examples/Example107_NonlinearStorage1D/","page":"107: 1D Nonlinear Storage","title":"107: 1D Nonlinear Storage","text":"This equation comes from the transformation of the nonlinear diffuision equation.","category":"page"},{"location":"examples/Example107_NonlinearStorage1D/","page":"107: 1D Nonlinear Storage","title":"107: 1D Nonlinear Storage","text":"partial_t u^frac1m -Delta u = 0","category":"page"},{"location":"examples/Example107_NonlinearStorage1D/","page":"107: 1D Nonlinear Storage","title":"107: 1D Nonlinear Storage","text":"in Omega=(-11) with homogeneous Neumann boundary conditions. We can derive an exact solution from the Barenblatt solution of the previous example.","category":"page"},{"location":"examples/Example107_NonlinearStorage1D/","page":"107: 1D Nonlinear Storage","title":"107: 1D Nonlinear Storage","text":"module Example107_NonlinearStorage1D\nusing Printf\nusing VoronoiFVM\nusing ExtendableGrids\nusing GridVisualize\n\nfunction barenblatt(x,t,m)\n    tx=t^(-1.0/(m+1.0))\n    xx=x*tx\n    xx=xx*xx\n    xx=1- xx*(m-1)/(2.0*m*(m+1));\n    if xx<0.0\n        xx=0.0\n    end\n    return tx*xx^(1.0/(m-1.0))\nend\n\n\nfunction main(;n=20,m=2.0,Plotter=nothing,verbose=false, unknown_storage=:sparse,tend=0.01,tstep=0.0001)\n\n    # Create a one-dimensional discretization\n    h=1.0/convert(Float64,n/2)\n    X=collect(-1:h:1)\n    grid=VoronoiFVM.Grid(X)\n\n    # Flux function which describes the flux\n    # between neigboring control volumes\n    function flux!(f,u,edge)\n        f[1]=u[1,1]-u[1,2]\n    end\n\n    ϵ=1.0e-10\n\n    # Storage term\n    # This needs to be regularized as its derivative\n    # at 0 is infinity\n    function storage!(f,u,node)\n        f[1]=(ϵ+u[1])^(1.0/m)\n    end\n\n    # Create a physics structure\n    physics=VoronoiFVM.Physics(\n        flux=flux!,\n        storage=storage!)\n\n\n    # Create a finite volume system - either\n    # in the dense or  the sparse version.\n    # The difference is in the way the solution object\n    # is stored - as dense or as sparse matrix\n    sys=VoronoiFVM.System(grid,physics,unknown_storage=unknown_storage)\n\n    # Add species 1 to region 1\n    enable_species!(sys,1,[1])\n\n    # Create a solution array\n    inival=unknowns(sys)\n    solution=unknowns(sys)\n    t0=0.001\n\n    # Broadcast the initial value\n    inival[1,:].=map(x->barenblatt(x,t0,m)^m,X)\n\n    # Create solver control info\n    control=VoronoiFVM.NewtonControl()\n    control.verbose=verbose\n    control.Δu_opt=0.1\n    control.force_first_step=true\n    tsol=solve(inival,sys,[t0,tend],control=control)\n\n    p=GridVisualizer(Plotter=Plotter,layout=(1,1),fast=true)\n    for i=1:length(tsol)\n        time=tsol.t[i]\n        scalarplot!(p[1,1],grid,tsol[1,:,i],title=@sprintf(\"t=%.3g\",time),color=:red,label=\"numerical\")\n        scalarplot!(p[1,1],grid,map(x->barenblatt(x,time,m)^m,grid),clear=false,color=:green,label=\"exact\")\n        reveal(p)\n        sleep(1.0e-2)\n    end\n\n    return sum(tsol[end])\nend\n\n\nfunction test()\n    testval=175.20261258406686\n    main(unknown_storage=:sparse) ≈ testval && main(unknown_storage=:dense) ≈ testval\nend\n\nend","category":"page"},{"location":"examples/Example107_NonlinearStorage1D/","page":"107: 1D Nonlinear Storage","title":"107: 1D Nonlinear Storage","text":"","category":"page"},{"location":"examples/Example107_NonlinearStorage1D/","page":"107: 1D Nonlinear Storage","title":"107: 1D Nonlinear Storage","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/Example203_CoordinateSystems/#:-Various-coordinate-systems","page":"203: Various coordinate systems","title":"203: Various coordinate systems","text":"","category":"section"},{"location":"examples/Example203_CoordinateSystems/","page":"203: Various coordinate systems","title":"203: Various coordinate systems","text":"(source code)","category":"page"},{"location":"examples/Example203_CoordinateSystems/","page":"203: Various coordinate systems","title":"203: Various coordinate systems","text":"module Example203_CoordinateSystems\n\nusing VoronoiFVM\nusing LinearAlgebra\nusing ExtendableGrids\nusing GridVisualize\n\nfunction main(;nref=0,r1=0.0, r2=5.0, dim=2,Plotter=nothing)\n    h=0.1*2.0^(-nref)\n    R=collect(r1:h:r2)\n    Z=collect(0:h:2)\n    grid=VoronoiFVM.Grid(R)\n    if dim==2\n        grid=VoronoiFVM.Grid(R,Z)\n    end\n    circular_symmetric!(grid)\n\n    function symlapcyl(r)\n        if r1≈0.0\n            return 0.25*(r2*r2-r*r);\n        else\n            return (log(r)-log(r2))/(log(r1)-log(r2));\n        end\n    end\n\n    function flux!(f,u,edge)\n        f[1]=u[1,1]-u[1,2]\n    end\n\n    function source!(f,node)\n        if r1≈0.0\n            f[1]=1.0\n        else\n            f[1]=0.0\n        end\n    end","category":"page"},{"location":"examples/Example203_CoordinateSystems/","page":"203: Various coordinate systems","title":"203: Various coordinate systems","text":"Create a physics structure","category":"page"},{"location":"examples/Example203_CoordinateSystems/","page":"203: Various coordinate systems","title":"203: Various coordinate systems","text":"    physics=VoronoiFVM.Physics(flux=flux!,source=source!)\n    sys=VoronoiFVM.System(grid,physics,unknown_storage=:dense)\n    ispec=1\n    enable_species!(sys,ispec,[1])\n    ileft=1\n    if dim==2\n        ileft=4\n    end\n    if !(r1≈0.0)\n        boundary_dirichlet!(sys,ispec,ileft,1.0)\n    end\n    boundary_dirichlet!(sys,ispec,2,0.0)\n\n    inival=unknowns(sys)\n    solution=unknowns(sys)\n    inival.=0\n    solution.=0","category":"page"},{"location":"examples/Example203_CoordinateSystems/","page":"203: Various coordinate systems","title":"203: Various coordinate systems","text":"Solve stationary problem","category":"page"},{"location":"examples/Example203_CoordinateSystems/","page":"203: Various coordinate systems","title":"203: Various coordinate systems","text":"    solve!(solution,inival,sys)\n\n    exact=symlapcyl.(coordinates(grid)[1,:])\n    vis=GridVisualizer(Plotter=Plotter,layout=(2,1))\n    scalarplot!(vis[1,1],grid,solution[1,:],title=\"numerical\")\n    scalarplot!(vis[2,1],grid,exact,title=\"exact\",show=true)\n\n    err=norm(solution[1,:]-exact,Inf)\nend","category":"page"},{"location":"examples/Example203_CoordinateSystems/","page":"203: Various coordinate systems","title":"203: Various coordinate systems","text":"Called by unit test","category":"page"},{"location":"examples/Example203_CoordinateSystems/","page":"203: Various coordinate systems","title":"203: Various coordinate systems","text":"function test()\n    main() <1.0e-14\nend\n\nend","category":"page"},{"location":"examples/Example203_CoordinateSystems/","page":"203: Various coordinate systems","title":"203: Various coordinate systems","text":"","category":"page"},{"location":"examples/Example203_CoordinateSystems/","page":"203: Various coordinate systems","title":"203: Various coordinate systems","text":"This page was generated using Literate.jl.","category":"page"},{"location":"nbhtml/nonlinear-solvers/#nonlinear-solvers","page":"Nonlinear solver control","title":"nonlinear-solvers.jl","text":"","category":"section"},{"location":"nbhtml/nonlinear-solvers/","page":"Nonlinear solver control","title":"Nonlinear solver control","text":"Download this Pluto.jl notebook.","category":"page"},{"location":"nbhtml/nonlinear-solvers/","page":"Nonlinear solver control","title":"Nonlinear solver control","text":"<iframe style=\"height:15000px\" width=\"100%\" src=\"../nonlinear-solvers.html\"> </iframe>","category":"page"},{"location":"examples/Example220_NonlinearPoisson2D_BoundarySpecies/#:-2D-Nonlinear-Poisson-with-boundary-reaction-and-boundary-species","page":"220: 2D Nonlinear Poisson with boundary reaction and boundary species","title":"220: 2D Nonlinear Poisson with boundary reaction and boundary species","text":"","category":"section"},{"location":"examples/Example220_NonlinearPoisson2D_BoundarySpecies/","page":"220: 2D Nonlinear Poisson with boundary reaction and boundary species","title":"220: 2D Nonlinear Poisson with boundary reaction and boundary species","text":"(source code)","category":"page"},{"location":"examples/Example220_NonlinearPoisson2D_BoundarySpecies/","page":"220: 2D Nonlinear Poisson with boundary reaction and boundary species","title":"220: 2D Nonlinear Poisson with boundary reaction and boundary species","text":"module Example220_NonlinearPoisson2D_BoundarySpecies\n\nusing Printf\nusing VoronoiFVM\nusing ExtendableGrids\nusing GridVisualize\n\nfunction main(;n=10,Plotter=nothing,verbose=false,unknown_storage=:sparse)\n\n\n    h=1.0/convert(Float64,n)\n    X=collect(0.0:h:1.0)\n    Y=collect(0.0:h:1.0)\n\n\n\n    grid=VoronoiFVM.Grid(X,Y)\n\n    k=1.0\n    eps::Float64=1.0\n    physics=VoronoiFVM.Physics(\n    breaction=function(f,u,node)\n        if  node.region==2\n            f[1]=k*(u[1]-u[3])\n            f[3]=k*(u[3]-u[1])+ k*(u[3]-u[2])\n            f[2]=k*(u[2]-u[3])\n        end\n    end,\n\n    bstorage=function(f,u,node)\n        if  node.region==2\n            f[3]=u[3]\n        end\n    end,\n\n\n    flux=function(f,u,edge)\n        f[1]=eps*(u[1,1]-u[1,2])\n        f[2]=eps*(u[2,1]-u[2,2])\n    end,\n\n    source=function(f,node)\n        x1=node[1]-0.5\n        x2=node[2]-0.5\n        f[1]=exp(-20.0*(x1^2+x2^2))\n    end,\n\n    storage=function(f,u,node)\n        f[1]=u[1]\n        f[2]=u[2]\n    end\n    )\n\n    sys=VoronoiFVM.System(grid,physics,unknown_storage=unknown_storage)\n\n    enable_species!(sys,1,[1])\n    enable_species!(sys,2,[1])\n    enable_boundary_species!(sys,3,[2])\n\n\n    function tran32!(a,b)\n        a[1]=b[2]\n    end\n\n    bgrid2=subgrid(grid,[2],boundary=true,transform=tran32!)\n\n    inival=unknowns(sys)\n    inival.=0.0\n    U=unknowns(sys)\n\n    eps=1.0e-2\n\n    control=VoronoiFVM.NewtonControl()\n    control.verbose=verbose\n    control.tol_linear=1.0e-5\n    control.tol_relative=1.0e-5\n    control.max_lureuse=0\n    tstep=0.01\n    time=0.0\n    istep=0\n    u5=0\n    p=GridVisualizer(Plotter=Plotter,layout=(3,1))\n    while time<1\n        time=time+tstep\n        solve!(U,inival,sys,control=control,tstep=tstep)\n        inival.=U\n        if verbose\n            @printf(\"time=%g\\n\",time)\n        end\n        tstep*=1.0\n        istep=istep+1\n        U_bound=view(U[3,:],bgrid2)\n        u5=U_bound[5]\n        scalarplot!(p[1,1],grid,U[1,:],clear=true)\n        scalarplot!(p[2,1],grid,U[2,:])\n        scalarplot!(p[3,1],bgrid2,U_bound,show=true,flimits=(0,0.0025))\n    end\n    return u5\nend\n\nfunction test()\n    main(unknown_storage=:sparse) ≈ 0.0020781361856598\n    main(unknown_storage=:dense) ≈ 0.0020781361856598\nend\nend","category":"page"},{"location":"examples/Example220_NonlinearPoisson2D_BoundarySpecies/","page":"220: 2D Nonlinear Poisson with boundary reaction and boundary species","title":"220: 2D Nonlinear Poisson with boundary reaction and boundary species","text":"","category":"page"},{"location":"examples/Example220_NonlinearPoisson2D_BoundarySpecies/","page":"220: 2D Nonlinear Poisson with boundary reaction and boundary species","title":"220: 2D Nonlinear Poisson with boundary reaction and boundary species","text":"This page was generated using Literate.jl.","category":"page"},{"location":"nbhtml/api-update/#api-update","page":"0.14.0 API Update","title":"api-update.jl","text":"","category":"section"},{"location":"nbhtml/api-update/","page":"0.14.0 API Update","title":"0.14.0 API Update","text":"Download this Pluto.jl notebook.","category":"page"},{"location":"nbhtml/api-update/","page":"0.14.0 API Update","title":"0.14.0 API Update","text":"<iframe style=\"height:15000px\" width=\"100%\" src=\"../api-update.html\"> </iframe>","category":"page"},{"location":"examples/Example205_NonlinearPoisson2D/#:-2D-Nonlinear-Poisson-equation","page":"205: 2D Nonlinear Poisson equation","title":"205: 2D Nonlinear Poisson equation","text":"","category":"section"},{"location":"examples/Example205_NonlinearPoisson2D/","page":"205: 2D Nonlinear Poisson equation","title":"205: 2D Nonlinear Poisson equation","text":"(source code)","category":"page"},{"location":"examples/Example205_NonlinearPoisson2D/","page":"205: 2D Nonlinear Poisson equation","title":"205: 2D Nonlinear Poisson equation","text":"module Example205_NonlinearPoisson2D\n\nusing Printf\nusing VoronoiFVM\nusing ExtendableGrids\nusing ExtendableSparse\nusing GridVisualize\n\n\n\nfunction main(;n=10,Plotter=nothing,verbose=false, unknown_storage=:sparse, max_lureuse=0,\n              factorization=LUFactorization(),iteration=:cg)\n    h=1.0/convert(Float64,n)\n    X=collect(0.0:h:1.0)\n    Y=collect(0.0:h:1.0)\n\n\n    grid=VoronoiFVM.Grid(X,Y)\n\n    eps=1.0e-2\n\n    physics=VoronoiFVM.Physics(\n        reaction=function(f,u,node)\n        f[1]=u[1]^2\n        end,\n\n        flux=function(f,u,edge)\n        f[1]=eps*(u[1,1]^2-u[1,2]^2)\n        end,\n\n        source=function(f,node)\n        x1=node[1]-0.5\n        x2=node[2]-0.5\n        f[1]=exp(-20.0*(x1^2+x2^2))\n        end,\n\n        storage=function(f,u,node)\n        f[1]=u[1]\n        end)\n    sys=VoronoiFVM.System(grid,physics,unknown_storage=unknown_storage)\n    enable_species!(sys,1,[1])\n\n    boundary_dirichlet!(sys,1,2,0.1)\n    boundary_dirichlet!(sys,1,4,0.1)\n\n    inival=unknowns(sys)\n    U=unknowns(sys)\n    inival.=0.5\n\n\n    control=VoronoiFVM.NewtonControl()\n    control.verbose=verbose\n    control.iteration=iteration\n    control.tol_linear=1.0e-5\n    control.max_lureuse=max_lureuse\n    control.factorization=factorization\n    tstep=0.01\n    time=0.0\n    u15=0\n    p=GridVisualizer(Plotter=Plotter)\n    while time<1.0\n        time=time+tstep\n        solve!(U,inival,sys,control=control,tstep=tstep)\n        u15=U[15]\n        inival.=U\n\n        if verbose\n            @printf(\"time=%g\\n\",time)\n        end\n\n        scalarplot!(p[1,1],grid,U[1,:],Plotter=Plotter,clear=true,show=true)\n        tstep*=1.0\n    end\n    return u15\nend\n\nfunction test()","category":"page"},{"location":"examples/Example205_NonlinearPoisson2D/","page":"205: 2D Nonlinear Poisson equation","title":"205: 2D Nonlinear Poisson equation","text":"test at once for iterative solution here","category":"page"},{"location":"examples/Example205_NonlinearPoisson2D/","page":"205: 2D Nonlinear Poisson equation","title":"205: 2D Nonlinear Poisson equation","text":"    testval=0.3554284760906605\n    main(unknown_storage=:sparse,max_lureuse=0) ≈  testval &&\n        main(unknown_storage=:dense,max_lureuse=0) ≈ testval &&\n        main(unknown_storage=:sparse,max_lureuse=10) ≈ testval &&\n        main(unknown_storage=:dense,max_lureuse=10) ≈ testval &&\n        main(unknown_storage=:sparse,max_lureuse=0, factorization=ILU0Preconditioner(), iteration=:cg) ≈ testval &&\n        main(unknown_storage=:dense,max_lureuse=0, factorization=ILU0Preconditioner(), iteration=:bicgstab) ≈ testval\nend\nend","category":"page"},{"location":"examples/Example205_NonlinearPoisson2D/","page":"205: 2D Nonlinear Poisson equation","title":"205: 2D Nonlinear Poisson equation","text":"","category":"page"},{"location":"examples/Example205_NonlinearPoisson2D/","page":"205: 2D Nonlinear Poisson equation","title":"205: 2D Nonlinear Poisson equation","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/Example215_NonlinearPoisson2D_BoundaryReaction/#:-2D-Nonlinear-Poisson-with-boundary-reaction","page":"215: 2D Nonlinear Poisson with boundary reaction","title":"215: 2D Nonlinear Poisson with boundary reaction","text":"","category":"section"},{"location":"examples/Example215_NonlinearPoisson2D_BoundaryReaction/","page":"215: 2D Nonlinear Poisson with boundary reaction","title":"215: 2D Nonlinear Poisson with boundary reaction","text":"(source code)","category":"page"},{"location":"examples/Example215_NonlinearPoisson2D_BoundaryReaction/","page":"215: 2D Nonlinear Poisson with boundary reaction","title":"215: 2D Nonlinear Poisson with boundary reaction","text":"module Example215_NonlinearPoisson2D_BoundaryReaction\n\nusing Printf\nusing VoronoiFVM\nusing ExtendableGrids\nusing GridVisualize\nusing ExtendableSparse\n\nfunction main(;n=10,Plotter=nothing,verbose=false, unknown_storage=:sparse,tend=100,max_lureuse=0,\n              factorization=LUFactorization())\n    h=1.0/convert(Float64,n)\n    X=collect(0.0:h:1.0)\n    Y=collect(0.0:h:1.0)\n\n    grid=VoronoiFVM.Grid(X,Y)\n\n\n    eps=1.0e-2\n    physics=VoronoiFVM.Physics(\n        breaction=function(f,u,node)\n        if  node.region==2\n            f[1]=1*(u[1]-u[2])\n            f[2]=1*(u[2]-u[1])\n        else\n            f[1]=0\n            f[2]=0\n        end\n        end,\n\n    flux=function(f,u,edge)\n        f[1]=eps*(u[1,1]-u[1,2])\n        f[2]=eps*(u[2,1]-u[2,2])\n    end,\n\n\n    storage=function(f,u,node)\n        f[1]=u[1]\n        f[2]=u[2]\n    end)\n\n    sys=VoronoiFVM.System(grid,physics,unknown_storage=unknown_storage)\n    enable_species!(sys,1,[1])\n    enable_species!(sys,2,[1])\n\n\n    inival=unknowns(sys)\n    U=unknowns(sys)\n    inival[1,:].=map((x,y)->exp(-5.0*((x-0.5)^2+(y-0.5)^2)),grid)\n    inival[2,:].=0\n\n    control=VoronoiFVM.NewtonControl()\n    control.verbose=verbose\n    control.tol_linear=1.0e-5\n    control.max_lureuse=max_lureuse\n    control.factorization=factorization\n\n    tstep=0.01\n    time=0.0\n    istep=0\n    u25=0\n\n    p=GridVisualizer(Plotter=Plotter,layout=(2,1))\n    while time<tend\n        time=time+tstep\n        solve!(U,inival,sys,control=control,tstep=tstep)\n        inival.=U\n        if verbose\n            @printf(\"time=%g\\n\",time)\n        end\n        I=integrate(sys,physics.storage,U)\n        Uall=sum(I)\n        tstep*=1.2\n        istep=istep+1\n        u25=U[25]\n        scalarplot!(p[1,1],grid,U[1,:],title=@sprintf(\"U1: %.3g U1+U2:%8.3g\",I[1,1],Uall),flimits=(0,1))\n        scalarplot!(p[2,1],grid,U[2,:],title=@sprintf(\"U2: %.3g\",I[2,1]),flimits=(0,1))\n        reveal(p)\n    end\n    return u25\nend\n\nfunction test()\n    testval=0.2760603343272377\n    main(unknown_storage=:sparse) ≈ testval &&\n        main(unknown_storage=:dense) ≈ testval\nend\nend","category":"page"},{"location":"examples/Example215_NonlinearPoisson2D_BoundaryReaction/","page":"215: 2D Nonlinear Poisson with boundary reaction","title":"215: 2D Nonlinear Poisson with boundary reaction","text":"","category":"page"},{"location":"examples/Example215_NonlinearPoisson2D_BoundaryReaction/","page":"215: 2D Nonlinear Poisson with boundary reaction","title":"215: 2D Nonlinear Poisson with boundary reaction","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/Example410_ManySpecies/#:-Many-Species","page":"410: Many Species","title":"410: Many Species","text":"","category":"section"},{"location":"examples/Example410_ManySpecies/","page":"410: Many Species","title":"410: Many Species","text":"(source code)","category":"page"},{"location":"examples/Example410_ManySpecies/","page":"410: Many Species","title":"410: Many Species","text":"Test stationary diffusion for 50 species.","category":"page"},{"location":"examples/Example410_ManySpecies/","page":"410: Many Species","title":"410: Many Species","text":"module Example410_ManySpecies\nusing Printf\nusing VoronoiFVM\nusing SparseArrays\nusing ExtendableGrids\nusing GridVisualize\nusing LinearAlgebra\n\nfunction main(;n=11, nspec=50, Plotter=nothing, unknown_storage=:dense)\n    grid=simplexgrid(range(0,1,length=n))\n\n    function flux(f,u,edge)\n        for ispec=1:nspec\n            f[ispec]=u[ispec,1]-u[ispec,2]\n        end\n    end\n    physics = VoronoiFVM.Physics(flux = flux)\n    sys     = VoronoiFVM.System(grid,physics,unknown_storage=unknown_storage)\n    for ispec=1:nspec\n        enable_species!(sys, ispec, [1])\n        boundary_dirichlet!(sys, ispec, 1, 0)\n        boundary_dirichlet!(sys, ispec, 2, 1)\n    end\n    sol=solve(unknowns(sys,inival=0),sys)\n    norm(sol)\nend\n\nfunction test()\n    testval=13.874436925511608\n    main(unknown_storage=:sparse) ≈ testval &&\n        main(unknown_storage=:dense) ≈ testval\nend\n\nend","category":"page"},{"location":"examples/Example410_ManySpecies/","page":"410: Many Species","title":"410: Many Species","text":"","category":"page"},{"location":"examples/Example410_ManySpecies/","page":"410: Many Species","title":"410: Many Species","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/Example106_NonlinearDiffusion1D/#:-1D-Nonlinear-Diffusion-equation","page":"106: 1D Nonlinear Diffusion equation","title":"106: 1D Nonlinear Diffusion equation","text":"","category":"section"},{"location":"examples/Example106_NonlinearDiffusion1D/","page":"106: 1D Nonlinear Diffusion equation","title":"106: 1D Nonlinear Diffusion equation","text":"(source code)","category":"page"},{"location":"examples/Example106_NonlinearDiffusion1D/","page":"106: 1D Nonlinear Diffusion equation","title":"106: 1D Nonlinear Diffusion equation","text":"Solve the nonlinear diffusion equation","category":"page"},{"location":"examples/Example106_NonlinearDiffusion1D/","page":"106: 1D Nonlinear Diffusion equation","title":"106: 1D Nonlinear Diffusion equation","text":"partial_t u -Delta u^m = 0","category":"page"},{"location":"examples/Example106_NonlinearDiffusion1D/","page":"106: 1D Nonlinear Diffusion equation","title":"106: 1D Nonlinear Diffusion equation","text":"in Omega=(-11) with homogeneous Neumann boundary condtions using the implicit Euler method.","category":"page"},{"location":"examples/Example106_NonlinearDiffusion1D/","page":"106: 1D Nonlinear Diffusion equation","title":"106: 1D Nonlinear Diffusion equation","text":"This equation is also called  \"porous medium equation\". The Barenblatt solution is an exact solution of this problem which for m>1 has a finite support. We initialize this problem with the exact solution for t=t_0=0001.","category":"page"},{"location":"examples/Example106_NonlinearDiffusion1D/","page":"106: 1D Nonlinear Diffusion equation","title":"106: 1D Nonlinear Diffusion equation","text":"(see Barenblatt, G. I. \"On nonsteady motions of gas and fluid in porous medium.\" Appl. Math. and Mech.(PMM) 16.1 (1952): 67-78.)","category":"page"},{"location":"examples/Example106_NonlinearDiffusion1D/","page":"106: 1D Nonlinear Diffusion equation","title":"106: 1D Nonlinear Diffusion equation","text":"module Example106_NonlinearDiffusion1D\nusing Printf\nusing VoronoiFVM\nusing ExtendableGrids\nusing GridVisualize\n\nfunction barenblatt(x,t,m)\n    tx=t^(-1.0/(m+1.0))\n    xx=x*tx\n    xx=xx*xx\n    xx=1- xx*(m-1)/(2.0*m*(m+1));\n    if xx<0.0\n        xx=0.0\n    end\n    return tx*xx^(1.0/(m-1.0))\nend\n\n\nfunction main(;n=20,m=2,Plotter=nothing,verbose=false, unknown_storage=:sparse,tend=0.01,tstep=0.0001,DiffEq=nothing)\n\n    # Create a one-dimensional discretization\n    h=1.0/convert(Float64,n/2)\n    X=collect(-1:h:1)\n    grid=VoronoiFVM.Grid(X)\n\n    # Flux function which describes the flux\n    # between neigboring control volumes\n    function flux!(f,u,edge)\n        f[1]=u[1,1]^m-u[1,2]^m\n    end\n\n    # Storage term\n    function storage!(f,u,node)\n        f[1]=u[1]\n    end\n\n    # Create a physics structure\n    physics=VoronoiFVM.Physics(\n        flux=flux!,\n        storage=storage!)\n\n\n    # Create a finite volume system - either\n    # in the dense or  the sparse version.\n    # The difference is in the way the solution object\n    # is stored - as dense or as sparse matrix\n    sys=VoronoiFVM.System(grid,physics,unknown_storage=unknown_storage)\n\n    # Add species 1 to region 1\n    enable_species!(sys,1,[1])\n\n\n    # Create a solution array\n    inival=unknowns(sys)\n    t0=0.001\n\n    # Broadcast the initial value\n    inival[1,:].=map(x->barenblatt(x,t0,m),X)\n\n\n    # Create solver control info for constant time step size\n    control=VoronoiFVM.NewtonControl()\n    control.verbose=verbose\n    control.Δt_min=tstep\n    control.Δt_max=tstep\n    control.Δt=tstep\n    control.Δu_opt=1\n\n    if isnothing(DiffEq)\n        tsol=solve(inival,sys,[t0,tend],control=control)\n    else\n        tsol=solve(DiffEq,inival,sys,[t0,tend])\n    end\n\n    p=GridVisualizer(Plotter=Plotter,layout=(1,1),fast=true)\n    for i=1:length(tsol)\n        time=tsol.t[i]\n        scalarplot!(p[1,1],grid,tsol[1,:,i],title=@sprintf(\"t=%.3g\",time),color=:red,label=\"numerical\",\n                    markershape=:circle,markevery=1)\n        scalarplot!(p[1,1],grid,map(x->barenblatt(x,time,m),grid),clear=false,color=:green,\n                    label=\"exact\",markershape=:none)\n        reveal(p)\n        sleep(1.0e-2)\n    end\n    return sum(tsol[end])\nend\n\n\nfunction test()\n    testval=46.66666666647518\n    main(unknown_storage=:sparse) ≈ testval && main(unknown_storage=:dense) ≈ testval\nend\n\nend","category":"page"},{"location":"examples/Example106_NonlinearDiffusion1D/","page":"106: 1D Nonlinear Diffusion equation","title":"106: 1D Nonlinear Diffusion equation","text":"","category":"page"},{"location":"examples/Example106_NonlinearDiffusion1D/","page":"106: 1D Nonlinear Diffusion equation","title":"106: 1D Nonlinear Diffusion equation","text":"This page was generated using Literate.jl.","category":"page"},{"location":"nbhtml/flux-reconstruction/#flux-reconstruction","page":"Obtaining vector fields","title":"flux-reconstruction.jl","text":"","category":"section"},{"location":"nbhtml/flux-reconstruction/","page":"Obtaining vector fields","title":"Obtaining vector fields","text":"Download this Pluto.jl notebook.","category":"page"},{"location":"nbhtml/flux-reconstruction/","page":"Obtaining vector fields","title":"Obtaining vector fields","text":"<iframe style=\"height:15000px\" width=\"100%\" src=\"../flux-reconstruction.html\"> </iframe>","category":"page"},{"location":"examples/Example115_HeterogeneousCatalysis1D/#:-1D-heterogeneous-catalysis","page":"115: 1D heterogeneous catalysis","title":"115: 1D heterogeneous catalysis","text":"","category":"section"},{"location":"examples/Example115_HeterogeneousCatalysis1D/","page":"115: 1D heterogeneous catalysis","title":"115: 1D heterogeneous catalysis","text":"(source code)","category":"page"},{"location":"examples/Example115_HeterogeneousCatalysis1D/","page":"115: 1D heterogeneous catalysis","title":"115: 1D heterogeneous catalysis","text":"Let Omega=(01), Gamma_1=0, Gamma_2=1 Regard a system of three species: ABC and let u_A=A, u_B=B and u_C=C be their corresponding concentrations.","category":"page"},{"location":"examples/Example115_HeterogeneousCatalysis1D/","page":"115: 1D heterogeneous catalysis","title":"115: 1D heterogeneous catalysis","text":"Species A and B exist in the interior of the domain, species C lives a the boundary Gamma_1.  We assume a heterogeneous reaction scheme where A reacts to C and C reacts to B:","category":"page"},{"location":"examples/Example115_HeterogeneousCatalysis1D/","page":"115: 1D heterogeneous catalysis","title":"115: 1D heterogeneous catalysis","text":"beginaligned\n      A leftrightarrow C\n      C leftrightarrow B\nendaligned","category":"page"},{"location":"examples/Example115_HeterogeneousCatalysis1D/","page":"115: 1D heterogeneous catalysis","title":"115: 1D heterogeneous catalysis","text":"with reaction constants k_AC^pm and k_{BC}^\\pm$.","category":"page"},{"location":"examples/Example115_HeterogeneousCatalysis1D/","page":"115: 1D heterogeneous catalysis","title":"115: 1D heterogeneous catalysis","text":"In Omega, both A and B are transported through diffusion:","category":"page"},{"location":"examples/Example115_HeterogeneousCatalysis1D/","page":"115: 1D heterogeneous catalysis","title":"115: 1D heterogeneous catalysis","text":"beginaligned\npartial_t u_B - nablacdot D_A nabla u_A  = f_A\npartial_t u_B - nablacdot D_B nabla u_B  = 0\nendaligned","category":"page"},{"location":"examples/Example115_HeterogeneousCatalysis1D/","page":"115: 1D heterogeneous catalysis","title":"115: 1D heterogeneous catalysis","text":"Here, f(x) is a source term creating A. On Gamma_2, we set boundary conditions","category":"page"},{"location":"examples/Example115_HeterogeneousCatalysis1D/","page":"115: 1D heterogeneous catalysis","title":"115: 1D heterogeneous catalysis","text":"beginaligned\nD_A nabla u_A  = 0\nu_B=0\nendaligned","category":"page"},{"location":"examples/Example115_HeterogeneousCatalysis1D/","page":"115: 1D heterogeneous catalysis","title":"115: 1D heterogeneous catalysis","text":"describing no normal flux for A and zero concentration of B. On Gamma_1, we use the mass action law to describe the boundary reaction and the evolution of the boundary concentration C. We assume that there is a limited amount of surface sites S for species C, so in fact A has to react with a free surface site in order to become C which reflected by the factor 1-u_C. The same is true for B.","category":"page"},{"location":"examples/Example115_HeterogeneousCatalysis1D/","page":"115: 1D heterogeneous catalysis","title":"115: 1D heterogeneous catalysis","text":"beginaligned\nR_AC(u_A u_C)=k_AC^+ u_A(1-u_C) - k_AC^-u_C\nR_BC(u_C u_B)=k_BC^+ u_B(1-u_C) - k_BC^-u_C\n- D_A nabla u_A  + S R_AC(u_A u_C) =0 \n- D_B nabla u_B  + S R_BC(u_B u_C) =0 \npartial_t C  - R_AC(u_A u_C) - R_BC(u_B u_C) =0\nendaligned","category":"page"},{"location":"examples/Example115_HeterogeneousCatalysis1D/","page":"115: 1D heterogeneous catalysis","title":"115: 1D heterogeneous catalysis","text":"module Example115_HeterogeneousCatalysis1D\nusing Printf\nusing VoronoiFVM\nusing ExtendableGrids\nusing GridVisualize\nusing LinearAlgebra\n\nfunction main(;n=10,Plotter=nothing,verbose=false,tend=1, unknown_storage=:sparse)\n\n    h=1.0/convert(Float64,n)\n    X=collect(0.0:h:1.0)\n    N=length(X)\n\n    grid=VoronoiFVM.Grid(X)\n    # By default, \\Gamma_1 at X[1] and \\Gamma_2 is at X[end]\n\n    # Species numbers\n    iA=1\n    iB=2\n    iC=3\n\n\n    # Diffusion flux for species A and B\n    D_A=1.0\n    D_B=1.0e-2\n    function flux!(f,u,edge)\n        f[iA]=D_A*(u[iA,1]-u[iA,2])\n        f[iB]=D_B*(u[iB,1]-u[iB,2])\n    end\n\n    # Storage term of species A and B\n    function storage!(f,u,node)\n        f[iA]=u[iA]\n        f[iB]=u[iB]\n    end\n\n    # Source term for species a around 0.5\n    function source!(f,node)\n        x1=node[1]-0.5\n        f[iA]=exp(-100*x1^2)\n    end\n\n    # Reaction constants (p = + , m = -)\n    # Choosen to prefer path A-> C -> B\n    # More over, A reacts faster than to C than C to B\n    # leading to \"catalyst poisoning\", i.e. C taking up most of the\n    # available catalyst sites\n    kp_AC=100.0\n    km_AC=1.0\n\n    kp_BC=0.1\n    km_BC=1.0\n\n    S=0.01\n\n    R_AC(u_A, u_C)=kp_AC*u_A*(1-u_C) - km_AC*u_C\n    R_BC(u_B, u_C)=kp_BC*u_B*(1-u_C) - km_BC*u_C\n\n    function breaction!(f,u,node)\n        if  node.region==1\n            f[iA]=S*R_AC(u[iA], u[iC])\n            f[iB]=S*R_BC(u[iB], u[iC])\n            f[iC]=-R_BC(u[iB], u[iC])-R_AC(u[iA], u[iC])\n        end\n    end\n\n    # This is for the term \\partial_t u_C at the boundary\n    function bstorage!(f,u,node)\n        if  node.region==1\n            f[iC]=u[iC]\n        end\n    end\n\n    physics=VoronoiFVM.Physics(\n        breaction=breaction!,\n        bstorage=bstorage!,\n        flux=flux!,\n        storage=storage!,\n        source=source!\n    )\n\n    sys=VoronoiFVM.System(grid,physics,unknown_storage=unknown_storage)\n\n    # Enable species in bulk resp\n    enable_species!(sys,iA,[1])\n    enable_species!(sys,iB,[1])\n\n    # Enable surface species\n    enable_boundary_species!(sys,iC,[1])\n\n    # Set Dirichlet bc for species B on \\Gamma_2\n    boundary_dirichlet!(sys,iB,2,0.0)\n\n    # Initial values\n    inival=unknowns(sys)\n    inival.=0.0\n    U=unknowns(sys)\n\n    tstep=0.01\n    time=0.0\n\n    # Data to store surface concentration vs time\n\n    p=GridVisualizer(Plotter=Plotter,layout=(3,1))\n\n    control=fixed_timesteps!(VoronoiFVM.NewtonControl(),tstep)\n    tsol=solve(inival,sys,[0,tend],control=control)\n\n    p=GridVisualizer(Plotter=Plotter,layout=(3,1),fast=true)\n    for it=1:length(tsol)\n        time=tsol.t[it]\n        scalarplot!(p[1,1],grid,tsol[iA,:,it],clear=true,title=@sprintf(\"[A]: (%.3f,%.3f)\",extrema(tsol[iA,:,it])...))\n        scalarplot!(p[2,1],grid,tsol[iB,:,it],clear=true,title=@sprintf(\"[B]: (%.3f,%.3f)\",extrema(tsol[iB,:,it])...))\n        scalarplot!(p[3,1],tsol.t[1:it],tsol[iC,1,1:it],title=@sprintf(\"[C]\"),clear=true,show=true)\n    end\n\n    return tsol[iC,1,end]\nend\n\nfunction test()\n    testval=0.87544440641274\n    isapprox(main(unknown_storage=:sparse),testval,rtol=1.0e-12)&&\n    isapprox(main(unknown_storage=:dense),testval,rtol=1.0e-12)\nend\nend","category":"page"},{"location":"examples/Example115_HeterogeneousCatalysis1D/","page":"115: 1D heterogeneous catalysis","title":"115: 1D heterogeneous catalysis","text":"","category":"page"},{"location":"examples/Example115_HeterogeneousCatalysis1D/","page":"115: 1D heterogeneous catalysis","title":"115: 1D heterogeneous catalysis","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/Example150_Impedance1D/#:-Impedance-calculation","page":"150: Impedance calculation","title":"150: Impedance calculation","text":"","category":"section"},{"location":"examples/Example150_Impedance1D/","page":"150: Impedance calculation","title":"150: Impedance calculation","text":"(source code)","category":"page"},{"location":"examples/Example150_Impedance1D/","page":"150: Impedance calculation","title":"150: Impedance calculation","text":"Impedance calculation for","category":"page"},{"location":"examples/Example150_Impedance1D/","page":"150: Impedance calculation","title":"150: Impedance calculation","text":"C ut - (D ux)_x + Ru = 0   in (0,1)      u(0,t)=1 + exp(iωt)      u(1,t)=0","category":"page"},{"location":"examples/Example150_Impedance1D/","page":"150: Impedance calculation","title":"150: Impedance calculation","text":"Measurement: I(t)= D u_x(1,t)","category":"page"},{"location":"examples/Example150_Impedance1D/","page":"150: Impedance calculation","title":"150: Impedance calculation","text":"Steady state:","category":"page"},{"location":"examples/Example150_Impedance1D/","page":"150: Impedance calculation","title":"150: Impedance calculation","text":"(D u0x)x + Ru0 = 0","category":"page"},{"location":"examples/Example150_Impedance1D/","page":"150: Impedance calculation","title":"150: Impedance calculation","text":"u0(0,t)=1    u0(1,t)=0","category":"page"},{"location":"examples/Example150_Impedance1D/","page":"150: Impedance calculation","title":"150: Impedance calculation","text":"Small signal ansatz for ω","category":"page"},{"location":"examples/Example150_Impedance1D/","page":"150: Impedance calculation","title":"150: Impedance calculation","text":"u(x,t)= u0(x)+ ua(x) exp(iωt)","category":"page"},{"location":"examples/Example150_Impedance1D/","page":"150: Impedance calculation","title":"150: Impedance calculation","text":"iωC ua - (D uax)x + R u_a =0      ua(0)=1      ua(1)=0","category":"page"},{"location":"examples/Example150_Impedance1D/","page":"150: Impedance calculation","title":"150: Impedance calculation","text":"module Example150_Impedance1D\n\nusing Printf\nusing VoronoiFVM\nusing ExtendableGrids\nusing GridVisualize\n\nfunction main(;nref=0,Plotter=nothing,verbose=false, unknown_storage=:sparse,\n              L=1.0, R=1.0, D=1.0, C=1.0,\n              ω0=1.0e-3,ω1=5.0e1)","category":"page"},{"location":"examples/Example150_Impedance1D/","page":"150: Impedance calculation","title":"150: Impedance calculation","text":"Create array which is refined close to 0","category":"page"},{"location":"examples/Example150_Impedance1D/","page":"150: Impedance calculation","title":"150: Impedance calculation","text":"    h0=0.005/2.0^nref\n    h1=0.1/2.0^nref\n\n    X=VoronoiFVM.geomspace(0,L,h0,h1)","category":"page"},{"location":"examples/Example150_Impedance1D/","page":"150: Impedance calculation","title":"150: Impedance calculation","text":"Create discretitzation grid","category":"page"},{"location":"examples/Example150_Impedance1D/","page":"150: Impedance calculation","title":"150: Impedance calculation","text":"    grid=VoronoiFVM.Grid(X)","category":"page"},{"location":"examples/Example150_Impedance1D/","page":"150: Impedance calculation","title":"150: Impedance calculation","text":"Create and fill data","category":"page"},{"location":"examples/Example150_Impedance1D/","page":"150: Impedance calculation","title":"150: Impedance calculation","text":"    data = (R=R, D=D, C=C)","category":"page"},{"location":"examples/Example150_Impedance1D/","page":"150: Impedance calculation","title":"150: Impedance calculation","text":"Declare constitutive functions","category":"page"},{"location":"examples/Example150_Impedance1D/","page":"150: Impedance calculation","title":"150: Impedance calculation","text":"    flux=function(f,u,edge,data)\n        f[1]=data.D*(u[1,1]-u[1,2])\n    end\n\n    storage=function(f,u,node,data)\n        f[1]=data.C*u[1]\n    end\n\n    reaction=function(f,u,node,data)\n        f[1]=data.R*u[1]\n    end\n\n    excited_bc=1\n    excited_bcval=1.0\n    excited_spec=1\n    meas_bc=2","category":"page"},{"location":"examples/Example150_Impedance1D/","page":"150: Impedance calculation","title":"150: Impedance calculation","text":"Create physics struct","category":"page"},{"location":"examples/Example150_Impedance1D/","page":"150: Impedance calculation","title":"150: Impedance calculation","text":"    physics=VoronoiFVM.Physics(data=data,\n                               flux=flux,\n                               storage=storage,\n                               reaction=reaction\n                               )","category":"page"},{"location":"examples/Example150_Impedance1D/","page":"150: Impedance calculation","title":"150: Impedance calculation","text":"Create discrete system and enabe species","category":"page"},{"location":"examples/Example150_Impedance1D/","page":"150: Impedance calculation","title":"150: Impedance calculation","text":"    sys=VoronoiFVM.System(grid,physics,unknown_storage=unknown_storage)\n\n    enable_species!(sys,excited_spec,[1])","category":"page"},{"location":"examples/Example150_Impedance1D/","page":"150: Impedance calculation","title":"150: Impedance calculation","text":"Create test functions for current measurement","category":"page"},{"location":"examples/Example150_Impedance1D/","page":"150: Impedance calculation","title":"150: Impedance calculation","text":"    factory=TestFunctionFactory(sys)\n    measurement_testfunction=testfunction(factory,[excited_bc],[meas_bc])\n\n    boundary_dirichlet!(sys,excited_spec,excited_bc,excited_bcval)\n    boundary_dirichlet!(sys,excited_spec,meas_bc,0.0)\n\n\n    inival=unknowns(sys,inival=0.0)\n    steadystate=solve(inival,sys)\n\n    function meas_stdy(meas,U)\n        u=reshape(U,sys)\n        meas[1]=-VoronoiFVM.integrate_stdy(sys,measurement_testfunction,u)[excited_spec]\n        nothing\n    end\n\n    function meas_tran(meas,U)\n        u=reshape(U,sys)\n        meas[1]=-VoronoiFVM.integrate_tran(sys,measurement_testfunction,u)[excited_spec]\n        nothing\n    end\n\n\n    dmeas_stdy=measurement_derivative(sys,meas_stdy,steadystate)\n    dmeas_tran=measurement_derivative(sys,meas_tran,steadystate)","category":"page"},{"location":"examples/Example150_Impedance1D/","page":"150: Impedance calculation","title":"150: Impedance calculation","text":"Create Impeadancs system from steady state","category":"page"},{"location":"examples/Example150_Impedance1D/","page":"150: Impedance calculation","title":"150: Impedance calculation","text":"    isys=VoronoiFVM.ImpedanceSystem(sys,steadystate,excited_spec,excited_bc)","category":"page"},{"location":"examples/Example150_Impedance1D/","page":"150: Impedance calculation","title":"150: Impedance calculation","text":"Prepare recording of impedance results","category":"page"},{"location":"examples/Example150_Impedance1D/","page":"150: Impedance calculation","title":"150: Impedance calculation","text":"    allomega=zeros(0)","category":"page"},{"location":"examples/Example150_Impedance1D/","page":"150: Impedance calculation","title":"150: Impedance calculation","text":"for calculated data","category":"page"},{"location":"examples/Example150_Impedance1D/","page":"150: Impedance calculation","title":"150: Impedance calculation","text":"    allI0=zeros(Complex{Float64},0)\n    allIL=zeros(Complex{Float64},0)","category":"page"},{"location":"examples/Example150_Impedance1D/","page":"150: Impedance calculation","title":"150: Impedance calculation","text":"for exact data","category":"page"},{"location":"examples/Example150_Impedance1D/","page":"150: Impedance calculation","title":"150: Impedance calculation","text":"    allIx0=zeros(Complex{Float64},0)\n    allIxL=zeros(Complex{Float64},0)\n\n    ω=ω0\n\n    UZ=unknowns(isys)\n    while ω<ω1","category":"page"},{"location":"examples/Example150_Impedance1D/","page":"150: Impedance calculation","title":"150: Impedance calculation","text":"solve impedance system","category":"page"},{"location":"examples/Example150_Impedance1D/","page":"150: Impedance calculation","title":"150: Impedance calculation","text":"        solve!(UZ,isys,ω)","category":"page"},{"location":"examples/Example150_Impedance1D/","page":"150: Impedance calculation","title":"150: Impedance calculation","text":"calculate aproximate solution obtain measurement in frequency  domain","category":"page"},{"location":"examples/Example150_Impedance1D/","page":"150: Impedance calculation","title":"150: Impedance calculation","text":"        IL=impedance(isys,ω,steadystate, dmeas_stdy, dmeas_tran)","category":"page"},{"location":"examples/Example150_Impedance1D/","page":"150: Impedance calculation","title":"150: Impedance calculation","text":"record approximate solution","category":"page"},{"location":"examples/Example150_Impedance1D/","page":"150: Impedance calculation","title":"150: Impedance calculation","text":"        push!(allomega, ω)\n        push!(allIL,IL)","category":"page"},{"location":"examples/Example150_Impedance1D/","page":"150: Impedance calculation","title":"150: Impedance calculation","text":"record exact solution","category":"page"},{"location":"examples/Example150_Impedance1D/","page":"150: Impedance calculation","title":"150: Impedance calculation","text":"        iω=1im*ω\n        z=sqrt(iω*data.C/data.D+data.R/data.D)\n        eplus=exp(z*L)\n        eminus=exp(-z*L)\n        IxL=2.0*data.D*z/(eplus-eminus)\n\n        push!(allIxL,1/IxL)","category":"page"},{"location":"examples/Example150_Impedance1D/","page":"150: Impedance calculation","title":"150: Impedance calculation","text":"increase omega","category":"page"},{"location":"examples/Example150_Impedance1D/","page":"150: Impedance calculation","title":"150: Impedance calculation","text":"        ω=ω*1.1\n\n    end\n\n    p=GridVisualizer(Plotter=Plotter)\n    scalarplot!(p,real(allIxL),imag(allIxL),label=\"exact\",color=:red,linestyle=:dot)\n    scalarplot!(p,real(allIL),imag(allIL),label=\"calc\",show=true,clear=false,color=:blue,linestyle=:solid)\n\n    sum(allIL)\nend\n\n\nfunction test()\n    tval=57.92710286186797 + 23.163945443946027im\n    main(unknown_storage=:dense) ≈ tval  &&  main(unknown_storage=:sparse) ≈ tval\nend\n\n\nend","category":"page"},{"location":"examples/Example150_Impedance1D/","page":"150: Impedance calculation","title":"150: Impedance calculation","text":"","category":"page"},{"location":"examples/Example150_Impedance1D/","page":"150: Impedance calculation","title":"150: Impedance calculation","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/Example102_StationaryConvectionDiffusion1D/#:-1D-Stationary-convection-diffusion-equation","page":"102: 1D Stationary convection-diffusion equation","title":"102: 1D Stationary convection-diffusion equation","text":"","category":"section"},{"location":"examples/Example102_StationaryConvectionDiffusion1D/","page":"102: 1D Stationary convection-diffusion equation","title":"102: 1D Stationary convection-diffusion equation","text":"(source code)","category":"page"},{"location":"examples/Example102_StationaryConvectionDiffusion1D/","page":"102: 1D Stationary convection-diffusion equation","title":"102: 1D Stationary convection-diffusion equation","text":"Solve the equation","category":"page"},{"location":"examples/Example102_StationaryConvectionDiffusion1D/","page":"102: 1D Stationary convection-diffusion equation","title":"102: 1D Stationary convection-diffusion equation","text":"-nabla ( D nabla u - v u) = 0","category":"page"},{"location":"examples/Example102_StationaryConvectionDiffusion1D/","page":"102: 1D Stationary convection-diffusion equation","title":"102: 1D Stationary convection-diffusion equation","text":"in Omega=(01) with boundary condition u(0)=0 and u(1)=1. v could be e.g. the velocity of a moving medium or the gradient of an electric field.","category":"page"},{"location":"examples/Example102_StationaryConvectionDiffusion1D/","page":"102: 1D Stationary convection-diffusion equation","title":"102: 1D Stationary convection-diffusion equation","text":"This is a convection dominant second order boundary value problem which obeys a local and a global maximum principle: the solution which is bounded by the values at the boundary and has no local extrema in the interior. If v is large compared to D, a boundary layer is observed.","category":"page"},{"location":"examples/Example102_StationaryConvectionDiffusion1D/","page":"102: 1D Stationary convection-diffusion equation","title":"102: 1D Stationary convection-diffusion equation","text":"The maximum principle of the solution can only be guaranteed it the discretization is performed accordingly: the flux function must monotonically increase in the first argument and monotonically decrease in the second argument.","category":"page"},{"location":"examples/Example102_StationaryConvectionDiffusion1D/","page":"102: 1D Stationary convection-diffusion equation","title":"102: 1D Stationary convection-diffusion equation","text":"The example describes three possible ways to define the flux function and demonstrates the impact on the qualitative properties of the solution.","category":"page"},{"location":"examples/Example102_StationaryConvectionDiffusion1D/","page":"102: 1D Stationary convection-diffusion equation","title":"102: 1D Stationary convection-diffusion equation","text":"module Example102_StationaryConvectionDiffusion1D\nusing Printf\nusing VoronoiFVM\nusing ExtendableGrids\nusing GridVisualize\n\n# Central difference flux. The velocity term is discretized using the\n# average of the solution in the endpoints of the grid. If the local Peclet\n# number v*h/D>1, the monotonicity property is lost.  Grid refinement\n# can fix this situation by decreasing $h$.\n\nfunction central_flux!(f,u,edge,data)\n    f_diff=data.D*(u[1,1]-u[1,2])\n    vh=project(edge,data.v)\n    f[1]=f_diff+vh*(u[1,1]+u[1,2])/2\nend\n\n# The simple upwind flux corrects the monotonicity properties essentially\n# via brute force and loses one order of convergence for small $h$ compared\n# to the central flux.\n\nfunction upwind_flux!(f,u,edge,data)\n    fdiff=data.D*(u[1,]-u[1,2])\n    vh=project(edge,data.v)\n    if vh>0\n        f[1]=fdiff+vh*u[1,1]\n    else\n        f[1]=fdiff+vh*u[1,2]\n    end\nend\n\n# The exponential fitting flux has the proper monotonicity properties and\n# kind of interpolates in a clever way between central\n# and upwind flux. It can be derived by solving the two-point boundary value problem\n# at the grid interval analytically.\n\n# Bernoulli function used in the exponential fitting discretization\nfunction bernoulli(x)\n    if abs(x)<nextfloat(eps(typeof(x)))\n        return 1\n    end\n    return x/(exp(x)-1)\nend\n\nfunction exponential_flux!(f,u,edge,data)\n    vh=project(edge,data.v)\n    Bplus= data.D*bernoulli(vh/data.D)\n    Bminus=data.D*bernoulli(-vh/data.D)\n    f[1]=Bminus*u[1,1]-Bplus*u[1,2]\nend\n\n\nfunction calculate(grid,data,flux,verbose)\n\n    sys=VoronoiFVM.System(grid,VoronoiFVM.Physics(flux=flux, data=data))\n\n    # Add species 1 to region 1\n    enable_species!(sys,1,[1])\n\n    # Set boundary conditions\n    boundary_dirichlet!(sys,1,1,0.0)\n    boundary_dirichlet!(sys,1,2,1.0)\n\n    # Create a solution array\n    inival=unknowns(sys,inival=0.5)\n    solution=unknowns(sys)\n\n    # Create solver control info\n    control=VoronoiFVM.NewtonControl()\n    control.verbose=verbose\n\n    # Stationary solution of the problem\n    solve!(solution,inival,sys, control=control)\n    return solution\nend\n\nfunction main(;n=10,Plotter=nothing,verbose=false,D=0.01,v=1.0)\n\n    # Create a one-dimensional discretization\n    h=1.0/convert(Float64,n)\n    grid=VoronoiFVM.Grid(collect(0:h:1))\n\n    data=(v=[v],D=D)","category":"page"},{"location":"examples/Example102_StationaryConvectionDiffusion1D/","page":"102: 1D Stationary convection-diffusion equation","title":"102: 1D Stationary convection-diffusion equation","text":"Calculate three stationary solutions with different ways to calculate flux","category":"page"},{"location":"examples/Example102_StationaryConvectionDiffusion1D/","page":"102: 1D Stationary convection-diffusion equation","title":"102: 1D Stationary convection-diffusion equation","text":"    solution_exponential=calculate(grid,data,exponential_flux!,verbose)\n    solution_upwind=calculate(grid,data,upwind_flux!,verbose)\n    solution_central=calculate(grid,data,central_flux!,verbose)","category":"page"},{"location":"examples/Example102_StationaryConvectionDiffusion1D/","page":"102: 1D Stationary convection-diffusion equation","title":"102: 1D Stationary convection-diffusion equation","text":"Visualize solutions using GridVisualize.jl","category":"page"},{"location":"examples/Example102_StationaryConvectionDiffusion1D/","page":"102: 1D Stationary convection-diffusion equation","title":"102: 1D Stationary convection-diffusion equation","text":"    p=GridVisualizer(Plotter=Plotter,layout=(3,1))\n    scalarplot!(p[1,1],grid,solution_exponential[1,:],title=\"exponential\")\n    scalarplot!(p[2,1],grid,solution_upwind[1,:],title=\"upwind\")\n    scalarplot!(p[3,1],grid,solution_central[1,:],title=\"centered\",show=true)\n\n    # Return test value\n    return sum(solution_exponential)+sum(solution_upwind)+sum(solution_central)\nend\n\nfunction test()\n    testval=2.523569744561089\n    main() ≈ testval\nend\n\nend","category":"page"},{"location":"examples/Example102_StationaryConvectionDiffusion1D/","page":"102: 1D Stationary convection-diffusion equation","title":"102: 1D Stationary convection-diffusion equation","text":"","category":"page"},{"location":"examples/Example102_StationaryConvectionDiffusion1D/","page":"102: 1D Stationary convection-diffusion equation","title":"102: 1D Stationary convection-diffusion equation","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/Example311_HeatEquation_BoundaryDiffusion/#:-Heat-Equation-with-boundary-diffusion","page":"311: Heat Equation with boundary diffusion","title":"311: Heat Equation with boundary diffusion","text":"","category":"section"},{"location":"examples/Example311_HeatEquation_BoundaryDiffusion/","page":"311: Heat Equation with boundary diffusion","title":"311: Heat Equation with boundary diffusion","text":"(source code)","category":"page"},{"location":"examples/Example311_HeatEquation_BoundaryDiffusion/","page":"311: Heat Equation with boundary diffusion","title":"311: Heat Equation with boundary diffusion","text":"module Example311_HeatEquation_BoundaryDiffusion\nusing Printf\nusing VoronoiFVM\nusing ExtendableGrids\n\n\"\"\"\n  We solve the following system\n\n      ∂_tu - εΔu = 0            in [0,T] × Ω\n           ε∇u⋅ν = k(u-v)       on [0,T] × Γ_1\n           ε∇u⋅ν = 0            on [0,T] × (∂Ω ∖ Γ_1)\n  ∂_tv -ε_ΓΔ_Γ v = f(x) +k(u-v) on [0,T] × Γ_1\n          u(0)   = 0.5          in   {0} × Ω\n          v(0)   = 0.5          on   {0} × Γ_1\n\"\"\"\n\nfunction main(n=1)\n\n    breg = 5 # boundary region number for surface diffusion\n\n\n    hmin   = 0.05 * 2.0^(-n+1)\n    hmax   = 0.2  * 2.0^(-n+1)\n    XLeft  = geomspace(0.0, 0.5, hmax, hmin)\n    XRight = geomspace(0.5, 1.0, hmin, hmax)\n    X      = glue(XLeft, XRight)\n\n    Z      = geomspace(0.0, 1.0, hmin, 2*hmax)\n\n    grid   = VoronoiFVM.Grid(X, X, Z)","category":"page"},{"location":"examples/Example311_HeatEquation_BoundaryDiffusion/","page":"311: Heat Equation with boundary diffusion","title":"311: Heat Equation with boundary diffusion","text":"parameters","category":"page"},{"location":"examples/Example311_HeatEquation_BoundaryDiffusion/","page":"311: Heat Equation with boundary diffusion","title":"311: Heat Equation with boundary diffusion","text":"    eps      = 1.0e0  # bulk heat conduction coefficient\n    eps_surf = 1.0e-2 # surface diffusion coefficient\n    k        = 1.0    # transmission coefficient\n    physics  = VoronoiFVM.Physics(\n        flux        = function(f,u,edge)\n                            f[1] = eps*(u[1,1]-u[1,2])\n                      end,\n\n        bflux       = function(f, u, edge)\n                        if edge.region == breg\n                          f[2]     = eps_surf*(u[2,1]-u[2,2])\n                        else\n                          f[2] = 0.0\n                        end\n\n                      end,\n        breaction   = function(f,u,node)\n                        if node.region == breg\n                          f[1] = k*(u[1]-u[2])\n                          f[2] = k*(u[2]-u[1])\n                        else\n                          f[1] = 0.0\n                          f[2] = 0.0\n                        end\n                      end,\n        bsource      = function(f, bnode)\n                        x1   = bnode[1]-0.5\n                        x2   = bnode[2]-0.5\n                        x3   = bnode[3]-0.5\n                        f[2] = 1.0e4*exp(-20.0*(x1^2+x2^2+x3^2))\n                      end,\n\n        bstorage    = function(f,u,node)\n                        if node.region == breg\n                          f[2] = u[2]\n                        end\n                      end,\n\n        storage     = function(f,u,node)\n                        f[1] = u[1]\n                      end\n    )\n\n    sys=VoronoiFVM.System(grid,physics,unknown_storage=:sparse)\n    enable_species!(sys,1,[1])\n    enable_boundary_species!(sys,2,[breg])\n\n    function tran32!(a,b)\n        a[1]=b[2]\n    end\n\n    bgrid2=subgrid(grid,[breg],boundary=true,transform=tran32!)\n\n    inival  = unknowns(sys)\n    U       = unknowns(sys)\n    inival .= 0.5\n\n\n    control             = VoronoiFVM.NewtonControl()\n    control.verbose     = false\n    control.tol_linear  = 1.0e-5\n    control.max_lureuse = 10\n\n    tstep = 0.1\n    time  = 0.0\n    step  = 0\n    T     = 1.0\n    while time < T\n        time=time+tstep\n        solve!(U, inival, sys, control=control, tstep=tstep)\n        inival.=U\n        U_surf=view(U[2,:],bgrid2)\n\n        tstep*=1.0\n\n        step += 1\n    end\n\n    U_surf=view(U[2,:],bgrid2)\n    sum(U_surf)\nend\n\n\nfunction test()\n    isapprox(main(), 1463.3732804776039, rtol=1.0e-13)\nend\n\nend","category":"page"},{"location":"examples/Example311_HeatEquation_BoundaryDiffusion/","page":"311: Heat Equation with boundary diffusion","title":"311: Heat Equation with boundary diffusion","text":"","category":"page"},{"location":"examples/Example311_HeatEquation_BoundaryDiffusion/","page":"311: Heat Equation with boundary diffusion","title":"311: Heat Equation with boundary diffusion","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/Example421_AbstractQuantities_TestFunctions/#:-Current-Calculation-for-AbstractQuantities","page":"421: Current Calculation for AbstractQuantities","title":"421: Current Calculation for AbstractQuantities","text":"","category":"section"},{"location":"examples/Example421_AbstractQuantities_TestFunctions/","page":"421: Current Calculation for AbstractQuantities","title":"421: Current Calculation for AbstractQuantities","text":"(source code)","category":"page"},{"location":"examples/Example421_AbstractQuantities_TestFunctions/","page":"421: Current Calculation for AbstractQuantities","title":"421: Current Calculation for AbstractQuantities","text":"Test current calculation for jumping species. Here, we have three cases:     a. Problem initialized as usual     b. Problem initialized with Continuousquantity     c. Problem initialized with Discontinuousquantity with adjusted reaction rate We see that the resulting current coincides for all three cases when adjusting the reaction rate.","category":"page"},{"location":"examples/Example421_AbstractQuantities_TestFunctions/","page":"421: Current Calculation for AbstractQuantities","title":"421: Current Calculation for AbstractQuantities","text":"module Example421_AbstractQuantities_TestFunctions\n\nusing Printf\nusing VoronoiFVM\nusing ExtendableGrids\nusing GridVisualize\nusing LinearAlgebra\n\nmutable struct Data\n    rate::Float64 # rate which is within DiscontinuousQuantities\n    Data() = new()\nend\n\nfunction main(;N=3, Plotter=nothing, unknown_storage=:sparse)\n\n    XX     = collect(0:0.1:1)\n    xcoord = XX\n    for i=1:N-1\n        xcoord = glue(xcoord,XX.+i)\n    end\n    grid = simplexgrid(xcoord)\n    for i=1:N\n        cellmask!(grid, [i-1], [i], i)\n    end\n    for i=1:N-1\n        bfacemask!(grid, [i], [i], i+2)\n    end\n\n    sysQ  = VoronoiFVM.System(grid, unknown_storage=unknown_storage)\n    cspec = ContinuousQuantity(sysQ, 1:N, id = 1)                    # continuous quantity\n    dspec = DiscontinuousQuantity(sysQ, 1:N, id = 2)                 # discontinuous quantity\n\n    data = Data();    rate = 0.0;     data.rate = rate\n\n    function fluxQ(f,u,edge, data) # For both quantities, we define simple diffusion fluxes\n        f[dspec] = u[dspec, 1]-u[dspec, 2]\n        f[cspec] = u[cspec, 1]-u[cspec, 2]\n    end\n\n    function breactionQ(f,u,bnode, data)\n        # Define a thin layer inteface condition for `dspec`.\n        if bnode.region>2\n            react=(u[dspec,1]-u[dspec,2])/data.rate\n            f[dspec,1]= react\n            f[dspec,2]= -react\n        end\n    end\n\n    physics!(sysQ,VoronoiFVM.Physics( data = data,\n        flux=fluxQ,\n        breaction=breactionQ\n    ))\n\n    ##########################################################\n    icc   = 1 # for system without AbstractQuantities\n\n    function flux!(f,u,edge) # analogous as for other system\n        f[icc] = u[icc, 1]-u[icc, 2]\n    end","category":"page"},{"location":"examples/Example421_AbstractQuantities_TestFunctions/","page":"421: Current Calculation for AbstractQuantities","title":"421: Current Calculation for AbstractQuantities","text":"other system to which we compare current calculation","category":"page"},{"location":"examples/Example421_AbstractQuantities_TestFunctions/","page":"421: Current Calculation for AbstractQuantities","title":"421: Current Calculation for AbstractQuantities","text":"    sys  = VoronoiFVM.System(grid; flux = flux!, species = icc, unknown_storage=unknown_storage)\n\n    # Set left boundary conditions\n    boundary_dirichlet!(sysQ, dspec, 1, 0.0)\n    boundary_dirichlet!(sysQ, cspec, 1, 0.0)\n    boundary_dirichlet!(sys,  icc,   1, 0.0)\n\n    subgrids = VoronoiFVM.subgrids(dspec, sysQ)","category":"page"},{"location":"examples/Example421_AbstractQuantities_TestFunctions/","page":"421: Current Calculation for AbstractQuantities","title":"421: Current Calculation for AbstractQuantities","text":"solve","category":"page"},{"location":"examples/Example421_AbstractQuantities_TestFunctions/","page":"421: Current Calculation for AbstractQuantities","title":"421: Current Calculation for AbstractQuantities","text":"    inivalQ  = unknowns(sysQ);  inival  = unknowns(sys)\n    UQ       = unknowns(sysQ);  U       = unknowns(sys)\n    inivalQ .= 0.0;             inival .= 0.0\n    biasval  = range(0, stop = 2.0, length = 5)\n\n    Icspec   = zeros(length(biasval));   Idspec   = zeros(length(biasval)); Iicc   = zeros(length(biasval))\n\n    for data.rate in [1.0e2, 1.0e0, 1.0e-2, 1.0e-4, 1.0e-6]\n        count = 1\n        for Δu in biasval","category":"page"},{"location":"examples/Example421_AbstractQuantities_TestFunctions/","page":"421: Current Calculation for AbstractQuantities","title":"421: Current Calculation for AbstractQuantities","text":"first problem","category":"page"},{"location":"examples/Example421_AbstractQuantities_TestFunctions/","page":"421: Current Calculation for AbstractQuantities","title":"421: Current Calculation for AbstractQuantities","text":"            boundary_dirichlet!(sysQ, dspec, 2, Δu)\n            boundary_dirichlet!(sysQ, cspec, 2, Δu)\n\n            solve!(UQ, inivalQ, sysQ)\n            inivalQ .= UQ\n\n            # get current\n            factoryQ  = TestFunctionFactory(sysQ)\n            tfQ       = testfunction(factoryQ, [1], [2])\n            IQ        = integrate(sysQ, tfQ, UQ)\n\n            val = 0.0\n            for ii in dspec.regionspec # current is calculated regionwise\n                val = val + IQ[ii]\n            end\n            Icspec[count] = IQ[cspec]\n            Idspec[count] = val","category":"page"},{"location":"examples/Example421_AbstractQuantities_TestFunctions/","page":"421: Current Calculation for AbstractQuantities","title":"421: Current Calculation for AbstractQuantities","text":"second problem","category":"page"},{"location":"examples/Example421_AbstractQuantities_TestFunctions/","page":"421: Current Calculation for AbstractQuantities","title":"421: Current Calculation for AbstractQuantities","text":"            boundary_dirichlet!(sys,  icc,   2, Δu)\n\n            solve!(U,  inival,  sys)\n            inival  .= U\n\n            factory = TestFunctionFactory(sys)\n            tf      = testfunction(factory, [1], [2])\n            I       = integrate(sys, tf, U)\n\n            Iicc[count] = I[icc]\n\n            count = count + 1\n        end # bias loop","category":"page"},{"location":"examples/Example421_AbstractQuantities_TestFunctions/","page":"421: Current Calculation for AbstractQuantities","title":"421: Current Calculation for AbstractQuantities","text":"plot","category":"page"},{"location":"examples/Example421_AbstractQuantities_TestFunctions/","page":"421: Current Calculation for AbstractQuantities","title":"421: Current Calculation for AbstractQuantities","text":"        dvws = views(UQ, dspec, subgrids, sysQ)\n        cvws = views(UQ, cspec, subgrids, sysQ)\n\n        vis  = GridVisualizer(layout = (2,1), resolution = (600,300), Plotter = Plotter)\n\n        for i in eachindex(dvws)\n            scalarplot!(vis[1, 1], subgrids[i], dvws[i], flimits=(-0.5,1.5), title = @sprintf(\"Solution with rate=%.2f\",data.rate),  label=\"discont quantity\", clear = false, color=:red)\n            scalarplot!(vis[1, 1], subgrids[i], cvws[i], label=\"cont quantity\",  clear = false, color=:green)\n        end\n        scalarplot!(vis[1, 1], grid, U[icc, :],  label=\"without quantity\",  clear = false, linestyle =:dot, color=:blue)\n\n        scalarplot!(vis[2, 1], biasval, Idspec, clear = false,  title = @sprintf(\"IV with rate=%.2f\",data.rate), label=\"discont quantity\", color=:red)\n        scalarplot!(vis[2, 1], biasval, Icspec, clear = false, title = \"Current\", label=\"cont quantity\", color=:green)\n        scalarplot!(vis[2, 1], biasval, Iicc,   clear = false, label=\"discont quantity\", linestyle =:dot, color=:blue, show = true)\n\n        reveal(vis)\n        sleep(0.2)\n\n        inival .= 0.0; inivalQ .= 0.0\n\n    end # rate loop\n\n    errorIV = norm(Idspec - Icspec, 2)\n\n    return errorIV\n\nend\n\n\nfunction test()\n    main(unknown_storage=:dense) ≈ 6.085802139465579e-7 &&\n    main(unknown_storage=:sparse) ≈ 6.085802139465579e-7\nend\n\nend","category":"page"},{"location":"examples/Example421_AbstractQuantities_TestFunctions/","page":"421: Current Calculation for AbstractQuantities","title":"421: Current Calculation for AbstractQuantities","text":"","category":"page"},{"location":"examples/Example421_AbstractQuantities_TestFunctions/","page":"421: Current Calculation for AbstractQuantities","title":"421: Current Calculation for AbstractQuantities","text":"This page was generated using Literate.jl.","category":"page"},{"location":"method/#The-Voronoi-finite-volume-method","page":"The Voronoi finite volume method","title":"The Voronoi finite volume method","text":"","category":"section"},{"location":"method/#Construction-of-control-volumes","page":"The Voronoi finite volume method","title":"Construction of control volumes","text":"","category":"section"},{"location":"method/","page":"The Voronoi finite volume method","title":"The Voronoi finite volume method","text":"Start with a boundary conforming Delaunay triangulation of a polygonal domain (intervals in 1D, triangles in 2D, tetrahedra in   3D). Such a triangulation can be generated by e.g. by the mesh generators triangle and TetGen. These are available in Julia via Triangulate.jl and TetGen.jl. For simple geometries – tensor products of lower dimensional grids – such triangulation can be created more easily. The package ExtendableGrids.jl manages the grid data structure which is used in this package. SimplexGridFactory.jl interfaces this grid structure with  Triangulate.jl and TetGen.jl and provides an API for incrementally setting up geometry descriptions.\nJoin triangle circumcenters by lines rightarrow create Voronoi cells which can serve as control volumes, akin to representative elementary volumes (REV) used to derive conservation laws. ","category":"page"},{"location":"method/","page":"The Voronoi finite volume method","title":"The Voronoi finite volume method","text":"<center>\n<img src=\"../trivoro.png\" width=\"50%\">\n</center>","category":"page"},{"location":"method/","page":"The Voronoi finite volume method","title":"The Voronoi finite volume method","text":"Black + green: triangle nodes\nGray: triangle edges\nBlue: triangle circumcenters\nRed: Boundaries of Voronoi cells","category":"page"},{"location":"method/","page":"The Voronoi finite volume method","title":"The Voronoi finite volume method","text":"In order to make this construction possible, the triangulation must have the boundary conforming Delaunay property: ","category":"page"},{"location":"method/","page":"The Voronoi finite volume method","title":"The Voronoi finite volume method","text":"The interior of any triangle circumcircle does not contain any other node of the triangulation\nAll circumcircle centers lay within the domain ","category":"page"},{"location":"method/","page":"The Voronoi finite volume method","title":"The Voronoi finite volume method","text":"In 2D, an equivalent condition is:","category":"page"},{"location":"method/","page":"The Voronoi finite volume method","title":"The Voronoi finite volume method","text":"The sum of triangle angles opposite to a given interior edge is less than pi\nTriangle angles opposite to boundary edges are less than fracpi2.","category":"page"},{"location":"method/","page":"The Voronoi finite volume method","title":"The Voronoi finite volume method","text":"As a consequence, there is a 1:1 incidence between triangulation nodes and Voronoi cells. Moreover, the angle between the interface between two neigboring  Voronoi cells and the edge between their corresponding nodes is fracpi2.  Therefore the edge direction is aligned with the normal direction with respect to the boundary of the Voronoi cell. This makes it easy to use these Voronoi cells as REVs aka control volumes aka finite volume cells and to derive a space discretization for a concervation law  based on very same balance rules used to derive this conservation law.","category":"page"},{"location":"method/#The-discretization-approach","page":"The Voronoi finite volume method","title":"The discretization approach","text":"","category":"section"},{"location":"method/","page":"The Voronoi finite volume method","title":"The Voronoi finite volume method","text":"<center>\n<img src=\"../vor.png\" width=\"50%\">\n</center>","category":"page"},{"location":"method/","page":"The Voronoi finite volume method","title":"The Voronoi finite volume method","text":"Given a continuity equation nablacdot vec j=f in a domain Omega, integrate it over a contol volume omega_k with associated node vec x_k and apply Gauss theorem:","category":"page"},{"location":"method/","page":"The Voronoi finite volume method","title":"The Voronoi finite volume method","text":"beginaligned\n0=int_omega_k (nablacdot  vec j -f ) domega\n=int_partialomega_k vec jcdot vec n ds  - int_omega_k f domega\n=sum_lin N_k int_omega_kcap omega_l vec jcdot vec n ds + int_partialomega_kcap partialOmega vec jcdot vec n ds   - int_omega_k f domega \napprox sum_lin N_k fracsigma_klh_klg(u_k u_l) -  omega_k f_k + textboundary terms\nendaligned","category":"page"},{"location":"method/","page":"The Voronoi finite volume method","title":"The Voronoi finite volume method","text":"Here, N_k is the set of neighbor control volumes, sigma_kl=omega_kcap omega_l, h_kl=vec x_k -vec x_l, where  cdot denotes the measure (length resp. area) of a geometrical entity. In the approximation step, we replaced the normal flux integral over the interface between two control volumes by the measure of this interface multiplied by a function depending on the unknowns u_k u_l associated to the respective nodes divided by the distance between these nodes.  The flux function g can be derived from usual finite difference formulas discretizing a particular flux law.","category":"page"},{"location":"method/#Flux-laws","page":"The Voronoi finite volume method","title":"Flux laws","text":"","category":"section"},{"location":"method/","page":"The Voronoi finite volume method","title":"The Voronoi finite volume method","text":"For instance, for the diffusion flux vec j=-Dvecnabla u, we use g(u_k u_l)=D(u_k -u_l).","category":"page"},{"location":"method/","page":"The Voronoi finite volume method","title":"The Voronoi finite volume method","text":"For a convective diffusion flux vec j = -Dvec nabla u + u vec v, one can chose the upwind flux","category":"page"},{"location":"method/","page":"The Voronoi finite volume method","title":"The Voronoi finite volume method","text":"beginaligned\ng(u_k u_l)=D(u_k -u_l) + \nv_klbegincases\nu_k v_kl0\nu_l v_klleq 0\nendcases\nendaligned","category":"page"},{"location":"method/","page":"The Voronoi finite volume method","title":"The Voronoi finite volume method","text":"where v_kl=frach_klsigma_klint_omega_kcap omega_l vec v cdot vec n_kl  ds Fluxes also can depend nonlinearily on u.","category":"page"},{"location":"method/#Boundary-conditions","page":"The Voronoi finite volume method","title":"Boundary conditions","text":"","category":"section"},{"location":"method/","page":"The Voronoi finite volume method","title":"The Voronoi finite volume method","text":"To implement a  Robin boundary condition on Gamma=partialOmega ","category":"page"},{"location":"method/","page":"The Voronoi finite volume method","title":"The Voronoi finite volume method","text":"- vec j cdot vec n + a u = b","category":"page"},{"location":"method/","page":"The Voronoi finite volume method","title":"The Voronoi finite volume method","text":"we note that by the very construction, the discretization nodes associated to control volumes adjacent to the domain boundary are located at the domain boundary, thus we can assume that the boundary condition is valid in the corresponding collocation node u_k. We assume that partialomega_kcap partial_Omega= cup_minmathcal M_k gamma_km is the union of a finite number of line (plane) segments. For interior nodes, we set mathcal M_k = emptyset . Thus, for the boundary terms in the above equation, we have","category":"page"},{"location":"method/","page":"The Voronoi finite volume method","title":"The Voronoi finite volume method","text":"beginaligned\ntextboundary terms=sum_minmathcal M_k int_gamma_km vec j cdot vec n d s\n                     approx sum_minmathcal M_k gamma_km vec j cdot vec n\n                     approxsum_minmathcal M_k gamma_km  (au_k -b)\nendaligned","category":"page"},{"location":"method/","page":"The Voronoi finite volume method","title":"The Voronoi finite volume method","text":"We observe that for varepsilonto 0, the Robin boundary condition ","category":"page"},{"location":"method/","page":"The Voronoi finite volume method","title":"The Voronoi finite volume method","text":"- vec j cdot vec n + frac1varepsilonu = frac1varepsilong","category":"page"},{"location":"method/","page":"The Voronoi finite volume method","title":"The Voronoi finite volume method","text":"tends to the Dirichlet bundary condition ","category":"page"},{"location":"method/","page":"The Voronoi finite volume method","title":"The Voronoi finite volume method","text":"    u=g","category":"page"},{"location":"method/","page":"The Voronoi finite volume method","title":"The Voronoi finite volume method","text":"Therefore, a Dirichlet boundary condition can be approximated by choosing a small value of varepsilon and implying the aforementioned Robin boundary conditions. This approach  called penalty method  is chosen for the implementation of Dirichlet boundary conditions in this package.","category":"page"},{"location":"method/#Time-dependent-problems,-reaction-terms","page":"The Voronoi finite volume method","title":"Time dependent problems, reaction terms","text":"","category":"section"},{"location":"method/","page":"The Voronoi finite volume method","title":"The Voronoi finite volume method","text":"This approach easily generalizes to time dependent nonlinear transport-reaction problems with storage terms s(u), reaction terms r(u) and source terms f:","category":"page"},{"location":"method/","page":"The Voronoi finite volume method","title":"The Voronoi finite volume method","text":"partial_t s(u) + nabla cdot vec j + r(u) -f =0","category":"page"},{"location":"method/","page":"The Voronoi finite volume method","title":"The Voronoi finite volume method","text":"Semidiscretization in time (for implicit Euler) leads to ","category":"page"},{"location":"method/","page":"The Voronoi finite volume method","title":"The Voronoi finite volume method","text":"fracs(u)-s(u^flat)tau + nabla cdot vec j + r(u) -f =0","category":"page"},{"location":"method/","page":"The Voronoi finite volume method","title":"The Voronoi finite volume method","text":"where tau is the time step size and u^flat is the solution from the old timestep. The approximation  approach then for each control volume gives","category":"page"},{"location":"method/","page":"The Voronoi finite volume method","title":"The Voronoi finite volume method","text":"omega_kfracs(u_k)-s(u_k^flat)tau + sum_lin N_k fracsigma_klh_klg(u_k u_l)+ sum_minmathcal M_k gamma_km  (au_k -b) + omega_k (r(u_k)- f_k)=0","category":"page"},{"location":"method/","page":"The Voronoi finite volume method","title":"The Voronoi finite volume method","text":"If n is the number of discretization nodes, we get a system of n equations with n unknowns which under proper conditions on rgs has a unique solution. ","category":"page"},{"location":"method/","page":"The Voronoi finite volume method","title":"The Voronoi finite volume method","text":"The implicit Euler method is the default solver for time dependent problems. Alternatively, ODE and DAE solvers from DifferentialEquations.jl can be used.","category":"page"},{"location":"method/#Generalizations-to-systems","page":"The Voronoi finite volume method","title":"Generalizations to systems","text":"","category":"section"},{"location":"method/","page":"The Voronoi finite volume method","title":"The Voronoi finite volume method","text":"This approach generalizes to systems of partial differential equations, which formally can be written in the same way, but assuming that u is a vector function of vec xt, and rgs are vector functions of their arguments. The package allows to handle different sets of species in different subdomains of Omega.","category":"page"},{"location":"method/#Boundary-reactions,-boundary-species","page":"The Voronoi finite volume method","title":"Boundary reactions, boundary species","text":"","category":"section"},{"location":"method/","page":"The Voronoi finite volume method","title":"The Voronoi finite volume method","text":"In addition to  rgs, the package allows to specify additional boundary species, boundary reaction, boundary flux and boundary storage terms.","category":"page"},{"location":"method/#Why-this-method-?","page":"The Voronoi finite volume method","title":"Why this method ?","text":"","category":"section"},{"location":"method/","page":"The Voronoi finite volume method","title":"The Voronoi finite volume method","text":"Independent of space dimension, the method (with properly chosen flux functions) is able to preserve a number of physical quantities if they are present on the continuous level:","category":"page"},{"location":"method/","page":"The Voronoi finite volume method","title":"The Voronoi finite volume method","text":"local and global mass conservation\npositivity of solutions\nmaximum principle: in the absence of source and reaction terms, local extrema of the stationary solution are located at the domain boudaries, never in the interior. For transient problems, local extrema in the interior can only come from the initial value. \nConsistency to thermodynamics: entropy production etc.","category":"page"},{"location":"method/","page":"The Voronoi finite volume method","title":"The Voronoi finite volume method","text":"Many of these properties are hard to prove for finite element methods, in particular for the convection-diffusion case.","category":"page"},{"location":"method/#Where-is-this-method-not-appropriate-?","page":"The Voronoi finite volume method","title":"Where is this method not appropriate ?","text":"","category":"section"},{"location":"method/","page":"The Voronoi finite volume method","title":"The Voronoi finite volume method","text":"There are a number of cases where this method needs to be replaced by something else or at least to be applied with great care:","category":"page"},{"location":"method/","page":"The Voronoi finite volume method","title":"The Voronoi finite volume method","text":"Anisotropic diffusion only works with proper mesh alignment \nStrongly varying capacity (in the function s) at domain interfaces lead to inexact breakthrough curves\nSharp moving convection fronts are smeared out too strongly","category":"page"},{"location":"method/#History-and-literature","page":"The Voronoi finite volume method","title":"History and literature","text":"","category":"section"},{"location":"method/","page":"The Voronoi finite volume method","title":"The Voronoi finite volume method","text":"The following list  is work in progress and incomplete, but it references some sources behind the ideas in this package.","category":"page"},{"location":"method/","page":"The Voronoi finite volume method","title":"The Voronoi finite volume method","text":"Macneal, R. H. (1953). An asymmetrical finite difference network. Quarterly of Applied Mathematics, 11(3), 295-310.  (pdf via JSTOR). Perhaps this is the earliest mentioning of the method. Note that it  was used on an electrical analog computer. \nGärtner, K., & Kamenski, L. (2019). Why do we need Voronoi cells and Delaunay meshes? arXiv preprint arXiv:1905.01738. A recent overview on the merits of the method. One of the authors belongs to the pioneers of its application in 3D.\nFuhrmann, J., & Langmach, H. (2001). Stability and existence of solutions of time-implicit finite volume schemes for viscous nonlinear conservation laws. Applied Numerical Mathematics, 37(1-2), 201-230. A discussion of the method applied to rather general nonlinear scalar problems.\nSi, H., Gärtner, K., & Fuhrmann, J. (2010). Boundary conforming Delaunay mesh generation. Computational Mathematics and Mathematical Physics, 50(1), 38-53. Definition of the boundary conforming Delaunay property. \nEymard, R., Fuhrmann, J., & Gärtner, K. (2006). A finite volume scheme for nonlinear parabolic equations derived from one-dimensional local Dirichlet problems. Numerische Mathematik, 102(3), 463-495. General concept of the derivation of upwind fluxes for nonlinear problems.\nFarrell, P., Rotundo, N., Doan, D. H., Kantner, M., Fuhrmann, J., & Koprucki, T. (2017). Drift-diffusion models. In Handbook of Optoelectronic Device Modeling and Simulation (pp. 733-772). CRC Press. Overview and introduction to the method applied to semiconductor device simulation. This problem class profits most from the desirable properties of the method.","category":"page"},{"location":"method/#Software-API-and-implementation","page":"The Voronoi finite volume method","title":"Software API and implementation","text":"","category":"section"},{"location":"method/","page":"The Voronoi finite volume method","title":"The Voronoi finite volume method","text":"The entities describing the discrete system can be subdivided into two categories:","category":"page"},{"location":"method/","page":"The Voronoi finite volume method","title":"The Voronoi finite volume method","text":"Geometrical data: omega_k gamma_k sigma_kl h_kl together with the connectivity information simplex grid. These data are calculated  from the discretization grid.\nPhysics data: the number of species and the functions sgrf etc. describing the particular problem.","category":"page"},{"location":"method/","page":"The Voronoi finite volume method","title":"The Voronoi finite volume method","text":"The solution of the nonlinear systems of equations is performed by Newton's method combined with various direct and iterative linear solvers. The Jacobi matrices used in Newton's method are assembled from the constitutive functions whith the help of forward mode automatic differentiation implemented in  ForwardDiff.jl.","category":"page"},{"location":"grid/#Grid","page":"Grid","title":"Grid","text":"","category":"section"},{"location":"grid/#Types-and-Constants","page":"Grid","title":"Types and Constants","text":"","category":"section"},{"location":"grid/","page":"Grid","title":"Grid","text":"Modules = [VoronoiFVM]\nPages = [ \n  \"grid/file.jl\",\n  \"grid/grid_interface.jl\",\n  \"grid/grid.jl\",\n  \"grid/regionedit.jl\",\n  \"grid/subgrid.jl\",\n  \"grid/tensor.jl\",\n  \"grid/generate.jl\",\n  \"grid/tokenstream.jl\",\n]\nOrder = [:type]","category":"page"},{"location":"grid/","page":"Grid","title":"Grid","text":"Modules = [VoronoiFVM]\nPages = [ \n  \"grid/file.jl\",\n  \"grid/grid_interface.jl\",\n  \"grid/grid.jl\",\n  \"grid/regionedit.jl\",\n  \"grid/subgrid.jl\",\n  \"grid/tensor.jl\",\n  \"grid/generate.jl\",\n  \"grid/tokenstream.jl\",\n]\nOrder = [:constant]","category":"page"},{"location":"grid/#Methods","page":"Grid","title":"Methods","text":"","category":"section"},{"location":"grid/","page":"Grid","title":"Grid","text":"Modules = [VoronoiFVM]\nPages = [ \n  \"grid/file.jl\",\n  \"grid/grid_interface.jl\",\n  \"grid/grid.jl\",\n  \"grid/regionedit.jl\",\n  \"grid/subgrid.jl\",\n  \"grid/tensor.jl\",\n  \"grid/generate.jl\",\n  \"grid/tokenstream.jl\",\n]\nOrder = [:function]","category":"page"},{"location":"examples/Example405_GenericOperator/","page":"-","title":"-","text":"module Example405_GenericOperator\nusing Printf\nusing VoronoiFVM\nusing ExtendableGrids\nusing GridVisualize\n\n\nfunction main(;n=10,Plotter=nothing,verbose=false, unknown_storage=:sparse)\n    # Same as Example102 with upwind\n\n\n    # Create a one-dimensional discretization\n    h=1.0/convert(Float64,n)\n    X=collect(0:h:1)\n    grid=VoronoiFVM.Grid(X)\n\n    # A parameter which is \"passed\" to the flux function via scope\n    D=1.0e-2\n    v=1.0\n\n    # This generic operator works on the full solution seen as linear vector, and indexing\n    # into it needs to be performed with the help of idx (defined below for a solution vector)\n    # Here, instead of the flux function we provide a \"generic operator\"\n    # which provides the stiffness part of the problem. Its sparsity is detected automatically\n    # using Symbolics.jl\n    function generic_operator!(f,u,sys)\n        f.=0.0\n        for i=1:length(X)-1\n            du=D*(u[idx[1,i]]-u[idx[1,i+1]])/(X[i+1]-X[i]) + v* (v>0 ? u[idx[1,i]] : u[idx[1,i+1]])\n            f[idx[1,i]]+=du\n            f[idx[1,i+1]]-=du\n        end\n    end\n\n\n    # Create a physics structure\n    physics=VoronoiFVM.Physics(generic=generic_operator!)\n\n    # Create a finite volume system - either\n    # in the dense or  the sparse version.\n    # The difference is in the way the solution object\n    # is stored - as dense or as sparse matrix\n\n    sys=VoronoiFVM.System(grid,physics,unknown_storage=unknown_storage)\n\n    # Add species 1 to region 1\n    enable_species!(sys,1,[1])\n\n    # Set boundary conditions\n    boundary_dirichlet!(sys,1,1,0.0)\n    boundary_dirichlet!(sys,1,2,1.0)\n\n    # Create a solution array\n    inival=unknowns(sys,inival=0.5)\n    solution=unknowns(sys)\n\n    idx=unknown_indices(solution)\n    # Create solver control info\n    control=VoronoiFVM.NewtonControl()\n    control.verbose=verbose\n\n    # Stationary solution of the problem\n    solve!(solution,inival,sys, control=control)\n\n    scalarplot(grid,solution[1,:],title=\"Nonlinear Poisson\",Plotter=Plotter,resolution=(300,300))\n    return sum(solution)\nend\n\nfunction test()\n    testval=1.099999999614456\n    main(unknown_storage=:sparse) ≈ testval && main(unknown_storage=:dense) ≈ testval\nend\n\nend","category":"page"},{"location":"examples/Example405_GenericOperator/","page":"-","title":"-","text":"","category":"page"},{"location":"examples/Example405_GenericOperator/","page":"-","title":"-","text":"This page was generated using Literate.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Markdown\nMarkdown.parse(\"\"\"\n$(read(\"../../README.md\",String))\n\"\"\")","category":"page"},{"location":"examples/Example125_TestFunctions1D/#:-Terminal-flux-calculation-via-test-functions","page":"125: Terminal flux calculation via test functions","title":"125: Terminal flux calculation via test functions","text":"","category":"section"},{"location":"examples/Example125_TestFunctions1D/","page":"125: Terminal flux calculation via test functions","title":"125: Terminal flux calculation via test functions","text":"(source code)","category":"page"},{"location":"examples/Example125_TestFunctions1D/","page":"125: Terminal flux calculation via test functions","title":"125: Terminal flux calculation via test functions","text":"For a rather comprehensive explanation see 225: Terminal flux calculation via test functions, nD","category":"page"},{"location":"examples/Example125_TestFunctions1D/","page":"125: Terminal flux calculation via test functions","title":"125: Terminal flux calculation via test functions","text":"module Example125_TestFunctions1D\nusing Printf\nusing VoronoiFVM\nusing ExtendableGrids\nusing GridVisualize\n\n\nfunction main(;n=100,Plotter=nothing,verbose=false,unknown_storage=:sparse)\n    h=1/n\n    grid=VoronoiFVM.Grid(collect(0:h:1))\n\n\n    eps::Vector{Float64}=[1,1.0e-1]\n\n    physics=VoronoiFVM.Physics(\n\n    reaction=function(f,u,node)\n        f[1]=10*(u[1]-u[2])\n        f[2]=10*(u[2]-u[1])\n    end,\n\n    flux=function(f,u,edge)\n        f[1]=eps[1]*(u[1,1]-u[1,2])\n        f[2]=eps[2]*(u[2,1]-u[2,2])\n    end,\n\n\n    storage=function(f,u,node)\n        f[1]=u[1]\n        f[2]=u[2]\n    end\n    )\n    sys=VoronoiFVM.System(grid,physics,unknown_storage=unknown_storage)\n\n    enable_species!(sys,1,[1])\n    enable_species!(sys,2,[1])\n\n    boundary_neumann!(sys,1,1,0.01)\n    boundary_dirichlet!(sys,2,2,0.0)\n\n    factory=TestFunctionFactory(sys)\n    tf1=testfunction(factory,[2],[1])\n    tf2=testfunction(factory,[1],[2])\n\n\n    U=unknowns(sys)\n    inival=unknowns(sys)\n    inival[2,:].=0.1\n    inival[1,:].=0.1\n\n    control=VoronoiFVM.NewtonControl()\n    control.verbose=verbose\n    control.damp_initial=0.1\n    I1=0\n    p=GridVisualizer(Plotter=Plotter,layout=(2,1))\n    for xeps in [1.0,0.1,0.01]\n        eps=[xeps,xeps]\n        solve!(U,inival,sys,control=control)\n        I1=integrate(sys,tf1,U)\n        coord=coordinates(grid)\n        inival.=U\n        scalarplot!(p[1,1],grid,U[1,:])\n        scalarplot!(p[2,1],grid,U[2,:])\n        reveal(p)\n        u5=U[5]\n    end\n    return I1[1]\nend\n\nfunction test()\n    main(unknown_storage=:sparse) ≈ 0.01 &&\n        main(unknown_storage=:dense) ≈ 0.01\nend\nend","category":"page"},{"location":"examples/Example125_TestFunctions1D/","page":"125: Terminal flux calculation via test functions","title":"125: Terminal flux calculation via test functions","text":"","category":"page"},{"location":"examples/Example125_TestFunctions1D/","page":"125: Terminal flux calculation via test functions","title":"125: Terminal flux calculation via test functions","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/Example103_ConvectionDiffusion1D/#:-1D-Convection-diffusion-equation","page":"103: 1D Convection-diffusion equation","title":"103: 1D Convection-diffusion equation","text":"","category":"section"},{"location":"examples/Example103_ConvectionDiffusion1D/","page":"103: 1D Convection-diffusion equation","title":"103: 1D Convection-diffusion equation","text":"(source code)","category":"page"},{"location":"examples/Example103_ConvectionDiffusion1D/","page":"103: 1D Convection-diffusion equation","title":"103: 1D Convection-diffusion equation","text":"Solve the equation","category":"page"},{"location":"examples/Example103_ConvectionDiffusion1D/","page":"103: 1D Convection-diffusion equation","title":"103: 1D Convection-diffusion equation","text":"partial_t u -nabla ( D nabla u - v u) = 0","category":"page"},{"location":"examples/Example103_ConvectionDiffusion1D/","page":"103: 1D Convection-diffusion equation","title":"103: 1D Convection-diffusion equation","text":"in Omega=(01) with homogeneous Neumann boundary conditon at x=0 and outflow boundary condition at x=1.","category":"page"},{"location":"examples/Example103_ConvectionDiffusion1D/","page":"103: 1D Convection-diffusion equation","title":"103: 1D Convection-diffusion equation","text":"module Example103_ConvectionDiffusion1D\nusing Printf\nusing VoronoiFVM\nusing ExtendableGrids\nusing GridVisualize\n\n# Bernoulli function used in the exponential fitting discretization\nfunction bernoulli(x)\n    if abs(x)<nextfloat(eps(typeof(x)))\n        return 1\n    end\n    return x/(exp(x)-1)\nend\n\nfunction exponential_flux!(f,u,edge,data)\n    vh=project(edge,data.v)\n    Bplus= data.D*bernoulli(vh/data.D)\n    Bminus=data.D*bernoulli(-vh/data.D)\n    f[1]=Bminus*u[1,1]-Bplus*u[1,2]\nend\n\nfunction outflow!(f,u,node,data)\n    if node.region==2\n        f[1]=data.v[1]*u[1]\n    end\nend\n\n\n\nfunction main(;n=10,Plotter=nothing,D=0.01,v=1.0,tend=100)\n\n    # Create a one-dimensional discretization\n    h=1.0/n\n    grid=VoronoiFVM.Grid(0:h:1)\n\n    data=(v=[v],D=D)\n\n    sys=VoronoiFVM.System(grid,VoronoiFVM.Physics(flux=exponential_flux!, data=data, breaction=outflow!))\n\n    # Add species 1 to region 1\n    enable_species!(sys,1,[1])\n\n    # Set boundary conditions\n    boundary_neumann!(sys,1,1,0.0)\n\n    # Create a solution array\n    inival=unknowns(sys)\n    inival[1,:].=map(x->1-2x,grid)\n\n    # Transient solution of the problem\n    control=VoronoiFVM.NewtonControl()\n    control.Δt=0.01*h\n    control.Δt_min=0.01*h\n    control.Δt_max=0.1*tend\n    tsol=solve(inival,sys,[0,tend],control=control)\n\n    vis=GridVisualizer(Plotter=Plotter)\n    for i=1:length(tsol.t)\n        scalarplot!(vis[1,1],grid,tsol[1,:,i],flimits=(0,1),title=\"t=$(tsol.t[i])\",show=true)\n        sleep(0.01)\n    end\n    tsol\nend\n\nfunction test()\n    tsol=main()\n    maximum(tsol)<=1.0 && maximum(tsol[end])<1.0e-20\nend\n\nend","category":"page"},{"location":"examples/Example103_ConvectionDiffusion1D/","page":"103: 1D Convection-diffusion equation","title":"103: 1D Convection-diffusion equation","text":"","category":"page"},{"location":"examples/Example103_ConvectionDiffusion1D/","page":"103: 1D Convection-diffusion equation","title":"103: 1D Convection-diffusion equation","text":"This page was generated using Literate.jl.","category":"page"},{"location":"solutions/#Solution-objects","page":"Solution objects","title":"Solution objects","text":"","category":"section"},{"location":"solutions/#Dense-solution-arrays","page":"Solution objects","title":"Dense solution arrays","text":"","category":"section"},{"location":"solutions/","page":"Solution objects","title":"Solution objects","text":"Modules = [VoronoiFVM]\nPages=[\"vfvm_densesolution.jl\"]","category":"page"},{"location":"solutions/#VoronoiFVM.DenseSolutionArray","page":"Solution objects","title":"VoronoiFVM.DenseSolutionArray","text":"const DenseSolutionArray=Matrix\n\nDense storage of solution\n\n\n\n\n\n","category":"type"},{"location":"solutions/#VoronoiFVM.dof-Union{Tuple{Tv}, Tuple{Matrix{Tv}, Integer, Integer}} where Tv","page":"Solution objects","title":"VoronoiFVM.dof","text":"dof(a, ispec, K)\n\n\nGet degree of freedom number\n\n\n\n\n\n","category":"method"},{"location":"solutions/#VoronoiFVM.values-Union{Tuple{Matrix{Tv}}, Tuple{Tv}} where Tv","page":"Solution objects","title":"VoronoiFVM.values","text":"Array of values in solution array.\n\n\n\n\n\n","category":"method"},{"location":"solutions/#Sparse-solution-arrays","page":"Solution objects","title":"Sparse solution arrays","text":"","category":"section"},{"location":"solutions/","page":"Solution objects","title":"Solution objects","text":"Modules = [VoronoiFVM]\nPages=[\"vfvm_sparsesolution.jl\"]","category":"page"},{"location":"solutions/#VoronoiFVM.SparseSolutionArray","page":"Solution objects","title":"VoronoiFVM.SparseSolutionArray","text":"struct SparseSolutionArray{Tv, Ti} <: AbstractArray{Tv, 2}\n\nStruct holding solution information for SparseSystem. Solution is stored in a sparse matrix structure.\n\nThis class plays well with the abstract array interface.\n\nFields:\n\nnode_dof::SparseArrays.SparseMatrixCSC{Tv, Ti} where {Tv, Ti}\nSparse matrix holding actual data.\n\n\n\n\n\n","category":"type"},{"location":"solutions/#Base.copy-Union{Tuple{VoronoiFVM.SparseSolutionArray{Tv, Ti}}, Tuple{Ti}, Tuple{Tv}} where {Tv, Ti}","page":"Solution objects","title":"Base.copy","text":"Create a copy of sparse solution array\n\n\n\n\n\n","category":"method"},{"location":"solutions/#Base.getindex-Tuple{VoronoiFVM.SparseSolutionArray, Integer, Integer}","page":"Solution objects","title":"Base.getindex","text":"getindex(a, ispec, inode)\n\n\nAccessor for sparse solution array.\n\n\n\n\n\n","category":"method"},{"location":"solutions/#Base.setindex!-Tuple{VoronoiFVM.SparseSolutionArray, Any, Integer, Integer}","page":"Solution objects","title":"Base.setindex!","text":"setindex!(a, v, ispec, inode)\n\n\nAccessor for sparse solution array.\n\n\n\n\n\n","category":"method"},{"location":"solutions/#Base.similar-Union{Tuple{VoronoiFVM.SparseSolutionArray{Tv, Ti}}, Tuple{Ti}, Tuple{Tv}} where {Tv, Ti}","page":"Solution objects","title":"Base.similar","text":"Create a similar unintialized sparse solution array\n\n\n\n\n\n","category":"method"},{"location":"solutions/#Base.size-Tuple{VoronoiFVM.SparseSolutionArray}","page":"Solution objects","title":"Base.size","text":"size(a)\n\n\nReturn size of sparse solution array.\n\n\n\n\n\n","category":"method"},{"location":"solutions/#VoronoiFVM.dof-Union{Tuple{Ti}, Tuple{Tv}, Tuple{VoronoiFVM.SparseSolutionArray{Tv, Ti}, Integer, Integer}} where {Tv, Ti}","page":"Solution objects","title":"VoronoiFVM.dof","text":"dof(a, i, j)\n\n\nGet number of degree of freedom. Return 0 if species is not defined in node.\n\n\n\n\n\n","category":"method"},{"location":"solutions/#VoronoiFVM.getdof-Tuple{VoronoiFVM.SparseSolutionArray, Integer}","page":"Solution objects","title":"VoronoiFVM.getdof","text":"getdof(a, i)\n\n\nReturn  value for degree of freedom.\n\n\n\n\n\n","category":"method"},{"location":"solutions/#VoronoiFVM.setdof!-Tuple{VoronoiFVM.SparseSolutionArray, Any, Integer}","page":"Solution objects","title":"VoronoiFVM.setdof!","text":"setdof!(a, v, i)\n\n\nSet value for degree of freedom.\n\n\n\n\n\n","category":"method"},{"location":"solutions/#VoronoiFVM.values-Tuple{VoronoiFVM.SparseSolutionArray}","page":"Solution objects","title":"VoronoiFVM.values","text":"values(a)\n\n\nArray of values in sparse solution array.\n\n\n\n\n\n","category":"method"},{"location":"solutions/#Transient-solution","page":"Solution objects","title":"Transient solution","text":"","category":"section"},{"location":"solutions/","page":"Solution objects","title":"Solution objects","text":"Modules = [VoronoiFVM]\nPages=[\"vfvm_transientsolution.jl\"]","category":"page"},{"location":"solutions/#VoronoiFVM.AbstractTransientSolution","page":"Solution objects","title":"VoronoiFVM.AbstractTransientSolution","text":"abstract type AbstractTransientSolution{T, N, A, B} <: AbstractDiffEqArray{T, N, A}\n\nAbstract type for transient solution\n\n\n\n\n\n","category":"type"},{"location":"solutions/#VoronoiFVM.TransientSolution","page":"Solution objects","title":"VoronoiFVM.TransientSolution","text":"mutable struct TransientSolution{T, N, A, B} <: VoronoiFVM.AbstractTransientSolution{T, N, A, B}\n\nTransient solution structure\n\nFields\n\nu::Any\nVector of solutions\n\nt::Any\nVector of times\n\nInterface\n\nObject of this type adhere to the AbstractDiffEqArray  interface. For indexing and interpolation, see https://diffeq.sciml.ai/stable/basics/solution/.\n\nIn particular, a TransientSolution sol can be accessed as follows:\n\nsol[i] contains the solution for timestep i\nsol[ispec,:,i] contains the solution for component ispec at timestep i\nsol(t) returns a (linearly) interpolated solution value for t.\nsol.t[i] is the corresponding time for timestep i\nsol[ispec,ix,i] refers to solution of component ispec at node ix at moment i\n\n\n\n\n\n","category":"type"},{"location":"solutions/#VoronoiFVM.TransientSolution-Union{Tuple{T}, Tuple{Number, AbstractArray{T}}} where T","page":"Solution objects","title":"VoronoiFVM.TransientSolution","text":"TransientSolution(t0,inival;\n                  in_memory=true,\n                  keep_open=true,\n                  fname=tempname(pwd())*\".jld2\"\n\nConstructor of transient solution with initial value and inital time.\n\nin_memory: if true (default), data are kept in main memory, otherwise on disk (via JLD2)\nkeep_open: if true, disk file is not closed during the existence of the object\nfname: file name for the disk file\n\n\n\n\n\n","category":"method"},{"location":"solutions/#VoronoiFVM.VectorOfDiskArrays-Union{Tuple{AbstractArray{T}}, Tuple{T}} where T","page":"Solution objects","title":"VoronoiFVM.VectorOfDiskArrays","text":"VectorOfDiskArrays(firstobj:AbstractArray;\n                   keep_open=true,\n                   fname= fname=tempname(pwd())*\".jld2\")\n\nConstructor of vector of arrays stored on disk (via JLD2).\n\nkeep_open: if true, disk file is not closed during the existence of the object\nfname: file name for the disk file\n\nThe disk file is automatically removed if the object is garbage collected.\n\n\n\n\n\n","category":"method"},{"location":"examples/Example301_Laplace3D/#:-3D-Laplace-equation","page":"301: 3D Laplace equation","title":"301: 3D Laplace equation","text":"","category":"section"},{"location":"examples/Example301_Laplace3D/","page":"301: 3D Laplace equation","title":"301: 3D Laplace equation","text":"(source code)","category":"page"},{"location":"examples/Example301_Laplace3D/","page":"301: 3D Laplace equation","title":"301: 3D Laplace equation","text":"module Example301_Laplace3D\n\nusing VoronoiFVM,ExtendableGrids\nusing GridVisualize\n\n\n# Flux function which describes the flux\n# between neigboring control volumes\nfunction g!(f,u,edge)\n    f[1]=u[1,1]-u[1,2]\nend\n\nfunction s(f,node)\n    n=view(node.coord,:,node.index)\n    f[1]=n[1]*sin(5.0*n[2])*exp(n[3])\nend\n\n\nfunction main(;Plotter=nothing,n=5)\n    nspecies=1\n    ispec=1\n    X=collect(0:1/n:1)\n    grid=VoronoiFVM.Grid(X,X,X)\n    physics=VoronoiFVM.Physics(flux=g!,source=s)\n    sys=VoronoiFVM.System(grid,physics)\n    enable_species!(sys,ispec,[1])\n    boundary_dirichlet!(sys,ispec,5,0.0)\n    boundary_dirichlet!(sys,ispec,6,0.0)\n    inival=unknowns(sys,inival=0)\n    solution=unknowns(sys)\n    solve!(solution,inival,sys)\n    scalarplot(grid,solution[1,:],Plotter=Plotter,zplane=0.5, flevel=0.5)\n    return solution[43]\nend\n\n# Called by unit test\n\nfunction test()\n    main() ≈ 0.012234524449380824\nend\n\nend","category":"page"},{"location":"examples/Example301_Laplace3D/","page":"301: 3D Laplace equation","title":"301: 3D Laplace equation","text":"","category":"page"},{"location":"examples/Example301_Laplace3D/","page":"301: 3D Laplace equation","title":"301: 3D Laplace equation","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/Example121_PoissonPointCharge1D/#:-1D-Poisson-with-point-charge","page":"121: 1D Poisson with point charge","title":"121: 1D Poisson with point charge","text":"","category":"section"},{"location":"examples/Example121_PoissonPointCharge1D/","page":"121: 1D Poisson with point charge","title":"121: 1D Poisson with point charge","text":"(source code)","category":"page"},{"location":"examples/Example121_PoissonPointCharge1D/","page":"121: 1D Poisson with point charge","title":"121: 1D Poisson with point charge","text":"Solve a Poisson equation","category":"page"},{"location":"examples/Example121_PoissonPointCharge1D/","page":"121: 1D Poisson with point charge","title":"121: 1D Poisson with point charge","text":"- Delta u = 0","category":"page"},{"location":"examples/Example121_PoissonPointCharge1D/","page":"121: 1D Poisson with point charge","title":"121: 1D Poisson with point charge","text":"in Omega=(-11) with a point charge Q at x=0.","category":"page"},{"location":"examples/Example121_PoissonPointCharge1D/","page":"121: 1D Poisson with point charge","title":"121: 1D Poisson with point charge","text":"module Example121_PoissonPointCharge1D\n\nusing Printf\n\nusing VoronoiFVM\nusing ExtendableGrids\nusing GridVisualize\n\nfunction main(;nref=0,Plotter=nothing, verbose=false, unknown_storage=:sparse, brea=false)\n\n    # Create grid in (-1,1) refined around 0\n    hmax=0.2/2.0^nref\n    hmin=0.05/2.0^nref\n    X1=geomspace(-1.0,0.0, hmax,hmin)\n    X2=geomspace(0.0,1.0, hmin,hmax)\n    X=glue(X1,X2)\n    grid=VoronoiFVM.Grid(X)\n\n    # Edit default region numbers:\n    #   additional boundary region 3 at 0.0\n    bfacemask!(grid, [0.0],[0.0],3)\n    # Material 1 left of 0\n    cellmask!(grid, [-1.0],[0.0],1)\n    # Material 2 right of 0\n    cellmask!(grid, [0.0],[1.0],2)\n\n\n    Q::Float64=0.0\n\n    function flux!(f,u,edge)\n        f[1]=u[1,1]-u[1,2]\n    end\n    function storage!(f,u,node)\n        f[1]=u[1]\n    end\n\n    # Define boundary reaction defining charge\n    # Note that the term  is written on  the left hand side, therefore the - sign\n    function breaction!(f,u,node)\n        if node.region==3\n            f[1]=-Q\n        end\n    end\n\n   # Create physics\n    physics=VoronoiFVM.Physics(\n        flux=flux!,\n        storage=storage!,\n        breaction=breaction!\n    )\n\n    # Create system\n    sys=VoronoiFVM.System(grid,physics,unknown_storage=:dense)\n\n    #  put potential into both regions\n    enable_species!(sys,1,[1,2])\n\n    # Set boundary conditions\n\n    boundary_dirichlet!(sys,1,1,1.0)\n    boundary_dirichlet!(sys,1,2,0.0)\n\n    # Create a solution array\n    inival=unknowns(sys)\n    U=unknowns(sys)\n    inival.=0\n\n    # Create solver control info\n    control=VoronoiFVM.NewtonControl()\n    control.verbose=verbose\n\n\n    vis=GridVisualizer(Plotter=Plotter)\n    # Solve and plot for several values of charge\n    for q in [0.1,0.2,0.4,0.8,1.6]\n\n        if brea\n            # Charge in reaction term\n            Q=q\n        else\n            # Charge as boundary condition\n            sys.boundary_values[1,3]=q\n        end\n        solve!(U,inival,sys, control=control)\n\n        # Plot data\n\n        scalarplot!(vis,grid,U[1,:],title=@sprintf(\"Q=%.2f\",q),clear=true,show=true)\n    end\n    return sum(U)\nend\n\nfunction test()\n    main()≈20.254591679579015\nend\nend","category":"page"},{"location":"examples/Example121_PoissonPointCharge1D/","page":"121: 1D Poisson with point charge","title":"121: 1D Poisson with point charge","text":"","category":"page"},{"location":"examples/Example121_PoissonPointCharge1D/","page":"121: 1D Poisson with point charge","title":"121: 1D Poisson with point charge","text":"This page was generated using Literate.jl.","category":"page"},{"location":"nbhtml/problemcase/#problemcase","page":"A case for caution","title":"problemcase.jl","text":"","category":"section"},{"location":"nbhtml/problemcase/","page":"A case for caution","title":"A case for caution","text":"Download this Pluto.jl notebook.","category":"page"},{"location":"nbhtml/problemcase/","page":"A case for caution","title":"A case for caution","text":"<iframe style=\"height:15000px\" width=\"100%\" src=\"../problemcase.html\"> </iframe>","category":"page"},{"location":"physics/#Physics-and-special-functions","page":"Physics & special functions","title":"Physics & special functions","text":"","category":"section"},{"location":"physics/#Physics","page":"Physics & special functions","title":"Physics","text":"","category":"section"},{"location":"physics/","page":"Physics & special functions","title":"Physics & special functions","text":"Modules = [VoronoiFVM]\nPages = [\"vfvm_physics.jl\"]","category":"page"},{"location":"physics/#VoronoiFVM.AbstractData","page":"Physics & special functions","title":"VoronoiFVM.AbstractData","text":"abstract type AbstractData\n\nAbstract type for user data.\n\ncompat: Compat\nWill be removed in future versions\n\n\n\n\n\n","category":"type"},{"location":"physics/#VoronoiFVM.AbstractPhysics","page":"Physics & special functions","title":"VoronoiFVM.AbstractPhysics","text":"abstract type AbstractPhysics\n\nAbstract type for physics.\n\n\n\n\n\n","category":"type"},{"location":"physics/#VoronoiFVM.Physics","page":"Physics & special functions","title":"VoronoiFVM.Physics","text":"struct Physics\n\nPhysics data record with the following fields:\n\nflux::Function\nFlux between neigboring control volumes: flux(f,_u,edge) or flux(f,_u,edge,data) should return in f[i] the flux of species i along the edge joining circumcenters of neigboring control volumes. u=unknowns(_u) returns a 2D array such that for species i, u[i,1] and u[i,2] contain the unknown values at the corresponding ends of the edge.\n\nstorage::Function\nStorage term (term under time derivative): storage(f,u,node) or storage(f,u,node,data)\nIt should return in f[i] the storage term for the i-th equation. u[i] contains the value of the i-th unknown.\n\nreaction::Function\nReaction term:  reaction(f,u,node) or reaction(f,u,node,data)\nIt should return in f[i] the reaction term for the i-th equation. u[i] contains the value of the i-th unknown.\n\nsource::Function\nSource term: source(f,node) or source(f,node,data).\nIt should return the in f[i] the value of the source term for the i-th equation.\n\nbflux::Function\nFlux between neighboring control volumes on the boundary\n\nbreaction::Function\nBoundary reaction term:  breaction(f,u,node) or breaction(f,u,node,data) Similar to reaction, but restricted to the inner or outer boundaries.\n\nbsource::Function\nBoundary source term: bsource(f,node) or bsource(f,node,data).\nIt should return in f[i] the value of the source term for the i-th equation.\n\nbstorage::Function\nBoundary storage term: bstorage(f,u,node) or bstorage(f,u,node,data) Similar to storage, but restricted to the inner or outer boundaries.\n\ngeneric_operator::Function\nGeneric operator  generic_operator(f,u,sys). This operator acts on the full solution u of a system. Sparsity is detected automatically  unless generic_operator_sparsity is given.\n\ngeneric_operator_sparsity::Function\nFunction defining the sparsity structure of the generic operator. This should return the sparsity pattern of the generic_operator.\n\ndata::Any\nUser data (parameters). This allows to pass various parameters to the callback functions.\n\nnum_species::Int8\nNumber of species including boundary species.\n\n\n\n\n\n","category":"type"},{"location":"physics/#VoronoiFVM.Physics-Tuple{}","page":"Physics & special functions","title":"VoronoiFVM.Physics","text":"Physics(;num_species=0,\n         data=nothing,\n         flux,\n         reaction,\n         storage,\n         source,\n         breaction,\n         bstorage,\n         generic,\n         generic_sparsity\n    )\n\nConstructor for physics data. For the meaning of the optional keyword arguments, see VoronoiFVM.System(grid::ExtendableGrid; kwargs...).\n\n\n\n\n\n","category":"method"},{"location":"physics/#Base.show-Tuple{IO, VoronoiFVM.AbstractPhysics}","page":"Physics & special functions","title":"Base.show","text":"show(io, physics)\n\n\nShow physics object\n\n\n\n\n\n","category":"method"},{"location":"physics/#VoronoiFVM.hasdata-Tuple{VoronoiFVM.Physics}","page":"Physics & special functions","title":"VoronoiFVM.hasdata","text":"hasdata(physics)\n\n\nCheck if physics object has data\n\n\n\n\n\n","category":"method"},{"location":"physics/#VoronoiFVM.@create_physics_wrappers-NTuple{5, Any}","page":"Physics & special functions","title":"VoronoiFVM.@create_physics_wrappers","text":"@create_physics_wrappers(physics,node,bnode,edge,bedge)\n\nCreate wrapper functions around physics callbacks which fit the API of ForwardDiff.jacobian! and pass the data parameter if necessary. These are meant to  be defined before performing assembly loops. The macro creates the follwing variables:\n\nwrapper functions: fluxwrap,storagewrap,reactionwrap,bstoragewrap, breactionwrap\nflag variables: issource, isreaction,isbreaction,isbstorage\n\n\n\n\n\n","category":"macro"},{"location":"physics/#Edge-and-node-data","page":"Physics & special functions","title":"Edge and node data","text":"","category":"section"},{"location":"physics/","page":"Physics & special functions","title":"Physics & special functions","text":"Modules = [VoronoiFVM]\nPages = [\"vfvm_geometryitems.jl\"]\n]","category":"page"},{"location":"physics/#VoronoiFVM.AbstractEdge","page":"Physics & special functions","title":"VoronoiFVM.AbstractEdge","text":"abstract type AbstractEdge{Tv<:Number, Ti<:Integer} <: VoronoiFVM.AbstractGeometryItem{Tv<:Number, Ti<:Integer}\n\nAbstract type for edges \n\nedge[idim,inode] gives coordinate of node.\n\n\n\n\n\n","category":"type"},{"location":"physics/#VoronoiFVM.AbstractEdgeData","page":"Physics & special functions","title":"VoronoiFVM.AbstractEdgeData","text":"abstract type AbstractEdgeData{T<:Number} <: AbstractArray{T<:Number, 2}\n\nAbstract type for data on edges. u[ispec,inode] accesses value of species at corresponding node.\n\n\n\n\n\n","category":"type"},{"location":"physics/#VoronoiFVM.AbstractGeometryItem","page":"Physics & special functions","title":"VoronoiFVM.AbstractGeometryItem","text":"abstract type AbstractGeometryItem{Tv<:Number, Ti<:Integer}\n\nAbstract type for geometry items (node,bnode,edge, bedge)\n\n\n\n\n\n","category":"type"},{"location":"physics/#VoronoiFVM.AbstractNode","page":"Physics & special functions","title":"VoronoiFVM.AbstractNode","text":"abstract type AbstractNode{Tv<:Number, Ti<:Integer} <: VoronoiFVM.AbstractGeometryItem{Tv<:Number, Ti<:Integer}\n\nAbstract type for nodes. \n\nnode[idim] gives the the corresponding coordinate.\n\n\n\n\n\n","category":"type"},{"location":"physics/#VoronoiFVM.AbstractNodeData","page":"Physics & special functions","title":"VoronoiFVM.AbstractNodeData","text":"abstract type AbstractNodeData{T<:Number} <: AbstractArray{T<:Number, 1}\n\nAbstract type for data on nodes. u[ispec] accesses value of species at this node.\n\n\n\n\n\n","category":"type"},{"location":"physics/#VoronoiFVM.BEdge","page":"Physics & special functions","title":"VoronoiFVM.BEdge","text":"mutable struct BEdge{Tv, Ti} <: VoronoiFVM.AbstractEdge{Tv, Ti}\n\nStructure holding local edge information.\n\nindex::Any\nIndex in grid\n\nnode::Vector\nIndex\n\nregion::Any\nInner region number corresponding to edge\n\nnspec::Any\nNumber of species defined in edge\n\nicell::Any\nNumber of discretization cell the edge is invoked from\n\ncoord::Matrix\nGrid coordinates\n\nbedgenodes::Matrix\nbfaceedges::Matrix\nbfaceregions::Vector\ntime::Any\nSystem time\n\nembedparam::Any\nCurrent value of embedding parameter\n\n\n\n\n\n","category":"type"},{"location":"physics/#VoronoiFVM.BNode","page":"Physics & special functions","title":"VoronoiFVM.BNode","text":"mutable struct BNode{Tv, Ti} <: VoronoiFVM.AbstractNode{Tv, Ti}\n\nStructure holding local boundary  node information.\n\nindex::Any\nIndex in grid\n\nibface::Any\nBFace number it is called from\n\nibnode::Any\nlocal node number\n\nregion::Any\nBoundary region number\n\ncellregions::Vector\nnspec::Any\nNumber of species defined in node\n\ncoord::Matrix\nGrid coordinates\n\nbfacenodes::Matrix\nbfaceregions::Vector\nallcellregions::Vector\nbfacecells::Adjacency\nDirichlet::Any\ntime::Any\nSystem time\n\nembedparam::Any\nCurrent value of embedding parameter\n\ndirichlet_value::Vector\n\n\n\n\n\n","category":"type"},{"location":"physics/#VoronoiFVM.Edge","page":"Physics & special functions","title":"VoronoiFVM.Edge","text":"mutable struct Edge{Tv, Ti} <: VoronoiFVM.AbstractEdge{Tv, Ti}\n\nStructure holding local edge information.\n\nindex::Any\nIndex in grid\n\nnode::Vector\nIndex\n\nregion::Any\nInner region number corresponding to edge\n\nnspec::Any\nNumber of species defined in edge\n\nicell::Any\nNumber of discretization cell the edge is invoked from\n\ncoord::Matrix\nGrid coordinates\n\ncellx::Matrix\nedgenodes::Matrix\ncellregions::Vector\nhas_celledges::Bool\ntime::Any\nSystem time\n\nembedparam::Any\nCurrent value of embedding parameter\n\n\n\n\n\n","category":"type"},{"location":"physics/#VoronoiFVM.Node","page":"Physics & special functions","title":"VoronoiFVM.Node","text":"mutable struct Node{Tv, Ti} <: VoronoiFVM.AbstractNode{Tv, Ti}\n\nStructure holding local node information.\n\nindex::Any\nIndex in grid\n\nregion::Any\nInner region number\n\nnspec::Any\nNumber of species defined in node\n\nicell::Any\nNumber of discretization cell the node is invoked from\n\ncoord::Matrix\nGrid coordinates\n\ncellnodes::Matrix\nGrid cell nodes\n\ncellregions::Vector\nGrid cell regions\n\ntime::Any\nSystem time\n\nembedparam::Any\nCurrent value of embedding parameter\n\n\n\n\n\n","category":"type"},{"location":"physics/#VoronoiFVM.NodeRHS","page":"Physics & special functions","title":"VoronoiFVM.NodeRHS","text":"struct NodeRHS{T, Tv, Ti} <: VoronoiFVM.AbstractNodeData{T}\n\nRHS data on node. \n\n\n\n\n\n","category":"type"},{"location":"physics/#VoronoiFVM.NodeUnknowns","page":"Physics & special functions","title":"VoronoiFVM.NodeUnknowns","text":"struct NodeUnknowns{T, Tv, Ti} <: VoronoiFVM.AbstractNodeData{T}\n\nUnknown data on node. \n\n\n\n\n\n","category":"type"},{"location":"physics/#VoronoiFVM.VectorUnknowns","page":"Physics & special functions","title":"VoronoiFVM.VectorUnknowns","text":"struct VectorUnknowns{T} <: AbstractArray{T, 1}\n\nWrapper struct for viewing unknowns passed to callback functions\n\nval::Vector\nn::Int64\noffset::Int64\n\n\n\n\n\n","category":"type"},{"location":"physics/#VoronoiFVM.meas-Tuple{VoronoiFVM.AbstractEdge}","page":"Physics & special functions","title":"VoronoiFVM.meas","text":"meas(edge::VoronoiFVM.AbstractEdge) -> Any\n\n\nCalculate the length of an edge. \n\n\n\n\n\n","category":"method"},{"location":"physics/#VoronoiFVM.num_species-Tuple{VoronoiFVM.AbstractEdge}","page":"Physics & special functions","title":"VoronoiFVM.num_species","text":"num_species(edge::VoronoiFVM.AbstractEdge) -> Any\n\n\nReturn number of species for edge\n\n\n\n\n\n","category":"method"},{"location":"physics/#VoronoiFVM.unknowns-Union{Tuple{T}, Tuple{VoronoiFVM.AbstractEdge, AbstractVector{T}, Any}} where T","page":"Physics & special functions","title":"VoronoiFVM.unknowns","text":"unknowns(edge::VoronoiFVM.AbstractEdge, u::AbstractArray{T, 1}, i) -> VoronoiFVM.VectorUnknowns\n\n\nConstruct vector unknowns on edge.\n\n\n\n\n\n","category":"method"},{"location":"physics/#VoronoiFVM.viewK-Tuple{VoronoiFVM.AbstractEdge, Any}","page":"Physics & special functions","title":"VoronoiFVM.viewK","text":"viewK(edge::VoronoiFVM.AbstractEdge, u) -> VoronoiFVM.VectorUnknowns\n\n\nSolution view on first edge node\n\n\n\n\n\n","category":"method"},{"location":"physics/#VoronoiFVM.viewL-Tuple{VoronoiFVM.AbstractEdge, Any}","page":"Physics & special functions","title":"VoronoiFVM.viewL","text":"viewL(edge::VoronoiFVM.AbstractEdge, u) -> VoronoiFVM.VectorUnknowns\n\n\nSolution view on second edge node\n\n\n\n\n\n","category":"method"},{"location":"physics/#Special-functions","page":"Physics & special functions","title":"Special functions","text":"","category":"section"},{"location":"physics/","page":"Physics & special functions","title":"Physics & special functions","text":"Modules = [VoronoiFVM]\nPages = [\"vfvm_functions.jl\"]","category":"page"},{"location":"physics/#VoronoiFVM.fbernoulli-Tuple{Any}","page":"Physics & special functions","title":"VoronoiFVM.fbernoulli","text":"fbernoulli(x)\n\n\nBernoulli function B(x)=fracxe^x-1 for exponentially fitted upwinding.\n\nThe name fbernoulli has been chosen to avoid confusion with Bernoulli from JuliaStats/Distributions.jl\n\nReturns a real number containing the result.\n\n\n\n\n\n","category":"method"},{"location":"physics/#VoronoiFVM.fbernoulli_pm-Tuple{Any}","page":"Physics & special functions","title":"VoronoiFVM.fbernoulli_pm","text":"fbernoulli_pm(x)\n\n\nBernoulli function B(x)=fracxe^x-1 for exponentially fitted upwind, joint evaluation for positive and negative argument\n\nUsually, we need B(x) B(-x) togehter,  and it is cheaper to calculate them together.\n\nReturns two real numbers containing the result for argument x and argument -x.\n\nThe error in comparison with the evaluation of the original expression with BigFloat is less than 1.0e-15\n\n\n\n\n\n","category":"method"},{"location":"post/#Postprocessing","page":"Postprocessing","title":"Postprocessing","text":"","category":"section"},{"location":"post/#Plotting","page":"Postprocessing","title":"Plotting","text":"","category":"section"},{"location":"post/","page":"Postprocessing","title":"Postprocessing","text":"Plotting can be performed using the package GridVisualize.jl.","category":"page"},{"location":"post/#Solution-integrals","page":"Postprocessing","title":"Solution integrals","text":"","category":"section"},{"location":"post/","page":"Postprocessing","title":"Postprocessing","text":"Modules = [VoronoiFVM]\nPages = [\"vfvm_intergrals.jl\"]","category":"page"},{"location":"post/#Boundary-flux-calculation","page":"Postprocessing","title":"Boundary flux calculation","text":"","category":"section"},{"location":"post/","page":"Postprocessing","title":"Postprocessing","text":"Modules = [VoronoiFVM]\nPages = [\"vfvm_testfunctions.jl\"]","category":"page"},{"location":"post/#VoronoiFVM.TestFunctionFactory","page":"Postprocessing","title":"VoronoiFVM.TestFunctionFactory","text":"mutable struct TestFunctionFactory{Tv}\n\nData structure containing DenseSystem used to calculate test functions for boundary flux calculations.\n\nsystem::VoronoiFVM.AbstractSystem{Tv} where Tv\nOriginal system\n\ntfsystem::VoronoiFVM.System{Tv, Ti, Tm, Matrix{Ti}, Matrix{Tv}} where {Tv, Ti, Tm}\nTest function system\n\n\n\n\n\n","category":"type"},{"location":"post/#VoronoiFVM.TestFunctionFactory-Union{Tuple{VoronoiFVM.AbstractSystem{Tv}}, Tuple{Tv}} where Tv","page":"Postprocessing","title":"VoronoiFVM.TestFunctionFactory","text":"Constructor for TestFunctionFactory from System\n\n\n\n\n\n","category":"method"},{"location":"post/#VoronoiFVM.integrate-Union{Tuple{Ti}, Tuple{Tv}, Tuple{VoronoiFVM.AbstractSystem{Tv, Ti}, Vector{Tv}, AbstractMatrix{Tv}, AbstractMatrix{Tv}, Real}} where {Tv, Ti}","page":"Postprocessing","title":"VoronoiFVM.integrate","text":"integrate(system, tf, U, Uold, tstep)\n\n\nCalculate test function integral for transient solution.\n\n\n\n\n\n","category":"method"},{"location":"post/#VoronoiFVM.integrate-Union{Tuple{Ti}, Tuple{Tv}, Tuple{VoronoiFVM.AbstractSystem{Tv, Ti}, Vector{Tv}, AbstractMatrix{Tv}}} where {Tv, Ti}","page":"Postprocessing","title":"VoronoiFVM.integrate","text":"integrate(system, tf, U)\n\n\nCalculate test function integral for steady state solution.\n\n\n\n\n\n","category":"method"},{"location":"post/#VoronoiFVM.integrate_stdy-Union{Tuple{Ti}, Tuple{Tv}, Tuple{Tu}, Tuple{VoronoiFVM.AbstractSystem{Tv, Ti}, Vector{Tv}, AbstractMatrix{Tu}}} where {Tu, Tv, Ti}","page":"Postprocessing","title":"VoronoiFVM.integrate_stdy","text":"Steady state part of test function integral.\n\n\n\n\n\n","category":"method"},{"location":"post/#VoronoiFVM.integrate_tran-Union{Tuple{Ti}, Tuple{Tv}, Tuple{Tu}, Tuple{VoronoiFVM.AbstractSystem{Tv, Ti}, Vector{Tv}, AbstractMatrix{Tu}}} where {Tu, Tv, Ti}","page":"Postprocessing","title":"VoronoiFVM.integrate_tran","text":"integrate_tran(system, tf, U)\n\n\nCalculate transient part of test function integral.\n\n\n\n\n\n","category":"method"},{"location":"post/#VoronoiFVM.testfunction-Union{Tuple{Tv}, Tuple{TestFunctionFactory{Tv}, Any, Any}} where Tv","page":"Postprocessing","title":"VoronoiFVM.testfunction","text":"testfunction(factory::TestFunctionFactory{Tv}, bc0, bc1) -> Any\n\n\nCreate testfunction which has Dirichlet zero boundary conditions  for boundary regions in bc0 and Dirichlet one boundary conditions  for boundary regions in bc1.\n\n\n\n\n\n","category":"method"},{"location":"post/#Impedance-calculatiom","page":"Postprocessing","title":"Impedance calculatiom","text":"","category":"section"},{"location":"post/","page":"Postprocessing","title":"Postprocessing","text":"Impedance calculation can be seen as a postprocessing step after the solution of the unexcited stationary system.","category":"page"},{"location":"post/","page":"Postprocessing","title":"Postprocessing","text":"Modules = [VoronoiFVM]\nPages = [\"vfvm_impedance.jl\"]","category":"page"},{"location":"post/#VoronoiFVM.AbstractImpedanceSystem","page":"Postprocessing","title":"VoronoiFVM.AbstractImpedanceSystem","text":"abstract type AbstractImpedanceSystem{Tv<:Number}\n\nAbstract type for impedance system.\n\n\n\n\n\n","category":"type"},{"location":"post/#VoronoiFVM.ImpedanceSystem","page":"Postprocessing","title":"VoronoiFVM.ImpedanceSystem","text":"mutable struct ImpedanceSystem{Tv} <: VoronoiFVM.AbstractImpedanceSystem{Tv}\n\nConcrete type for impedance system.\n\nsysnzval::AbstractArray{Complex{Tv}, 1} where Tv\nNonzero pattern of time domain system matrix\n\ngrid::Any\nDiscretization grid\n\nstorderiv::AbstractMatrix\nDerivative of storage term\n\nmatrix::AbstractArray{Complex{Tv}, 2} where Tv\nComplex matrix of impedance system\n\nF::AbstractArray{Complex{Tv}, 2} where Tv\nRight hand side of impedance system\n\nU0::AbstractMatrix\nStationary state\n\n\n\n\n\n","category":"type"},{"location":"post/#VoronoiFVM.ImpedanceSystem-Union{Tuple{Ti}, Tuple{Tv}, Tuple{VoronoiFVM.AbstractSystem{Tv, Ti}, AbstractMatrix, Any, Any}} where {Tv, Ti}","page":"Postprocessing","title":"VoronoiFVM.ImpedanceSystem","text":"ImpedanceSystem(system, U0, excited_spec, excited_bc)\n\n\nConstruct impedance system from time domain system sys and steady state solution U0 under the assumption of a periodic perturbation of species excited_spec at  boundary excited_bc.\n\n\n\n\n\n","category":"method"},{"location":"post/#VoronoiFVM.impedance-Tuple{VoronoiFVM.ImpedanceSystem, Any, Any, Any, Any}","page":"Postprocessing","title":"VoronoiFVM.impedance","text":"impedance(impedance_system,ω, U0 ,\n          excited_spec, excited_bc, excited_bcval,\n           dmeas_stdy,\n           dmeas_tran \n           )\n    \n\nCalculate impedance.\n\nω:  frequency \nU0: steady state slution\ndmeas_stdy: Derivative of steady state part of measurement functional\ndmeas_tran  Derivative of transient part of the measurement functional\n\n\n\n\n\n","category":"method"},{"location":"post/#VoronoiFVM.measurement_derivative-Tuple{VoronoiFVM.AbstractSystem, Any, Any}","page":"Postprocessing","title":"VoronoiFVM.measurement_derivative","text":"measurement_derivative(system, measurement_functional, U0)\n\n\nCalculate the derivative of the scalar measurement functional at steady state U0\n\nUsually, this functional is  a test function integral.  Initially, we assume that its value depends on all unknowns of the system.\n\n\n\n\n\n","category":"method"},{"location":"post/#VoronoiFVM.solve!-Union{Tuple{Tv}, Tuple{AbstractArray{Complex{Tv}, 2}, VoronoiFVM.ImpedanceSystem{Tv}, Any}} where Tv","page":"Postprocessing","title":"VoronoiFVM.solve!","text":"solve!(UZ, impedance_system, ω)\n\n\nSolve the impedance system for given frequency ω.\n\n\n\n\n\n","category":"method"},{"location":"post/#VoronoiFVM.unknowns-Union{Tuple{VoronoiFVM.ImpedanceSystem{Tv}}, Tuple{Tv}} where Tv","page":"Postprocessing","title":"VoronoiFVM.unknowns","text":"Create a vector of unknowns of the impedance system\n\n\n\n\n\n","category":"method"},{"location":"examples/Example225_TestFunctions2D/#:-Terminal-flux-calculation-via-test-functions,-nD","page":"225: Terminal flux calculation via test functions, nD","title":"225: Terminal flux calculation via test functions, nD","text":"","category":"section"},{"location":"examples/Example225_TestFunctions2D/","page":"225: Terminal flux calculation via test functions, nD","title":"225: Terminal flux calculation via test functions, nD","text":"(source code)","category":"page"},{"location":"examples/Example225_TestFunctions2D/","page":"225: Terminal flux calculation via test functions, nD","title":"225: Terminal flux calculation via test functions, nD","text":"After calculating solutions based on the finite volume method, it may be interesting to obtain information about the solution besides of the graphical representation.","category":"page"},{"location":"examples/Example225_TestFunctions2D/","page":"225: Terminal flux calculation via test functions, nD","title":"225: Terminal flux calculation via test functions, nD","text":"Here, we focus on the following data:","category":"page"},{"location":"examples/Example225_TestFunctions2D/","page":"225: Terminal flux calculation via test functions, nD","title":"225: Terminal flux calculation via test functions, nD","text":"integrals of the solution\nflux through parts of the boundary","category":"page"},{"location":"examples/Example225_TestFunctions2D/","page":"225: Terminal flux calculation via test functions, nD","title":"225: Terminal flux calculation via test functions, nD","text":"Let us define the following reaction - diffusion system in a domain Omega:","category":"page"},{"location":"examples/Example225_TestFunctions2D/","page":"225: Terminal flux calculation via test functions, nD","title":"225: Terminal flux calculation via test functions, nD","text":"beginaligned\npartial_t u_1 - nabla cdot nabla u_1 + r(u_1 u_2) = f=10\npartial_t u_2 - nabla cdot nabla u_1 - r(u_1 u_2) = 0\nendaligned","category":"page"},{"location":"examples/Example225_TestFunctions2D/","page":"225: Terminal flux calculation via test functions, nD","title":"225: Terminal flux calculation via test functions, nD","text":"with boundary conditions u_2=0 on Gamma_2subsetpartialOmega and r(u_1u_2)=u_1 + 01 u_2","category":"page"},{"location":"examples/Example225_TestFunctions2D/","page":"225: Terminal flux calculation via test functions, nD","title":"225: Terminal flux calculation via test functions, nD","text":"The source f creates species u_1 which reacts to u_2, u_2 then leaves the domain at boundary Gamma_2.","category":"page"},{"location":"examples/Example225_TestFunctions2D/#Stationary-problem","page":"225: Terminal flux calculation via test functions, nD","title":"Stationary problem","text":"","category":"section"},{"location":"examples/Example225_TestFunctions2D/","page":"225: Terminal flux calculation via test functions, nD","title":"225: Terminal flux calculation via test functions, nD","text":"For the stationary problem, we have the following flux balances derived from the equations and from Gauss theorem:","category":"page"},{"location":"examples/Example225_TestFunctions2D/","page":"225: Terminal flux calculation via test functions, nD","title":"225: Terminal flux calculation via test functions, nD","text":"beginaligned\nint_Omega r(u_1u_2) domega = int_Omega f domega \nint_Omega -r(u_1u_2) domega = int_Gamma_2 nabla u cdot vec n ds \nendaligned","category":"page"},{"location":"examples/Example225_TestFunctions2D/","page":"225: Terminal flux calculation via test functions, nD","title":"225: Terminal flux calculation via test functions, nD","text":"The volume integrals can be approximated based on the finite volume subdivision Omega=cup_iin mathcal N omega_i:","category":"page"},{"location":"examples/Example225_TestFunctions2D/","page":"225: Terminal flux calculation via test functions, nD","title":"225: Terminal flux calculation via test functions, nD","text":"beginaligned\nint_Omega r(u_1u_2) domega approx sum_iin mathcal N omega_i r(u_1iu_2i)\nint_Omega f domega approx sum_iin mathcal N omega_i f_i\nendaligned","category":"page"},{"location":"examples/Example225_TestFunctions2D/","page":"225: Terminal flux calculation via test functions, nD","title":"225: Terminal flux calculation via test functions, nD","text":"But what about  the boundary integral ?  Here, we use a  trick to cast the surface  integral to the  integral to  a volume integral  with the help of a test function:","category":"page"},{"location":"examples/Example225_TestFunctions2D/","page":"225: Terminal flux calculation via test functions, nD","title":"225: Terminal flux calculation via test functions, nD","text":"Let T(x) be the solution of the Laplace problem -nabla^2 T =0 in Omega and the boundary conditions","category":"page"},{"location":"examples/Example225_TestFunctions2D/","page":"225: Terminal flux calculation via test functions, nD","title":"225: Terminal flux calculation via test functions, nD","text":"beginaligned\nT =0 quad textat Gamma_4\nT =1 quad textat Gamma_2\npartial_n T =0quad textat  Gamma_1Gamma_3\nendaligned","category":"page"},{"location":"examples/Example225_TestFunctions2D/","page":"225: Terminal flux calculation via test functions, nD","title":"225: Terminal flux calculation via test functions, nD","text":"Write vec j=-nabla u. and assume nablacdot vec j + r =f.","category":"page"},{"location":"examples/Example225_TestFunctions2D/","page":"225: Terminal flux calculation via test functions, nD","title":"225: Terminal flux calculation via test functions, nD","text":"beginaligned\nint_Gamma_2 vec j cdot vec n ds=int_Gamma_2 Tvec j cdot vec n ds quad textdue to T=1 texton Gamma_2\n =int_partialOmega  Tvec j cdot vec n dsquad textdue to T=0 texton Gamma_4 quadvec jcdot vec n=0 texton Gamma_1 Gamma_3\n= int_Omega nabla cdot (T vec j) domega quad text(Gauss)\n= int_Omega nabla T cdot vec j domega + int_Omega T nablacdot j domega\n=  int_Omega nabla T cdot vec j domega + int_Omega T(f-r)dω\nendaligned","category":"page"},{"location":"examples/Example225_TestFunctions2D/","page":"225: Terminal flux calculation via test functions, nD","title":"225: Terminal flux calculation via test functions, nD","text":"and we approximate","category":"page"},{"location":"examples/Example225_TestFunctions2D/","page":"225: Terminal flux calculation via test functions, nD","title":"225: Terminal flux calculation via test functions, nD","text":"beginaligned\nint_Omega nabla T cdot vec j domega approx sum_kl\nfracomega_kcapomega_lh_klg(u_k u_l) (T_k-T_l)\nendaligned","category":"page"},{"location":"examples/Example225_TestFunctions2D/","page":"225: Terminal flux calculation via test functions, nD","title":"225: Terminal flux calculation via test functions, nD","text":"where the sum runs over pairs of neigboring control volumes.","category":"page"},{"location":"examples/Example225_TestFunctions2D/","page":"225: Terminal flux calculation via test functions, nD","title":"225: Terminal flux calculation via test functions, nD","text":"The integrate method with a  test function parameter returns a value for each species, the sign convention assumes that species leaving the domain lead to negative values.","category":"page"},{"location":"examples/Example225_TestFunctions2D/#Transient-problem","page":"225: Terminal flux calculation via test functions, nD","title":"Transient problem","text":"","category":"section"},{"location":"examples/Example225_TestFunctions2D/","page":"225: Terminal flux calculation via test functions, nD","title":"225: Terminal flux calculation via test functions, nD","text":"The amount  of species created via  the source term (measured  in F) integrated  over time  should be  equal to  the sum  of the  amount of species left in  the domain at the  very end of the  evolution and the amount of species which left the domain:","category":"page"},{"location":"examples/Example225_TestFunctions2D/","page":"225: Terminal flux calculation via test functions, nD","title":"225: Terminal flux calculation via test functions, nD","text":"int_t_0^t_end int_Omega f domega dt= int_Omega (u_1+u_2)dω + int_t_0^t_end int_Gamma_2 nabla u_2 cdot vec n ds","category":"page"},{"location":"examples/Example225_TestFunctions2D/","page":"225: Terminal flux calculation via test functions, nD","title":"225: Terminal flux calculation via test functions, nD","text":"Literature references:","category":"page"},{"location":"examples/Example225_TestFunctions2D/","page":"225: Terminal flux calculation via test functions, nD","title":"225: Terminal flux calculation via test functions, nD","text":"H. Gajewski \"Analysis und Numerik von Ladungstransport in Halbleitern\", WIAS Berlin, Report No.6\nYoder, P. D., K. Gärtner, and W. Fichtner. \"A generalized Ramo–Shockley theorem for classical to quantum transport at arbitrary frequencies.\" Journal of Applied Physics 79.4 (1996): 1951-1954.\nP. Farrell, N. Rotundo, D. H. Doan, M. Kantner, J. Fuhrmann, and T. Koprucki, \"Numerical methods for drift-diffusion models\", in Handbook of optoelectronic device modeling and simulation: Lasers, modulators, photodetectors, solar cells, and numerical methods, vol. 2, J. Piprek, Ed. Boca Raton: CRC Press, 2017, pp. 733–771.","category":"page"},{"location":"examples/Example225_TestFunctions2D/","page":"225: Terminal flux calculation via test functions, nD","title":"225: Terminal flux calculation via test functions, nD","text":"module Example225_TestFunctions2D\n\nusing VoronoiFVM, GridVisualize,ExtendableGrids\n\nfunction main(;n=10,Plotter=nothing,verbose=false, unknown_storage=:sparse,dim=2,tend=5, dt=0.2)\n    n=[101,21,5]\n    X=collect(range(0.0,1,length=n[dim]))\n    if dim==1\n        grid=simplexgrid(X)\n        Γ_where_T_equal_1=[2]\n        Γ_where_T_equal_0=[1]\n    elseif dim==2\n        grid=simplexgrid(X,X)\n        Γ_where_T_equal_1=[2]\n        Γ_where_T_equal_0=[4]\n    elseif dim==3\n        grid=simplexgrid(X,X,X)\n        Γ_where_T_equal_1=[2]\n        Γ_where_T_equal_0=[4]\n    end\n\n    function storage(f,u,node)\n        f.=u\n    end\n\n    function flux(f,u,edge)\n\tf[1]=u[1,1]-u[1,2]\n\tf[2]=u[2,1]-u[2,2]\n    end\n\n    r(u1,u2)= u1-0.1*u2\n\n    function reaction(f,u,node)\n\tf[1]= r(u[1],u[2])\n\tf[2]=-r(u[1],u[2])\n    end\n\n\n    function source(f,node)\n\tf[1]=1.0\n    end\n\n    physics=VoronoiFVM.Physics(flux=flux,\n\t                       storage=storage,\n\t                       reaction=reaction,\n\t                       source=source)\n\n    system=VoronoiFVM.System(grid,physics)\n\n    enable_species!(system,1,[1])\n    enable_species!(system,2,[1])\n    boundary_dirichlet!(system,2,2,0.0);\n\n\n    inival=unknowns(system,inival=0.0)\n\n    sol=solve(inival,system)\n\n    vis=GridVisualizer(Plotter=Plotter,layout=(1,2),resolution=(600,300),fignumber=1)\n    scalarplot!(vis[1,1],grid,sol[1,:],flimits=(0,1.5),title=\"u_1\")\n    scalarplot!(vis[1,2],grid,sol[2,:],flimits=(0,1.5),title=\"u_2\",show=true)\n\n    \"\"\"\n        The `integrate` method of `VoronoiFVM`  provides a possibility to calculate\n        the volume integral of a function of a solution as described above.\n        It returns a `num_specie` x `num_regions` matrix of the integrals\n        of the function of the unknowns over the different subdomains (here, we have only one):\n    \"\"\"\n\n    \"\"\"\n        Amount of u_1 and u_2 in the domain aka integral over identity storage function:\n    \"\"\"\n    U=integrate(system,storage,sol)\n\n    \"\"\"\n    Amount of species created by source term per unit time:\n    \"\"\"\n    F=integrate(system,(f,u,node)->source(f,node),sol)\n\n    \"\"\"\n    Amount of  reaction per unit time:\n    \"\"\"\n    R=integrate(system,reaction,sol)\n\n\n    tf=TestFunctionFactory(system)\n    T=testfunction(tf,Γ_where_T_equal_0,Γ_where_T_equal_1)\n\n    I=integrate(system,T,sol)\n\n\n    t0=0.0\n\n    control=fixed_timesteps!(VoronoiFVM.NewtonControl(),dt)\n\n    tsol=solve(inival,system,[t0,tend],control=control)\n\n\n    vis1=GridVisualizer(Plotter=Plotter,layout=(1,2),resolution=(600,300),fignumber=4)\n\n    for i=1:length(tsol)\n        sol=tsol[i]\n        scalarplot!(vis1[1,1],grid,sol[1,:],flimits=(0,1.5),clear=true)\n        scalarplot!(vis1[1,2],grid,sol[2,:],flimits=(0,1.5),show=true)\n    end\n\n    outflow_rate=Float64[]\n    for i=2:length(tsol)\n\tofr=integrate(system,T,tsol[i],tsol[i-1],tsol.t[i]-tsol.t[i-1])\n  \tpush!(outflow_rate,ofr[2])\n    end\n\n    vis2=GridVisualizer(Plotter=Plotter,layout=(1,1),resolution=(600,300),fignumber=2)\n    scalarplot!(vis2[1,1],[0,tend],-[I[2],I[2]],label=\"stationary\",clear=true)\n    scalarplot!(vis2[1,1],tsol.t[2:end],-outflow_rate,label=\"transient\",show=true)\n\n    all_outflow=0.0\n    for i=1:length(tsol)-1\n\tall_outflow-=outflow_rate[i]*(tsol.t[i+1]-tsol.t[i])\n    end\n\n    Uend=integrate(system,storage,tsol[end])\n    isapprox(F[1], R[1],rtol=1.0e-12)  ? true : return false\n    isapprox(I[1], 0.0, atol=1.0e-12)  ? true : return false\n    isapprox(R[2], I[2],rtol=1.0e-12)  ? true : return false\n    isapprox(F[1]*(tend-t0), ( Uend[1] + Uend[2] + all_outflow), rtol=1.0e-12) ? true : return false\nend\n\n\nfunction test()\n    main(dim=1, unknown_storage=:sparse )  ? true : return false\n    main(dim=1, unknown_storage=:dense  )  ? true : return false\n    main(dim=2, unknown_storage=:sparse )  ? true : return false\n    main(dim=2, unknown_storage=:dense  )  ? true : return false\n    main(dim=3, unknown_storage=:sparse )  ? true : return false\n    main(dim=3, unknown_storage=:dense  )  ? true : return false\nend\n\nend","category":"page"},{"location":"examples/Example225_TestFunctions2D/","page":"225: Terminal flux calculation via test functions, nD","title":"225: Terminal flux calculation via test functions, nD","text":"","category":"page"},{"location":"examples/Example225_TestFunctions2D/","page":"225: Terminal flux calculation via test functions, nD","title":"225: Terminal flux calculation via test functions, nD","text":"This page was generated using Literate.jl.","category":"page"},{"location":"allindex/#Index","page":"Index","title":"Index","text":"","category":"section"},{"location":"allindex/#Types-and-Constructors","page":"Index","title":"Types and Constructors","text":"","category":"section"},{"location":"allindex/","page":"Index","title":"Index","text":"Modules = [VoronoiFVM]\nOrder=[:type]","category":"page"},{"location":"allindex/#Constants","page":"Index","title":"Constants","text":"","category":"section"},{"location":"allindex/","page":"Index","title":"Index","text":"Modules = [VoronoiFVM]\nOrder=[:constant]","category":"page"},{"location":"allindex/#Methods","page":"Index","title":"Methods","text":"","category":"section"},{"location":"allindex/","page":"Index","title":"Index","text":"Modules = [VoronoiFVM]\nOrder=[:function]","category":"page"},{"location":"examples/Example226_BoundaryIntegral/#:-Terminal-flux-calculation-via-test-functions,-nD,-boundary-reaction","page":"226: Terminal flux calculation via test functions, nD, boundary reaction","title":"226: Terminal flux calculation via test functions, nD, boundary reaction","text":"","category":"section"},{"location":"examples/Example226_BoundaryIntegral/","page":"226: Terminal flux calculation via test functions, nD, boundary reaction","title":"226: Terminal flux calculation via test functions, nD, boundary reaction","text":"(source code)","category":"page"},{"location":"examples/Example226_BoundaryIntegral/","page":"226: Terminal flux calculation via test functions, nD, boundary reaction","title":"226: Terminal flux calculation via test functions, nD, boundary reaction","text":"module Example226_BoundaryIntegral\n\nusing VoronoiFVM, GridVisualize,ExtendableGrids\n\nfunction main(;n=10,Plotter=nothing,verbose=false, unknown_storage=:sparse,dim=2)\n    n=[101,21,5]\n    X=collect(range(0.0,1,length=n[dim]))\n    if dim==1\n        grid=simplexgrid(X)\n        Γ_where_T_equal_1=[2]\n        Γ_where_T_equal_0=[1]\n    elseif dim==2\n        grid=simplexgrid(X,X)\n        Γ_where_T_equal_1=[2]\n        Γ_where_T_equal_0=[4]\n    elseif dim==3\n        grid=simplexgrid(X,X,X)\n        Γ_where_T_equal_1=[2]\n        Γ_where_T_equal_0=[4]\n    end\n\n    function storage(f,u,node)\n        f.=u\n    end\n\n    function flux(f,u,edge)\n\tf[1]=u[1,1]-u[1,2]\n    end\n\n\n    function breaction(f,u,node)\n        if node.region==Γ_where_T_equal_1[1]\n            f[1]= u[1]^2\n        end\n    end\n\n    physics=VoronoiFVM.Physics(flux=flux,\n\t                       storage=storage,\n\t                       breaction=breaction)\n\n    system=VoronoiFVM.System(grid,physics)\n    enable_species!(system,1,[1])\n    boundary_dirichlet!(system,1,Γ_where_T_equal_0[1],1.0);\n    inival=unknowns(system,inival=0.0)\n\n    U=solve(inival,system)\n\n    tf=TestFunctionFactory(system)\n    T=testfunction(tf,Γ_where_T_equal_0,Γ_where_T_equal_1)\n\n    scalarplot(grid,U[1,:],Plotter=Plotter,zplane=0.50001)\n    I=integrate(system,T,U)\n    B=integrate(system,breaction,U; boundary=true)\n    isapprox(-I[1], B[Γ_where_T_equal_1[1]],rtol=1.0e-12)\nend\n\n\nfunction test()\n    main(dim=1, unknown_storage=:sparse )  ? true : return false\n    main(dim=1, unknown_storage=:dense  )  ? true : return false\n    main(dim=2, unknown_storage=:sparse )  ? true : return false\n    main(dim=2, unknown_storage=:dense  )  ? true : return false\n    main(dim=3, unknown_storage=:sparse )  ? true : return false\n    main(dim=3, unknown_storage=:dense  )  ? true : return false\nend\n\nend","category":"page"},{"location":"examples/Example226_BoundaryIntegral/","page":"226: Terminal flux calculation via test functions, nD, boundary reaction","title":"226: Terminal flux calculation via test functions, nD, boundary reaction","text":"","category":"page"},{"location":"examples/Example226_BoundaryIntegral/","page":"226: Terminal flux calculation via test functions, nD, boundary reaction","title":"226: Terminal flux calculation via test functions, nD, boundary reaction","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/Example151_Impedance1D/#:-Impedance-calculation","page":"151: Impedance calculation","title":"151: Impedance calculation","text":"","category":"section"},{"location":"examples/Example151_Impedance1D/","page":"151: Impedance calculation","title":"151: Impedance calculation","text":"(source code)","category":"page"},{"location":"examples/Example151_Impedance1D/","page":"151: Impedance calculation","title":"151: Impedance calculation","text":"Same as Example150, but with new and more generic way of  passing the parameter.","category":"page"},{"location":"examples/Example151_Impedance1D/","page":"151: Impedance calculation","title":"151: Impedance calculation","text":"Impedance calculation for","category":"page"},{"location":"examples/Example151_Impedance1D/","page":"151: Impedance calculation","title":"151: Impedance calculation","text":"C ut - (D ux)_x + Ru = 0   in (0,1)      u(0,t)=1 + exp(iωt)      u(1,t)=0","category":"page"},{"location":"examples/Example151_Impedance1D/","page":"151: Impedance calculation","title":"151: Impedance calculation","text":"Measurement: I(t)= D u_x(1,t)","category":"page"},{"location":"examples/Example151_Impedance1D/","page":"151: Impedance calculation","title":"151: Impedance calculation","text":"Steady state:","category":"page"},{"location":"examples/Example151_Impedance1D/","page":"151: Impedance calculation","title":"151: Impedance calculation","text":"(D u0x)x + Ru0 = 0","category":"page"},{"location":"examples/Example151_Impedance1D/","page":"151: Impedance calculation","title":"151: Impedance calculation","text":"u0(0,t)=1    u0(1,t)=0","category":"page"},{"location":"examples/Example151_Impedance1D/","page":"151: Impedance calculation","title":"151: Impedance calculation","text":"Small signal ansatz for ω","category":"page"},{"location":"examples/Example151_Impedance1D/","page":"151: Impedance calculation","title":"151: Impedance calculation","text":"u(x,t)= u0(x)+ ua(x) exp(iωt)","category":"page"},{"location":"examples/Example151_Impedance1D/","page":"151: Impedance calculation","title":"151: Impedance calculation","text":"iωC ua - (D uax)x + R u_a =0      ua(0)=1      ua(1)=0","category":"page"},{"location":"examples/Example151_Impedance1D/","page":"151: Impedance calculation","title":"151: Impedance calculation","text":"module Example151_Impedance1D\n\nusing Printf\nusing VoronoiFVM\nusing ExtendableGrids\nusing GridVisualize\n\nfunction main(;nref=0,Plotter=nothing,verbose=false, unknown_storage=:sparse,\n              L=1.0, R=1.0, D=1.0, C=1.0,\n              ω0=1.0e-3,ω1=5.0e1)","category":"page"},{"location":"examples/Example151_Impedance1D/","page":"151: Impedance calculation","title":"151: Impedance calculation","text":"Create array which is refined close to 0","category":"page"},{"location":"examples/Example151_Impedance1D/","page":"151: Impedance calculation","title":"151: Impedance calculation","text":"    h0=0.005/2.0^nref\n    h1=0.1/2.0^nref\n\n    X=VoronoiFVM.geomspace(0,L,h0,h1)","category":"page"},{"location":"examples/Example151_Impedance1D/","page":"151: Impedance calculation","title":"151: Impedance calculation","text":"Create discretitzation grid","category":"page"},{"location":"examples/Example151_Impedance1D/","page":"151: Impedance calculation","title":"151: Impedance calculation","text":"    grid=VoronoiFVM.Grid(X)","category":"page"},{"location":"examples/Example151_Impedance1D/","page":"151: Impedance calculation","title":"151: Impedance calculation","text":"Create and fill data","category":"page"},{"location":"examples/Example151_Impedance1D/","page":"151: Impedance calculation","title":"151: Impedance calculation","text":"    data = (R=R, D=D, C=C)","category":"page"},{"location":"examples/Example151_Impedance1D/","page":"151: Impedance calculation","title":"151: Impedance calculation","text":"Declare constitutive functions","category":"page"},{"location":"examples/Example151_Impedance1D/","page":"151: Impedance calculation","title":"151: Impedance calculation","text":"    flux=function(f,u,edge,data)\n        f[1]=data.D*(u[1,1]-u[1,2])\n    end\n\n    storage=function(f,u,node,data)\n        f[1]=data.C*u[1]\n    end\n\n    reaction=function(f,u,node,data)\n        f[1]=data.R*u[1]\n    end\n\n\n    excited_bc=1\n    excited_bcval=1.0\n    excited_spec=1\n    meas_bc=2\n\n    bc=function(f,u,node,data)\n        p=parameters(u)\n        boundary_dirichlet!(f,u,node,region=excited_bc,value=p[1])\n        boundary_dirichlet!(f,u,node,region=meas_bc,value=0.0)\n    end","category":"page"},{"location":"examples/Example151_Impedance1D/","page":"151: Impedance calculation","title":"151: Impedance calculation","text":"Create discrete system and enabe species","category":"page"},{"location":"examples/Example151_Impedance1D/","page":"151: Impedance calculation","title":"151: Impedance calculation","text":"    sys=VoronoiFVM.System(grid,unknown_storage=unknown_storage,\n                          data=data,\n                          flux=flux,\n                          storage=storage,\n                          reaction=reaction,\n                          bcondition=bc,\n                          nparams=1,\n                          species=1\n                          )","category":"page"},{"location":"examples/Example151_Impedance1D/","page":"151: Impedance calculation","title":"151: Impedance calculation","text":"Create test functions for current measurement","category":"page"},{"location":"examples/Example151_Impedance1D/","page":"151: Impedance calculation","title":"151: Impedance calculation","text":"    factory=TestFunctionFactory(sys)\n    measurement_testfunction=testfunction(factory,[excited_bc],[meas_bc])\n\n    steadystate=solve(sys,inival=0.0,params=[1.0])\n\n    function meas_stdy(meas,U)\n        u=reshape(U,sys)\n        meas[1]=-VoronoiFVM.integrate_stdy(sys,measurement_testfunction,u)[excited_spec]\n        nothing\n    end\n\n    function meas_tran(meas,U)\n        u=reshape(U,sys)\n        meas[1]=-VoronoiFVM.integrate_tran(sys,measurement_testfunction,u)[excited_spec]\n        nothing\n    end\n\n\n    dmeas_stdy=measurement_derivative(sys,meas_stdy,steadystate)\n    dmeas_tran=measurement_derivative(sys,meas_tran,steadystate)","category":"page"},{"location":"examples/Example151_Impedance1D/","page":"151: Impedance calculation","title":"151: Impedance calculation","text":"Create Impeadancs system from steady state","category":"page"},{"location":"examples/Example151_Impedance1D/","page":"151: Impedance calculation","title":"151: Impedance calculation","text":"    isys=VoronoiFVM.ImpedanceSystem(sys,steadystate)","category":"page"},{"location":"examples/Example151_Impedance1D/","page":"151: Impedance calculation","title":"151: Impedance calculation","text":"Prepare recording of impedance results","category":"page"},{"location":"examples/Example151_Impedance1D/","page":"151: Impedance calculation","title":"151: Impedance calculation","text":"    allomega=zeros(0)","category":"page"},{"location":"examples/Example151_Impedance1D/","page":"151: Impedance calculation","title":"151: Impedance calculation","text":"for calculated data","category":"page"},{"location":"examples/Example151_Impedance1D/","page":"151: Impedance calculation","title":"151: Impedance calculation","text":"    allI0=zeros(Complex{Float64},0)\n    allIL=zeros(Complex{Float64},0)","category":"page"},{"location":"examples/Example151_Impedance1D/","page":"151: Impedance calculation","title":"151: Impedance calculation","text":"for exact data","category":"page"},{"location":"examples/Example151_Impedance1D/","page":"151: Impedance calculation","title":"151: Impedance calculation","text":"    allIx0=zeros(Complex{Float64},0)\n    allIxL=zeros(Complex{Float64},0)\n\n    ω=ω0\n\n    UZ=unknowns(isys)\n    while ω<ω1","category":"page"},{"location":"examples/Example151_Impedance1D/","page":"151: Impedance calculation","title":"151: Impedance calculation","text":"solve impedance system","category":"page"},{"location":"examples/Example151_Impedance1D/","page":"151: Impedance calculation","title":"151: Impedance calculation","text":"        solve!(UZ,isys,ω)","category":"page"},{"location":"examples/Example151_Impedance1D/","page":"151: Impedance calculation","title":"151: Impedance calculation","text":"calculate aproximate solution obtain measurement in frequency  domain","category":"page"},{"location":"examples/Example151_Impedance1D/","page":"151: Impedance calculation","title":"151: Impedance calculation","text":"        IL=impedance(isys,ω,steadystate, dmeas_stdy, dmeas_tran)","category":"page"},{"location":"examples/Example151_Impedance1D/","page":"151: Impedance calculation","title":"151: Impedance calculation","text":"record approximate solution","category":"page"},{"location":"examples/Example151_Impedance1D/","page":"151: Impedance calculation","title":"151: Impedance calculation","text":"        push!(allomega, ω)\n        push!(allIL,IL)","category":"page"},{"location":"examples/Example151_Impedance1D/","page":"151: Impedance calculation","title":"151: Impedance calculation","text":"record exact solution","category":"page"},{"location":"examples/Example151_Impedance1D/","page":"151: Impedance calculation","title":"151: Impedance calculation","text":"        iω=1im*ω\n        z=sqrt(iω*data.C/data.D+data.R/data.D)\n        eplus=exp(z*L)\n        eminus=exp(-z*L)\n        IxL=2.0*data.D*z/(eplus-eminus)\n\n        push!(allIxL,1/IxL)","category":"page"},{"location":"examples/Example151_Impedance1D/","page":"151: Impedance calculation","title":"151: Impedance calculation","text":"increase omega","category":"page"},{"location":"examples/Example151_Impedance1D/","page":"151: Impedance calculation","title":"151: Impedance calculation","text":"        ω=ω*1.1\n\n    end\n\n    p=GridVisualizer(Plotter=Plotter)\n    scalarplot!(p,real(allIxL),imag(allIxL),label=\"exact\",color=:red,linestyle=:dot)\n    scalarplot!(p,real(allIL),imag(allIL),label=\"calc\",show=true,clear=false,color=:blue,linestyle=:solid)\n\n    sum(allIL)\nend\n\n\nfunction test()\n    tval=57.92710286186797 + 23.163945443946027im\n    main(unknown_storage=:dense) ≈ tval  &&  main(unknown_storage=:sparse) ≈ tval\nend\n\n\nend","category":"page"},{"location":"examples/Example151_Impedance1D/","page":"151: Impedance calculation","title":"151: Impedance calculation","text":"","category":"page"},{"location":"examples/Example151_Impedance1D/","page":"151: Impedance calculation","title":"151: Impedance calculation","text":"This page was generated using Literate.jl.","category":"page"},{"location":"solver/#Solution-methods","page":"Solution methods","title":"Solution methods","text":"","category":"section"},{"location":"solver/#Built-in-solver","page":"Solution methods","title":"Built-in solver","text":"","category":"section"},{"location":"solver/","page":"Solution methods","title":"Solution methods","text":"The package comes with a built-in solve method which solves  stationary problems, simple homotopy embedding problems and transient problems  via the implicit Euler method.  This solver and its default parameters are tuned for robustness, possibly at the expense of solution speed. Careful tuning of the parameters, or – in the case of transient problems – the choice of the DifferentialEquations.jl solver can significantly improve the performance.","category":"page"},{"location":"solver/","page":"Solution methods","title":"Solution methods","text":"VoronoiFVM.solve(system::VoronoiFVM.AbstractSystem; kwargs...)","category":"page"},{"location":"solver/#VoronoiFVM.solve-Tuple{VoronoiFVM.AbstractSystem}","page":"Solution methods","title":"VoronoiFVM.solve","text":"VoronoiFVM.solve(system; kwargs...)\n\nBuilt-in solution method for VoronoiFVM.System.\n\nKeyword arguments:\n\nGeneral for all solvers \ninival (default: 0) : Array created via unknowns or  number giving the initial value.\nAll elements of SolverControl can be used as kwargs except in the case of the DifferentialEquations based solver\ndamp (default: 1): alias for damp_initial\ndamp_grow (default: 1): alias for damp_growth\nabstol: alias for tol_absolute\nreltol: alias for tol_relative\ncontrol (default: nothing): Pass instance of SolverControl\nparams: Parameters (Parameter handling is experimental and may change)\nStationary solver: Invoked if neither times nor embed, nor tstep are given as keyword argument.\ntime (default: 0): Set time value. \nReturns a DenseSolutionArray or SparseSolutionArray\nEmbedding (homotopy) solver: Invoked if embed kwarg is given. Use homotopy embedding + damped Newton's method  to  solve stationary problem or to solve series of parameter dependent problems. Parameter step control is performed according to solver control data.  kwargs and default values are:\nembed (default: nothing ): vector of parameter values to be reached exactly\nIn addition,  all kwargs of the implicit Euler solver (besides times) are handled.   Returns a transient solution object sol containing the stored solution(s),  see TransientSolution.\nImplicit Euler transient solver: Invoked if times kwarg is given. Use implicit Euler method  + damped   Newton's method  to  solve time dependent problem. Time step control is performed according to solver control data.  kwargs and default values are:\ntimes (default: nothing ): vector of time values to be reached exactly\npre (default: (sol,t)->nothing ):  invoked before each time step\npost  (default:  (sol,oldsol, t, Δt)->nothing ):  invoked after each time step\nsample (default:  (sol,t)->nothing ): invoked after timestep for all times in times[2:end].\ndelta (default:  (u,v,t, Δt)->norm(sys,u-v,Inf) ):  Value  used to control the time step size Δu\nIf control.handle_error is true, if step solution  throws an error, stepsize  is lowered, and  step solution is called again with a smaller time value. If control.Δt<control.Δt_min, solution is aborted with error. Returns a transient solution object sol containing the stored solution,  see TransientSolution.\nImplicit Euler timestep solver.  Invoked if tstep kwarg is given. Solve one time step of the implicit Euler method.\ntime (default: 0): Set time value. \ntstep: time step\nReturns a DenseSolutionArray or SparseSolutionArray\n\n\n\n\n\n","category":"method"},{"location":"solver/#diffeq","page":"Solution methods","title":"DifferentialEquations.jl solver","text":"","category":"section"},{"location":"solver/","page":"Solution methods","title":"Solution methods","text":"For transient problems, as an alternative to the use of the built-in implicit Euler method, (stiff) ODE solvers from  DifferentialEquations.jl  can be used.","category":"page"},{"location":"solver/","page":"Solution methods","title":"Solution methods","text":"The dependency of the code on  DifferentialEquations.jl is optional. It is handeled via Requires.jl. This means that it becomes available as as soon as DifferentialEquations.jl is made available via Pkg.add() and used in the code.","category":"page"},{"location":"solver/","page":"Solution methods","title":"Solution methods","text":"The interface just provides two methods: creation of an ODEProblem from a VoronoiFVM.System and a reshape method which turns the output of the ode solver into a TransientSolution.","category":"page"},{"location":"solver/","page":"Solution methods","title":"Solution methods","text":"The basic usage pattern is as follows: replace the call to the built-in solver","category":"page"},{"location":"solver/","page":"Solution methods","title":"Solution methods","text":"sol=VoronoiFVM.solve(sys; times=(t0,t1), inival=inival)","category":"page"},{"location":"solver/","page":"Solution methods","title":"Solution methods","text":"by","category":"page"},{"location":"solver/","page":"Solution methods","title":"Solution methods","text":"problem = ODEProblem(sys,inival,(t0,tend))\nodesol = DifferentialEquations.solve(problem)\nsol=reshape(odesol,sys)","category":"page"},{"location":"solver/","page":"Solution methods","title":"Solution methods","text":"DifferentialEquations.ODEProblem(::VoronoiFVM.AbstractSystem, inival, tspan, callback)\nBase.reshape(::DifferentialEquations.AbstractDiffEqArray,::VoronoiFVM.AbstractSystem)","category":"page"},{"location":"solver/#SciMLBase.ODEProblem-Tuple{VoronoiFVM.AbstractSystem, Any, Any, Any}","page":"Solution methods","title":"SciMLBase.ODEProblem","text":"ODEProblem(system,inival,tspan,callback=DifferentialEquations.CallbackSet())\n\nCreate an ODEProblem which can  be handeled by ODE solvers from DifferentialEquations.jl.\n\nParameters:\n\nsystem: A VoronoiFVM.System\ninival: Initial value. Consider to  pass a stationary solution at tspan[1].\ntspan: Time interval \ncallback : (optional) callback for ODE solver \n\nThe method returns an ODEProblem which can be solved by DifferentialEquations.solve().\n\n\n\n\n\n","category":"method"},{"location":"solver/#Base.reshape-Tuple{AbstractDiffEqArray, VoronoiFVM.AbstractSystem}","page":"Solution methods","title":"Base.reshape","text":"reshape(ode_solution, system)\n\nCreate a TransientSolution from the output of the ode solver.\n\n\n\n\n\n","category":"method"},{"location":"solver/#Built-in-solver-control","page":"Solution methods","title":"Built-in solver control","text":"","category":"section"},{"location":"solver/","page":"Solution methods","title":"Solution methods","text":"SolverControl\nNewtonControl","category":"page"},{"location":"solver/#VoronoiFVM.SolverControl","page":"Solution methods","title":"VoronoiFVM.SolverControl","text":"mutable struct SolverControl\n\nSolver control parameters for time stepping, embedding, Newton method control. All field names can be used as keyword arguments for solve(system::VoronoiFVM.AbstractSystem; kwargs...)\n\nNewton's method solves F(u)=0 by the iterative procedure u_i+1=u_i - d_i F(u_i)^-1F(u_i) starting with some inital value u_0, where d_i is a damping parameter.\n\ntol_absolute::Float64\nTolerance (in terms of norm of Newton update): terminate if Delta u_i=u_i+1-u_i_infty  tol_absolute.  Default: 1.0e-10\ntol_relative::Float64\nTolerance (relative to the size of the first update): terminate if Delta u_iDelta u_1 tol_relative.  Default: 1.0e-10\ntol_round::Float64\nTolerance for roundoff error detection: terminate if   u_i+1_1 - u_i_1 u_i_1 tol_round occured max_round times in a row.  Default: 1.0e-10\ntol_mono::Float64\nTolerance for monotonicity test: terminate with error if Delta u_iDelta u_i-1 1/tol_mono.  Default: 0.001\ndamp_initial::Float64\nInitial damping parameter d_0. To handle convergence problems, set this to a value less than 1.  Default: 1.0\ndamp_growth::Float64\nDamping parameter growth factor: d_i+1=min(d_icdot max_growth 1). It should be larger than 1.  Default: 1.2\nmax_iterations::Int32\nMaximum number of iterations.  Default: 100\nmax_lureuse::Int32\nMaximum number of reuses of lu factorization. It this value is 0, linear systems are solved by a sparse direct solver, and it's LU factorization is called in every Newton step. Otherwise, a BICGstab iterative method is used for linear system solution with a LU factorization as preconditioner which is updated only every max_lureuse Newton step.  Default: 0\nmax_round::Int32\nMaximum number of consecutive iterations within roundoff error tolerance The default effectively disables this criterion.  Default: 1000\ntol_linear::Float64\nTolerance of iterative linear solver.  Default: 0.0001\nfactorization::ExtendableSparse.AbstractFactorization\nFactorization kind for linear sytems (see ExtendableSparse.jl). Default: Standard Julia LU Factorization (UMFPACK).  Default: LUFactorization()\niteration::Symbol\nIterative solver if factorization is incomplete. Currently supported: :bicgstab, :cg  Default: :bicgstab\nverbose::Bool\nVerbosity flag.  Default: false\nhandle_exceptions::Bool\nHandle exceptions during transient solver and parameter embedding. If true, exceptions in Newton solves are catched, the embedding resp. time step is lowered, and solution is retried.  Default: false\nΔp::Float64\nInitial parameter step for embedding.  Default: 1.0\nΔp_max::Float64\nMaximal parameter step size.  Default: 1.0\nΔp_min::Float64\nMinimal parameter step size.  Default: 0.001\nΔp_grow::Float64\nMaximal parameter step size growth.  Default: 1.0\nΔt::Float64\nInitial time step  size.  Default: 0.1\nΔt_max::Float64\nMaximal time step size.  Default: 1.0\nΔt_min::Float64\nMinimal time step size.  Default: 0.001\nΔt_grow::Float64\nMaximal time step size growth.  Default: 1.2\nΔu_opt::Float64\nOptimal size of update for time stepping and embeding. The algorithm tries to keep the difference in norm between \"old\" and \"new\" solutions  approximately at this value.  Default: 0.1\nforce_first_step::Bool\nForce first timestep.  Default: false\nedge_cutoff::Float64\nEdge parameter cutoff for rectangular triangles.  Default: 0.0\numfpack_pivot_tolerance::Float64\nPivot tolerance for umfpack.  Default: defaultumfpackpivot_tolerance\nstore_all::Bool\nStore all steps of transient/embedding problem:  Default: true\nin_memory::Bool\nStore transient/embedding solution in memory  Default: true\nlog::Any\nRecord history  Default: false\n\n\n\n\n\n","category":"type"},{"location":"solver/#VoronoiFVM.NewtonControl","page":"Solution methods","title":"VoronoiFVM.NewtonControl","text":"NewtonControl\n\nLegacy name of SolverControl\n\n\n\n\n\n","category":"type"},{"location":"solver/#Built-in-solver-history-handling","page":"Solution methods","title":"Built-in solver history handling","text":"","category":"section"},{"location":"solver/","page":"Solution methods","title":"Solution methods","text":"If log is set to true in solve, the history of newton iterations and  time/embedding steps is recorded and. For the respective previous solution step it can be obtained via history(system).","category":"page"},{"location":"solver/","page":"Solution methods","title":"Solution methods","text":"NewtonSolverHistory\nTransientSolverHistory\nBase.summary(::NewtonSolverHistory)\nBase.summary(::TransientSolverHistory)\ndetails\nhistory\nhistory_details\nhistory_summary","category":"page"},{"location":"solver/#VoronoiFVM.NewtonSolverHistory","page":"Solution methods","title":"VoronoiFVM.NewtonSolverHistory","text":"mutable struct NewtonSolverHistory <: AbstractVector{Float64}\n\nHistory information for one Newton solve of a nonlinear system. As an abstract vector it provides the history of the update norms. See summary and details for other ways to extract information.\n\nnlu::Int64\nnumber of Jacobi matrix factorizations  Default: 0\nnlin::Int64\nnumber of linear interation steps / factorization solves Default: 0\ntime::Float64\nElapsed time for solution  Default: 0.0\nupdatenorm::Any\nHistory of norms of u_i+1-u_i Default: zeros(0)\nl1normdiff::Any\nHistory of norms of u_i+1_1 - u_i_1 u_i_1  Default: zeros(0)\n\n\n\n\n\n","category":"type"},{"location":"solver/#VoronoiFVM.TransientSolverHistory","page":"Solution methods","title":"VoronoiFVM.TransientSolverHistory","text":"mutable struct TransientSolverHistory <: AbstractVector{NewtonSolverHistory}\n\nHistory information for transient solution/parameter embedding\n\nAs an abstract vector it provides the histories of each implicit Euler/embedding step. See summary and details for other ways to extract information.\n\nhistories::Any\nHistories of each implicit Euler Newton iteration  Default: Vector{NewtonSolverHistory}(undef, 0)\ntimes::Any\nTime values  Default: zeros(0)\nupdates::Any\nUpdate norms used for step control Default: zeros(0)\n\n\n\n\n\n","category":"type"},{"location":"solver/#Base.summary-Tuple{NewtonSolverHistory}","page":"Solution methods","title":"Base.summary","text":"summary(h::NewtonSolverHistory)\n\nReturn named tuple summarizing history.\n\n\n\n\n\n","category":"method"},{"location":"solver/#Base.summary-Tuple{TransientSolverHistory}","page":"Solution methods","title":"Base.summary","text":"summary(h::TransientSolverHistory)\n\nReturn named tuple summarizing history.\n\n\n\n\n\n","category":"method"},{"location":"solver/#VoronoiFVM.details","page":"Solution methods","title":"VoronoiFVM.details","text":"details(h::NewtonSolverHistory)\n\nReturn array of named tuples  with info on each iteration step\n\n\n\n\n\ndetails(h::TransientSolverHistory)\n\nReturn array of details of each solver step\n\n\n\n\n\n","category":"function"},{"location":"solver/#VoronoiFVM.history","page":"Solution methods","title":"VoronoiFVM.history","text":"history(sys)\n\nReturn solver history from last solve call, if log was set to true. See  see NewtonSolverHistory, TransientSolverHistory.\n\n\n\n\n\n","category":"function"},{"location":"solver/#VoronoiFVM.history_details","page":"Solution methods","title":"VoronoiFVM.history_details","text":"history_details(sys)\n\nReturn details of solver history from last solve call, if log was set to true. See details.\n\n\n\n\n\n","category":"function"},{"location":"solver/#VoronoiFVM.history_summary","page":"Solution methods","title":"VoronoiFVM.history_summary","text":"history_summary(sys)\n\nReturn summary of solver history from last solve call, if log was set to true.\n\n\n\n\n\n","category":"function"},{"location":"solver/#Matrix-extraction","page":"Solution methods","title":"Matrix extraction","text":"","category":"section"},{"location":"solver/","page":"Solution methods","title":"Solution methods","text":"For testing and teaching purposes, one can obtain residual and linearization at a given vector of unknowns","category":"page"},{"location":"solver/","page":"Solution methods","title":"Solution methods","text":"evaluate_residual_and_jacobian","category":"page"},{"location":"solver/#VoronoiFVM.evaluate_residual_and_jacobian","page":"Solution methods","title":"VoronoiFVM.evaluate_residual_and_jacobian","text":"evaluate_residual_and_jacobian(system,u;\n                               t=0.0, tstep=Inf,embed=0.0)\n\nEvaluate residual and jacobian at solution value u. Returns a solution vector containing the residual, and an ExendableSparseMatrix containing the linearization at u.\n\n\n\n\n\n","category":"function"},{"location":"solver/#Legacy-API","page":"Solution methods","title":"Legacy API","text":"","category":"section"},{"location":"solver/","page":"Solution methods","title":"Solution methods","text":"During the development of the code, a number of API variants have been developed which are supported for backward compatibility.","category":"page"},{"location":"solver/","page":"Solution methods","title":"Solution methods","text":"VoronoiFVM.solve(inival, system::VoronoiFVM.AbstractSystem, times; kwargs...)\nVoronoiFVM.solve(inival, system::VoronoiFVM.AbstractSystem; kwargs...)\nVoronoiFVM.solve!(solution,inival, system::VoronoiFVM.AbstractSystem; kwargs...)","category":"page"},{"location":"solver/#VoronoiFVM.solve-Tuple{Any, VoronoiFVM.AbstractSystem, Any}","page":"Solution methods","title":"VoronoiFVM.solve","text":"    solve(inival, system, times; kwargs...)\n\nAlias for solve(system::VoronoiFVM.AbstractSystem; kwargs...) with the corresponding keyword arguments.\n\n\n\n\n\n","category":"method"},{"location":"solver/#VoronoiFVM.solve-Tuple{Any, VoronoiFVM.AbstractSystem}","page":"Solution methods","title":"VoronoiFVM.solve","text":"solve(inival, system; control=NewtonControl(),params, tstep=Inf)\n\nAlias for solve(system::VoronoiFVM.AbstractSystem; kwargs...) with the corresponding keyword arguments.\n\nSolve stationary problem(if tstep==Inf) or one step implicit Euler step using Newton's method with inival as initial value. Returns a solution array.\n\n\n\n\n\n","category":"method"},{"location":"solver/#VoronoiFVM.solve!-Tuple{Any, Any, VoronoiFVM.AbstractSystem}","page":"Solution methods","title":"VoronoiFVM.solve!","text":"solve!(solution, inival, system; \n    control=NewtonControl(), \n    tstep=Inf)\n\nMutating version of solve(inival,system)\n\n\n\n\n\n","category":"method"},{"location":"quantities/#Quantities","page":"Quantities","title":"Quantities","text":"","category":"section"},{"location":"quantities/","page":"Quantities","title":"Quantities","text":"The concept of quantities is implemented on top of the concept of species numbers. They have been introduces in order to be able to handle discontinuities at interfaces.","category":"page"},{"location":"quantities/","page":"Quantities","title":"Quantities","text":"Modules = [VoronoiFVM]\nPages = [\"vfvm_quantities.jl\"]\nOrder = [:type, :constant, :function]","category":"page"},{"location":"quantities/#VoronoiFVM.AbstractQuantity","page":"Quantities","title":"VoronoiFVM.AbstractQuantity","text":"abstract type AbstractQuantity{Ti<:Integer}\n\nAbstract supertype of quantities\n\n\n\n\n\n","category":"type"},{"location":"quantities/#VoronoiFVM.ContinuousQuantity","page":"Quantities","title":"VoronoiFVM.ContinuousQuantity","text":"struct ContinuousQuantity{Ti} <: VoronoiFVM.AbstractQuantity{Ti}\n\nA continuous quantity is represented by exactly one species number\n\nispec::Any\nSpecies number representing the quantity\n\nid::Any\nQuantity identifier allowing to use the quantity as index in parameter fields\n\n\n\n\n\n","category":"type"},{"location":"quantities/#VoronoiFVM.ContinuousQuantity-Union{Tuple{Tm}, Tuple{Ti}, Tuple{Tv}, Tuple{VoronoiFVM.AbstractSystem{Tv, Ti, Tm}, Any}} where {Tv, Ti, Tm}","page":"Quantities","title":"VoronoiFVM.ContinuousQuantity","text":" ContinuousQuantity(system,regions; ispec=0, id=0)\n\nAdd continuous quantity to the regions listed in regions.\n\nUnless specified in ispec, the species number is generated automtically.\n\nUnless specified by id, the quantity ID is generated automatically.\n\n\n\n\n\n","category":"method"},{"location":"quantities/#VoronoiFVM.DiscontinuousQuantity","page":"Quantities","title":"VoronoiFVM.DiscontinuousQuantity","text":"struct DiscontinuousQuantity{Ti} <: VoronoiFVM.AbstractQuantity{Ti}\n\nA discontinuous quantity is represented by different species in neigboring regions.\n\nregionspec::Vector\nSpecies numbers representing the quantity in each region\n\nid::Any\nQuantity identifier allowing to use the quantity as index in parameter fields\n\n\n\n\n\n","category":"type"},{"location":"quantities/#VoronoiFVM.DiscontinuousQuantity-Union{Tuple{Tm}, Tuple{Ti}, Tuple{Tv}, Tuple{VoronoiFVM.AbstractSystem{Tv, Ti, Tm}, AbstractVector}} where {Tv, Ti, Tm}","page":"Quantities","title":"VoronoiFVM.DiscontinuousQuantity","text":" DiscontinuousQuantity(system,regions; regionspec=nothing, id=0)\n\nAdd discontinuous quantity to the regions listed in regions.\n\nUnless specified in regionspec, the species numbers for each region are generated automatically.\n\nUnless specified by id, the quantity ID is generated automatically.\n\n\n\n\n\n","category":"method"},{"location":"quantities/#VoronoiFVM.InterfaceQuantity","page":"Quantities","title":"VoronoiFVM.InterfaceQuantity","text":"struct InterfaceQuantity{Ti} <: VoronoiFVM.AbstractQuantity{Ti}\n\nAn interface quantity is represented by exactly one species number\n\nispec::Any\nSpecies number representing the quantity\n\nbregspec::Vector\nboundary regions, where interface quantity is defined\n\nid::Any\nQuantity identifier allowing to use the quantity as index in parameter fields\n\n\n\n\n\n","category":"type"},{"location":"quantities/#VoronoiFVM.InterfaceQuantity-Union{Tuple{Tm}, Tuple{Ti}, Tuple{Tv}, Tuple{VoronoiFVM.AbstractSystem{Tv, Ti, Tm}, AbstractVector}} where {Tv, Ti, Tm}","page":"Quantities","title":"VoronoiFVM.InterfaceQuantity","text":" InterfaceQuantity(system,regions; ispec=0, id=0)\n\nAdd interface quantity to the boundary regions given in breg.\n\nUnless specified in ispec, the species number is generated automtically.\n\nUnless specified by id, the quantity ID is generated automatically.\n\n\n\n\n\n","category":"method"},{"location":"quantities/#Base.getindex-Tuple{AbstractArray, VoronoiFVM.AbstractQuantity}","page":"Quantities","title":"Base.getindex","text":"A[q]\n\nAccess columns  of Array A using id of quantity q\n\n\n\n\n\n","category":"method"},{"location":"quantities/#Base.getindex-Tuple{AbstractMatrix, VoronoiFVM.AbstractQuantity, Any}","page":"Quantities","title":"Base.getindex","text":"M[q,i]\n\nAccess columns  M using id of quantity q\n\n\n\n\n\n","category":"method"},{"location":"quantities/#Base.getindex-Tuple{ContinuousQuantity, VoronoiFVM.AbstractNode}","page":"Quantities","title":"Base.getindex","text":"node[quantity]\nedge[quantity]\n\nReturn species number on AbstractNode or AbstractEdge\n\n\n\n\n\n","category":"method"},{"location":"quantities/#Base.getindex-Tuple{DiscontinuousQuantity, VoronoiFVM.BNode, Any}","page":"Quantities","title":"Base.getindex","text":"bnode[quantity,ireg]\n\nReturn species number of discontinuous quantity region ireg  adjacent to  BNode.\n\n\n\n\n\n","category":"method"},{"location":"quantities/#Base.getindex-Tuple{DiscontinuousQuantity, VoronoiFVM.BNode}","page":"Quantities","title":"Base.getindex","text":"bnode[quantity]\n\nReturn species number of discontinuous quantity region ireg  adjacent to  BNode for outer boundary nodes.\n\n\n\n\n\n","category":"method"},{"location":"quantities/#Base.getindex-Tuple{VoronoiFVM.AbstractEdgeData, VoronoiFVM.AbstractQuantity, Any}","page":"Quantities","title":"Base.getindex","text":"u[q,j]\n\nReturn value of quantity in unknowns on edge in flux callbacks.\n\n\n\n\n\n","category":"method"},{"location":"quantities/#Base.getindex-Tuple{VoronoiFVM.AbstractNodeData, VoronoiFVM.AbstractQuantity}","page":"Quantities","title":"Base.getindex","text":"u[q]\n\nReturn value of quantity in unknowns on node in  node callbacks.\n\n\n\n\n\n","category":"method"},{"location":"quantities/#Base.getindex-Tuple{VoronoiFVM.BNodeUnknowns, DiscontinuousQuantity, Any}","page":"Quantities","title":"Base.getindex","text":"u[q,ireg]\n\nReturn value of discontinuous quantity in unknowns adjacent to unknowns on boundary node.\n\n\n\n\n\n","category":"method"},{"location":"quantities/#Base.setindex!-Tuple{AbstractArray, Any, VoronoiFVM.AbstractQuantity}","page":"Quantities","title":"Base.setindex!","text":"A[q]\n\nSet element of A using id of quantity q\n\n\n\n\n\n","category":"method"},{"location":"quantities/#Base.setindex!-Tuple{AbstractMatrix, Any, VoronoiFVM.AbstractQuantity, Any}","page":"Quantities","title":"Base.setindex!","text":"M[q,i]\n\nSet element of M using id of quantity q\n\n\n\n\n\n","category":"method"},{"location":"quantities/#Base.setindex!-Tuple{VoronoiFVM.AbstractNodeData, Any, VoronoiFVM.AbstractQuantity}","page":"Quantities","title":"Base.setindex!","text":"f[q]=value\n\nSet rhs value for quantity in callbacks\n\n\n\n\n\n","category":"method"},{"location":"quantities/#Base.setindex!-Tuple{VoronoiFVM.BNodeRHS, Any, DiscontinuousQuantity, Any}","page":"Quantities","title":"Base.setindex!","text":"f[q,ireg]=v\n\nSet rhs value for discontinuous quantity in adjacent regions of  boundary node.\n\n\n\n\n\n","category":"method"},{"location":"quantities/#VoronoiFVM.boundary_dirichlet!-Tuple{VoronoiFVM.AbstractSystem, DiscontinuousQuantity, Any, Any}","page":"Quantities","title":"VoronoiFVM.boundary_dirichlet!","text":"boundary_dirichlet(system, quantity, ibc, value)\n\nSet Dirichlet boundary value for quantity at boundary ibc.\n\n\n\n\n\n","category":"method"},{"location":"quantities/#VoronoiFVM.num_quantities-Tuple{VoronoiFVM.AbstractSystem}","page":"Quantities","title":"VoronoiFVM.num_quantities","text":"num_quantities(system)\n\n\nNumber of quantities defined for system\n\n\n\n\n\n","category":"method"},{"location":"quantities/#VoronoiFVM.subgrids-Tuple{DiscontinuousQuantity, Any}","page":"Quantities","title":"VoronoiFVM.subgrids","text":"subgrids(quantity, system)\n\nReturn a vector of subgrids containing a subgrid for each region where discontinuous quantity is defined.\n\n\n\n\n\n","category":"method"},{"location":"quantities/#VoronoiFVM.subgrids-Tuple{InterfaceQuantity, Any}","page":"Quantities","title":"VoronoiFVM.subgrids","text":"subgrids(quantity, system)\n\nReturn the subgrid where interface quantity is defined.\n\n\n\n\n\n","category":"method"},{"location":"quantities/#VoronoiFVM.views-Tuple{Any, DiscontinuousQuantity, Any, Any}","page":"Quantities","title":"VoronoiFVM.views","text":"views(quantity, subgrids,system)\n\nReturn a vector of solutions containing the solutions with respect tp each region where discontinuous quantity is defined.\n\n\n\n\n\n","category":"method"},{"location":"examples/Example120_ThreeRegions1D/#:-Differing-species-sets-in-regions,-1D","page":"120: Differing species sets in regions, 1D","title":"120: Differing species sets in regions, 1D","text":"","category":"section"},{"location":"examples/Example120_ThreeRegions1D/","page":"120: Differing species sets in regions, 1D","title":"120: Differing species sets in regions, 1D","text":"(source code)","category":"page"},{"location":"examples/Example120_ThreeRegions1D/","page":"120: Differing species sets in regions, 1D","title":"120: Differing species sets in regions, 1D","text":"module Example120_ThreeRegions1D\n\nusing Printf\nusing VoronoiFVM\nusing ExtendableGrids\nusing GridVisualize\n\n\n\nfunction main(;n=30,Plotter=nothing,plot_grid=false, verbose=false,unknown_storage=:sparse,tend=10,rely_on_corrections=false)\n    h=3.0/(n-1)\n    X=collect(0:h:3.0)\n    grid=VoronoiFVM.Grid(X)\n    cellmask!(grid,[0.0],[1.0],1)\n    cellmask!(grid,[1.0],[2.1],2)\n    cellmask!(grid,[1.9],[3.0],3)\n\n    subgrid1=subgrid(grid,[1])\n    subgrid2=subgrid(grid,[1,2,3])\n    subgrid3=subgrid(grid,[3])\n\n    if plot_grid\n        plotgrid(grid,Plotter=Plotter)\n        return\n    end\n\n    eps=[1,1,1]\n    k=[1,1,1]\n\n    function reaction(f,u,node)\n        if node.region==1\n            f[1]=k[1]*u[1]\n            f[2]=-k[1]*u[1]\n        elseif node.region==3\n            f[2]=k[3]*u[2]\n            f[3]=-k[3]*u[2]\n        else\n            f[1]=0\n        end\n    end\n\n    function source(f,node)\n        if node.region==1\n           f[1]=1.0e-4*(3.0-node[1])\n        end\n    end\n\n    if rely_on_corrections\n        # Since 0.17.0 one can\n        # write into the result also where\n        # the corresponding species has not been enabled\n        # Species information is used to prevent the assembly.\n        flux=function(f,u,edge)\n            for i=1:3\n                f[i]=eps[i]*(u[i,1]-u[i,2])\n            end\n        end\n\n        storage=function(f,u,node)\n            f.=u\n        end\n    else\n        # This is the \"old\" way:\n        # Write into result only where\n        # the corresponding species has been enabled\n        flux=function(f,u,edge)\n            if edge.region==1\n                f[1]=eps[1]*(u[1,1]-u[1,2])\n                f[2]=eps[2]*(u[2,1]-u[2,2])\n            elseif edge.region==2\n                f[2]=eps[2]*(u[2,1]-u[2,2])\n            elseif edge.region==3\n                f[2]=eps[2]*(u[2,1]-u[2,2])\n                f[3]=eps[3]*(u[3,1]-u[3,2])\n            end\n        end\n\n\n        storage=function(f,u,node)\n            if node.region==1\n                f[1]=u[1]\n                f[2]=u[2]\n            elseif node.region==2\n                f[2]=u[2]\n            elseif node.region==3\n                f[2]=u[2]\n                f[3]=u[3]\n            end\n        end\n\n    end\n\n    sys=VoronoiFVM.System(grid; flux, reaction,storage, source,unknown_storage=unknown_storage)\n\n    enable_species!(sys,1,[1])\n    enable_species!(sys,2,[1,2,3])\n    enable_species!(sys,3,[3])\n\n    boundary_dirichlet!(sys,3,2,0.0)\n\n    inival=unknowns(sys)\n    U=unknowns(sys)\n    inival.=0\n\n    control=VoronoiFVM.NewtonControl()\n    control.verbose=verbose\n    tstep=0.01\n    time=0.0\n    istep=0\n    testval=0\n    p=GridVisualizer(Plotter=Plotter,layout=(1,1))\n    while time<tend\n        time=time+tstep\n        solve!(U,inival,sys,control=control,tstep=tstep)\n        inival.=U\n        if verbose\n            @printf(\"time=%g\\n\",time)\n        end\n        tstep*=1.1\n        istep=istep+1\n        testval=U[2,5]\n\n        U1=view(U[1,:],subgrid1)\n        U2=view(U[2,:],subgrid2)\n        U3=view(U[3,:],subgrid3)\n\n        scalarplot!(p[1,1],subgrid1, U1,label=\"spec1\", color=(0.5,0,0),xlimits=(0,3),flimits=(0,1e-3),\n                  title=@sprintf(\"three regions t=%.3g\",time))\n        scalarplot!(p[1,1],subgrid2, U2,label=\"spec2\", color=(0.0,0.5,0),clear=false)\n        scalarplot!(p[1,1],subgrid3, U3,label=\"spec3\", color=(0.0,0.0,0.5),clear=false,show=true)\n        if Plotter !=nothing\n            sleep(1.0e-2)\n        end\n    end\n    return testval\nend\n\nfunction test()\n    testval=0.0005967243505359461\n    main(unknown_storage=:sparse,rely_on_corrections=false) ≈ testval &&\n        main(unknown_storage=:dense,rely_on_corrections=false) ≈ testval# &&\n        main(unknown_storage=:sparse,rely_on_corrections=true) ≈ testval &&\n        main(unknown_storage=:dense,rely_on_corrections=true) ≈ testval\n\nend\n\nend","category":"page"},{"location":"examples/Example120_ThreeRegions1D/","page":"120: Differing species sets in regions, 1D","title":"120: Differing species sets in regions, 1D","text":"","category":"page"},{"location":"examples/Example120_ThreeRegions1D/","page":"120: Differing species sets in regions, 1D","title":"120: Differing species sets in regions, 1D","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/Example422_InterfaceQuantities/#:-Drift-Diffusion-with-Discontinuous-and-Interface-Potentials","page":"422: Drift-Diffusion with Discontinuous and Interface Potentials","title":"422: Drift-Diffusion with Discontinuous and Interface Potentials","text":"","category":"section"},{"location":"examples/Example422_InterfaceQuantities/","page":"422: Drift-Diffusion with Discontinuous and Interface Potentials","title":"422: Drift-Diffusion with Discontinuous and Interface Potentials","text":"(source code)","category":"page"},{"location":"examples/Example422_InterfaceQuantities/","page":"422: Drift-Diffusion with Discontinuous and Interface Potentials","title":"422: Drift-Diffusion with Discontinuous and Interface Potentials","text":"Nondimensionalized semiconductor device equations (with artificial doping) with Discontinuousquantities and additional Interfacequantities.","category":"page"},{"location":"examples/Example422_InterfaceQuantities/","page":"422: Drift-Diffusion with Discontinuous and Interface Potentials","title":"422: Drift-Diffusion with Discontinuous and Interface Potentials","text":"module Example422_InterfaceQuantities\n\nusing VoronoiFVM\nusing ExtendableGrids\nusing GridVisualize\n\nfunction main(;n=5, Plotter = nothing, tend = 20.0, unknown_storage=:sparse,\n              reactionN = 5.0e0, reactionP = 5.0e0)\n\n    ################################################################################\n    #### grid\n    ################################################################################\n    h1       = 1.0\n    h2       = 1.0\n    h_total  = h1 + h2","category":"page"},{"location":"examples/Example422_InterfaceQuantities/","page":"422: Drift-Diffusion with Discontinuous and Interface Potentials","title":"422: Drift-Diffusion with Discontinuous and Interface Potentials","text":"region numbers","category":"page"},{"location":"examples/Example422_InterfaceQuantities/","page":"422: Drift-Diffusion with Discontinuous and Interface Potentials","title":"422: Drift-Diffusion with Discontinuous and Interface Potentials","text":"    region1         = 1\n    region2         = 2\n    regions         = [region1, region2]\n    numberOfRegions = length(regions)","category":"page"},{"location":"examples/Example422_InterfaceQuantities/","page":"422: Drift-Diffusion with Discontinuous and Interface Potentials","title":"422: Drift-Diffusion with Discontinuous and Interface Potentials","text":"boundary region numbers","category":"page"},{"location":"examples/Example422_InterfaceQuantities/","page":"422: Drift-Diffusion with Discontinuous and Interface Potentials","title":"422: Drift-Diffusion with Discontinuous and Interface Potentials","text":"    bregion1  = 1\n    bregion2  = 2\n    bjunction = 3\n\n    coord_1   = collect(range(0.0, stop = h1,      length = n))\n    coord_2   = collect(range(h1,  stop = h1 + h2, length = n))\n    coord     = glue(coord_1, coord_2)\n\n    grid      = simplexgrid(coord)","category":"page"},{"location":"examples/Example422_InterfaceQuantities/","page":"422: Drift-Diffusion with Discontinuous and Interface Potentials","title":"422: Drift-Diffusion with Discontinuous and Interface Potentials","text":"specify inner regions","category":"page"},{"location":"examples/Example422_InterfaceQuantities/","page":"422: Drift-Diffusion with Discontinuous and Interface Potentials","title":"422: Drift-Diffusion with Discontinuous and Interface Potentials","text":"    cellmask!(grid, [0.0], [h1], region1)\n    cellmask!(grid, [h1],  [h1 + h2], region2)","category":"page"},{"location":"examples/Example422_InterfaceQuantities/","page":"422: Drift-Diffusion with Discontinuous and Interface Potentials","title":"422: Drift-Diffusion with Discontinuous and Interface Potentials","text":"specifiy outer regions","category":"page"},{"location":"examples/Example422_InterfaceQuantities/","page":"422: Drift-Diffusion with Discontinuous and Interface Potentials","title":"422: Drift-Diffusion with Discontinuous and Interface Potentials","text":"    bfacemask!(grid, [0.0],     [0.0],     bregion1)\n    bfacemask!(grid, [h_total], [h_total], bregion2)","category":"page"},{"location":"examples/Example422_InterfaceQuantities/","page":"422: Drift-Diffusion with Discontinuous and Interface Potentials","title":"422: Drift-Diffusion with Discontinuous and Interface Potentials","text":"inner interfaces","category":"page"},{"location":"examples/Example422_InterfaceQuantities/","page":"422: Drift-Diffusion with Discontinuous and Interface Potentials","title":"422: Drift-Diffusion with Discontinuous and Interface Potentials","text":"    bfacemask!(grid, [h1], [h1], bjunction)\n\n    #gridplot(grid, Plotter = nothing, legend=:rt)\n\n    ################################################################################\n    #########  system\n    ################################################################################\n\n    sys    = VoronoiFVM.System(grid, unknown_storage = unknown_storage)\n    iphin  = DiscontinuousQuantity(sys, 1:numberOfRegions, id = 1)\n    iphip  = DiscontinuousQuantity(sys, 1:numberOfRegions, id = 2)\n    iphinb = InterfaceQuantity(sys,     [bjunction],       id = 3)\n    iphipb = InterfaceQuantity(sys,     [bjunction],       id = 4)\n    ipsi   = ContinuousQuantity(sys,    1:numberOfRegions, id = 5)\n\n    NA  = [10.0, 0.0];  ND = [0.0, 10.0]\n\n    function storage!(f, u, node)\n\n        etan = - ( (u[iphin] - u[ipsi]) )\n        etap =   ( (u[iphip] - u[ipsi]) )\n\n        f[iphin] = - exp(etan)\n        f[iphip] =   exp(etap)\n\n        f[ipsi]  =  0.0\n\n    end\n\n    function reaction!(f, u, node)\n\n        etan     = - ( (u[iphin] - u[ipsi]) )\n        etap     =   ( (u[iphip] - u[ipsi]) )\n\n        f[ipsi]  = - (ND[node.region] - exp(etan) + exp(etap) - NA[node.region])\n        ########################\n        r0       = 1.0e-4\n        recomb   = r0 * exp(etan) * exp(etap)\n\n        f[iphin] =  - recomb\n        f[iphip] =    recomb\n    end\n\n    function flux!(f, u, node)\n\n        f[ipsi] =  - (u[ipsi, 2] - u[ipsi, 1])\n\n        ########################\n        bp, bm = fbernoulli_pm(-  (u[ipsi, 2] - u[ipsi, 1]) )\n\n        etan1 = - ( (u[iphin, 1] - u[ipsi, 1]) )\n        etap1 =   ( (u[iphip, 1] - u[ipsi, 1]) )\n\n        etan2 = - ( (u[iphin, 2] - u[ipsi, 2]) )\n        etap2 =   ( (u[iphip, 2] - u[ipsi, 2]) )\n\n        f[iphin]  =   (bm * exp(etan2) - bp * exp(etan1))\n        f[iphip]  = - (bp * exp(etap2) - bm * exp(etap1))\n    end\n\n    function breaction!(f, u, bnode)\n\n        if bnode.region == bjunction","category":"page"},{"location":"examples/Example422_InterfaceQuantities/","page":"422: Drift-Diffusion with Discontinuous and Interface Potentials","title":"422: Drift-Diffusion with Discontinuous and Interface Potentials","text":"left values","category":"page"},{"location":"examples/Example422_InterfaceQuantities/","page":"422: Drift-Diffusion with Discontinuous and Interface Potentials","title":"422: Drift-Diffusion with Discontinuous and Interface Potentials","text":"            nleft    = exp(- ( (u[iphin, 1] - u[ipsi]) ))\n            pleft    = exp(  ( (u[iphip, 1] - u[ipsi]) ))","category":"page"},{"location":"examples/Example422_InterfaceQuantities/","page":"422: Drift-Diffusion with Discontinuous and Interface Potentials","title":"422: Drift-Diffusion with Discontinuous and Interface Potentials","text":"interface species","category":"page"},{"location":"examples/Example422_InterfaceQuantities/","page":"422: Drift-Diffusion with Discontinuous and Interface Potentials","title":"422: Drift-Diffusion with Discontinuous and Interface Potentials","text":"            n_interf = exp(- ( (u[iphinb]   - u[ipsi]) ))\n            p_interf = exp(  ( (u[iphipb]   - u[ipsi]) ))","category":"page"},{"location":"examples/Example422_InterfaceQuantities/","page":"422: Drift-Diffusion with Discontinuous and Interface Potentials","title":"422: Drift-Diffusion with Discontinuous and Interface Potentials","text":"right values","category":"page"},{"location":"examples/Example422_InterfaceQuantities/","page":"422: Drift-Diffusion with Discontinuous and Interface Potentials","title":"422: Drift-Diffusion with Discontinuous and Interface Potentials","text":"            nright   = exp(- ( (u[iphin, 2] - u[ipsi]) ))\n            pright   = exp(  ( (u[iphip, 2] - u[ipsi]) ))\n            ################","category":"page"},{"location":"examples/Example422_InterfaceQuantities/","page":"422: Drift-Diffusion with Discontinuous and Interface Potentials","title":"422: Drift-Diffusion with Discontinuous and Interface Potentials","text":"left and right reaction for n","category":"page"},{"location":"examples/Example422_InterfaceQuantities/","page":"422: Drift-Diffusion with Discontinuous and Interface Potentials","title":"422: Drift-Diffusion with Discontinuous and Interface Potentials","text":"            f[iphin, 1] = reactionN * (nleft  - n_interf)\n            f[iphin, 2] = reactionN * (nright - n_interf)","category":"page"},{"location":"examples/Example422_InterfaceQuantities/","page":"422: Drift-Diffusion with Discontinuous and Interface Potentials","title":"422: Drift-Diffusion with Discontinuous and Interface Potentials","text":"left and right reaction for p","category":"page"},{"location":"examples/Example422_InterfaceQuantities/","page":"422: Drift-Diffusion with Discontinuous and Interface Potentials","title":"422: Drift-Diffusion with Discontinuous and Interface Potentials","text":"            f[iphip, 1] = reactionP * (pleft  - p_interf)\n            f[iphip, 2] = reactionP * (pright - p_interf)","category":"page"},{"location":"examples/Example422_InterfaceQuantities/","page":"422: Drift-Diffusion with Discontinuous and Interface Potentials","title":"422: Drift-Diffusion with Discontinuous and Interface Potentials","text":"interface species reaction","category":"page"},{"location":"examples/Example422_InterfaceQuantities/","page":"422: Drift-Diffusion with Discontinuous and Interface Potentials","title":"422: Drift-Diffusion with Discontinuous and Interface Potentials","text":"            f[iphinb]   =  - (f[iphin, 1] + f[iphin, 2])\n            f[iphipb]   =  - (f[iphip, 1] + f[iphip, 2])\n\n        end\n\n\n    end\n\n    function bstorage!(f, u, bnode)\n\n        f[ipsi]  =  0.0\n\n        if bnode.region == bjunction\n\n            etan = - ( (u[iphinb] - u[ipsi]) )\n            etap =   ( (u[iphipb] - u[ipsi]) )\n\n            f[iphinb] = - exp(etan)\n            f[iphipb] =   exp(etap)\n\n        end\n\n    end\n\n    physics!(sys, VoronoiFVM.Physics(\n        flux      = flux!,\n        storage   = storage!,\n        reaction  = reaction!,\n        breaction = breaction!,\n        bstorage  = bstorage!\n    ))\n\n\n    boundary_dirichlet!(sys, iphin, bregion1, 4.0)\n    boundary_dirichlet!(sys, iphip, bregion1, 4.0)\n    boundary_dirichlet!(sys, ipsi,  bregion1, 0.0)\n    boundary_dirichlet!(sys, iphin, bregion2, 0.0)\n    boundary_dirichlet!(sys, iphip, bregion2, 0.0)\n    boundary_dirichlet!(sys, ipsi,  bregion2, 5.0)\n\n    ################################################################################\n    #########  time loop\n    ################################################################################\n\n    # Create a solution array\n    inival = unknowns(sys); inival .= 0.0\n    sol    = unknowns(sys)\n\n    t0      = 1.0e-6\n    ntsteps = 10\n    tvalues = range(t0, stop = tend, length = ntsteps)\n\n    for istep = 2:ntsteps\n\n        t   = tvalues[istep]       # Actual time\n        Δt  = t - tvalues[istep-1] # Time step size\n\n        #println(\"Δt = \", t)\n\n        solve!(sol, inival, sys, tstep = Δt)\n        inival .= sol\n\n    end # time loop\n\n    ################################################################################\n    #########  Bias Loop\n    ################################################################################\n    biasval  = range(0, stop = 2.0, length = 10)\n    Idspec   = zeros(0)\n\n    for Δu in biasval\n\n        boundary_dirichlet!(sys, iphin, bregion1, 4.0 + Δu)\n        boundary_dirichlet!(sys, iphip, bregion1, 4.0 + Δu)\n        boundary_dirichlet!(sys, ipsi,  bregion1, 0.0 + Δu)\n\n        #println(\"Δu = \", Δu)\n\n        solve!(sol, inival, sys)\n        inival .= sol\n\n        # get current\n        factory = TestFunctionFactory(sys)\n        tf      = testfunction(factory, [1], [2])\n        I       = integrate(sys, tf, sol)\n\n        val = 0.0\n        for ii = 1:length(I)-1\n            val = val + I[ii]\n        end\n\n        push!(Idspec, val)\n\n    end # bias loop\n\n    ################################################################################\n    #########  Plotting\n    ################################################################################\n\n    vis = GridVisualizer(Plotter = Plotter, layout=(2,1))\n\n    subgridBulk = subgrids(iphin, sys)\n    phin_sol    = views(sol, iphin, subgridBulk, sys)\n    phip_sol    = views(sol, iphip, subgridBulk, sys)\n    psi_sol     = views(sol, ipsi,  subgridBulk, sys)\n\n    for i in eachindex(phin_sol)\n        scalarplot!(vis[1, 1], subgridBulk[i], phin_sol[i], clear = false, color=:green)\n        scalarplot!(vis[1, 1], subgridBulk[i], phip_sol[i], clear = false, color=:red)\n        scalarplot!(vis[1, 1], subgridBulk[i], psi_sol[i],  clear = false, color=:blue)\n    end\n\n    scalarplot!(vis[2, 1], biasval, Idspec, clear = false, color=:red)\n\n    bgrid     = subgrids(iphinb, sys)\n    sol_bound = views(sol, iphinb, bgrid, sys)\n\n    return sol_bound[1]\n\nend # main\n\nfunction test()\n    testval=0.35545473758267826\n    main(unknown_storage=:dense) ≈ testval && main(unknown_storage=:sparse) ≈ testval\nend\n\n\n\nend # module","category":"page"},{"location":"examples/Example422_InterfaceQuantities/","page":"422: Drift-Diffusion with Discontinuous and Interface Potentials","title":"422: Drift-Diffusion with Discontinuous and Interface Potentials","text":"","category":"page"},{"location":"examples/Example422_InterfaceQuantities/","page":"422: Drift-Diffusion with Discontinuous and Interface Potentials","title":"422: Drift-Diffusion with Discontinuous and Interface Potentials","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/Example160_UnipolarDriftDiffusion1D/#:-Unipolar-degenerate-drift-diffusion","page":"160: Unipolar degenerate drift-diffusion","title":"160: Unipolar degenerate drift-diffusion","text":"","category":"section"},{"location":"examples/Example160_UnipolarDriftDiffusion1D/","page":"160: Unipolar degenerate drift-diffusion","title":"160: Unipolar degenerate drift-diffusion","text":"(source code)","category":"page"},{"location":"examples/Example160_UnipolarDriftDiffusion1D/","page":"160: Unipolar degenerate drift-diffusion","title":"160: Unipolar degenerate drift-diffusion","text":"See: C. Cancès, C. Chainais-Hillairet, J. Fuhrmann, and B. Gaudeul, \"A numerical-analysis-focused comparison of several finite volume schemes for a unipolar degenerate drift-diffusion model\" IMA Journal of Numerical Analysis, vol. 41, no. 1, pp. 271–314, 2021.","category":"page"},{"location":"examples/Example160_UnipolarDriftDiffusion1D/","page":"160: Unipolar degenerate drift-diffusion","title":"160: Unipolar degenerate drift-diffusion","text":"Available from https://doi.org/10.1093/imanum/draa002, the preprint is on arxiv1907.11126.","category":"page"},{"location":"examples/Example160_UnipolarDriftDiffusion1D/","page":"160: Unipolar degenerate drift-diffusion","title":"160: Unipolar degenerate drift-diffusion","text":"The problem consists of a Poisson equation for the electrostatic potential phi:","category":"page"},{"location":"examples/Example160_UnipolarDriftDiffusion1D/","page":"160: Unipolar degenerate drift-diffusion","title":"160: Unipolar degenerate drift-diffusion","text":"-nabla varepsilon nabla phi = z(2c-1)","category":"page"},{"location":"examples/Example160_UnipolarDriftDiffusion1D/","page":"160: Unipolar degenerate drift-diffusion","title":"160: Unipolar degenerate drift-diffusion","text":"and a degenerate drift-diffusion equation of the transport of a charged species c:","category":"page"},{"location":"examples/Example160_UnipolarDriftDiffusion1D/","page":"160: Unipolar degenerate drift-diffusion","title":"160: Unipolar degenerate drift-diffusion","text":"partial_t u  - nablacdot left(nabla c  + c nabla (phi - log (1-c) )right)","category":"page"},{"location":"examples/Example160_UnipolarDriftDiffusion1D/","page":"160: Unipolar degenerate drift-diffusion","title":"160: Unipolar degenerate drift-diffusion","text":"In particular, the paper, among others, investigates the \"sedan\" flux discretization which is able to handle the degeneracy coming from the log (1-c) term. The earliest reference to this scheme we found in the source code of the SEDAN III semiconductor device simulator.","category":"page"},{"location":"examples/Example160_UnipolarDriftDiffusion1D/","page":"160: Unipolar degenerate drift-diffusion","title":"160: Unipolar degenerate drift-diffusion","text":"module Example160_UnipolarDriftDiffusion1D\n\nusing Printf\n\nusing VoronoiFVM\nusing ExtendableGrids\nusing GridVisualize\n\nmutable struct Data\n    eps::Float64\n    z::Float64\n    ic::Int32\n    iphi::Int32\n    Data()=new()\nend\n\n\n\n\nfunction classflux!(f,u,edge,data)\n    ic=data.ic\n    iphi=data.iphi\n    f[iphi]=data.eps*(u[iphi,1]-u[iphi,2])\n    bp,bm=fbernoulli_pm(u[iphi,1]-u[iphi,2])\n    f[ic]=bm*u[ic,1]-bp*u[ic,2]\nend\n\n\nfunction storage!(f,u,node,data)\n    ic=data.ic\n    iphi=data.iphi\n    f[iphi]=0\n    f[ic]=u[ic]\nend\n\nfunction reaction!(f,u,node,data)\n    ic=data.ic\n    iphi=data.iphi\n    f[iphi]=data.z*(1-2*u[ic])\n    f[ic]=0\nend\n\nfunction sedanflux!(f,u,edge,data)\n    ic=data.ic\n    iphi=data.iphi\n    f[iphi]=data.eps*(u[iphi,1]-u[iphi,2])\n    mu1=-log(1-u[ic,1])\n    mu2=-log(1-u[ic,2])\n    bp,bm=fbernoulli_pm(data.z*2*(u[iphi,1]-u[iphi,2])+(mu1-mu2))\n    f[ic]=bm*u[ic,1]-bp*u[ic,2]\nend\n\n\nfunction main(;n=20,Plotter=nothing,dlcap=false,verbose=false,unknown_storage=:sparse,DiffEq=nothing)\n\n    h=1.0/convert(Float64,n)\n    grid=VoronoiFVM.Grid(collect(0:h:1))\n\n    data=Data()\n    data.eps=1.0e-3\n    data.z=-1\n    data.iphi=1\n    data.ic=2\n\n    ic=data.ic\n    iphi=data.iphi\n\n\n    physics=VoronoiFVM.Physics(data=data,\n                               flux=sedanflux!,\n                               reaction=reaction!,\n                               storage=storage!\n                               )\n    sys=VoronoiFVM.System(grid,physics,unknown_storage=unknown_storage)\n\n    enable_species!(sys,1,[1])\n    enable_species!(sys,2,[1])\n\n    boundary_dirichlet!(sys,iphi,1,5.0)\n    boundary_dirichlet!(sys,iphi,2,0.0)\n    boundary_dirichlet!(sys,ic,2,0.5)\n\n    inival=unknowns(sys)\n    @views inival[iphi,:].=2\n    @views inival[ic,:].=0.5\n\n\n    if !dlcap\n        # Create solver control info for constant time step size\n        tstep=1.0e-3\n        control=VoronoiFVM.NewtonControl()\n        control.verbose=verbose\n        control.Δt_min=tstep\n        control.Δt=tstep\n        control.Δt_grow=1.2\n        control.Δt_max=0.1\n        control.Δu_opt=100\n        control.damp_initial=0.5\n        if isnothing(DiffEq)\n            tsol=solve(inival,sys,[0.0,10],control=control)\n        else # does not work yet...\n            tsol=solve(DiffEq,inival,sys,[0.0,10],\n                       initializealg=DiffEq.NoInit(),\n                       dt=tstep)\n        end\n        vis=GridVisualizer(Plotter=Plotter,layout=(1,1),fast=true)\n        for log10t=-4:0.01:0\n            time=10^(log10t)\n            sol=tsol(time)\n            scalarplot!(vis[1,1],grid,sol[iphi,:],label=\"ϕ\",title=@sprintf(\"time=%.3g\",time),flimits=(0,5),color=:green)\n            scalarplot!(vis[1,1],grid,sol[ic,:],label=\"c\",flimits=(0,5),clear=false,color=:red)\n            reveal(vis)\n        end\n        return sum(tsol[end])\n\n    else  # Calculate double layer capacitance\n        U=unknowns(sys)\n        control=VoronoiFVM.NewtonControl()\n        control.damp_initial=1.0e-5\n        delta=1.0e-4\n        @views inival[iphi,:].=0\n        @views inival[ic,:].=0.5\n        sys.boundary_values[iphi,1]=0\n\n        dphi=1.0e-1\n        phimax=5\n        delta=1.0e-4\n        vplus=zeros(0)\n        cdlplus=zeros(0)\n        vminus=zeros(0)\n        cdlminus=zeros(0)\n        cdl=0.0\n        vis=GridVisualizer(Plotter=Plotter,layout=(2,1),fast=true)\n        for dir in [1,-1]\n            phi=0.0\n            while phi<phimax\n                sys.boundary_values[iphi,1]=dir*phi\n                solve!(U,inival,sys,control=control)\n                inival.=U\n                Q=integrate(sys,physics.reaction,U)\n                sys.boundary_values[iphi,1]=dir*phi+delta\n                solve!(U,inival,sys,control=control)\n                inival.=U\n\n                scalarplot!(vis[1,1],grid,U[iphi,:],label=\"ϕ\",title=@sprintf(\"Δϕ=%.3g\",phi),flimits=(-5,5),clear=true,color=:green)\n                scalarplot!(vis[1,1],grid,U[ic,:],label=\"c\",flimits=(0,5),clear=false,color=:red)\n\n                Qdelta=integrate(sys,physics.reaction,U)\n                cdl=(Qdelta[iphi]-Q[iphi])/delta\n                if dir==1\n                    push!(vplus,dir*phi)\n                    push!(cdlplus,cdl)\n                else\n                    push!(vminus,dir*phi)\n                    push!(cdlminus,cdl)\n                end\n\n                scalarplot!(vis[2,1],[0,1.0e-1], [0,0.05],color=:white,clear=true)\n                v=vcat(reverse(vminus),vplus)\n                c=vcat(reverse(cdlminus),cdlplus)\n                if length(v)>=2\n                    scalarplot!(vis[2,1],v,c,color=:green,clear=false,title=\"C_dl\")\n                end\n\n                phi+=dphi\n                reveal(vis)\n            end\n        end\n\n        return cdl\n    end\nend\n\nfunction test()\n\n    isapprox(main(unknown_storage=:sparse,dlcap=false),18.721369939561963,rtol=1.0e-5)&&\n    isapprox(main(unknown_storage=:sparse,dlcap=true),0.010759276468375045,rtol=1.0e-5)&&\n    isapprox(main(unknown_storage=:dense,dlcap=false),18.721369939561963,rtol=1.0e-5)&&\n    isapprox(main(unknown_storage=:dense,dlcap=true),0.010759276468375045,rtol=1.0e-5)\n\nend\nend","category":"page"},{"location":"examples/Example160_UnipolarDriftDiffusion1D/","page":"160: Unipolar degenerate drift-diffusion","title":"160: Unipolar degenerate drift-diffusion","text":"","category":"page"},{"location":"examples/Example160_UnipolarDriftDiffusion1D/","page":"160: Unipolar degenerate drift-diffusion","title":"160: Unipolar degenerate drift-diffusion","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/Example406_WeirdReaction/#:-1D-Weird-Surface-Reaction","page":"406: 1D Weird Surface Reaction","title":"406: 1D Weird Surface Reaction","text":"","category":"section"},{"location":"examples/Example406_WeirdReaction/","page":"406: 1D Weird Surface Reaction","title":"406: 1D Weird Surface Reaction","text":"(source code)","category":"page"},{"location":"examples/Example406_WeirdReaction/","page":"406: 1D Weird Surface Reaction","title":"406: 1D Weird Surface Reaction","text":"Species A and B exist in the interior of the domain, species C lives a the boundary Gamma_1.  We assume a heterogeneous reaction scheme where A reacts to B with a rate depending on nabla A near the surface","category":"page"},{"location":"examples/Example406_WeirdReaction/","page":"406: 1D Weird Surface Reaction","title":"406: 1D Weird Surface Reaction","text":"beginaligned\n      A leftrightarrow B\nendaligned","category":"page"},{"location":"examples/Example406_WeirdReaction/","page":"406: 1D Weird Surface Reaction","title":"406: 1D Weird Surface Reaction","text":"In Omega, both A and B are transported through diffusion:","category":"page"},{"location":"examples/Example406_WeirdReaction/","page":"406: 1D Weird Surface Reaction","title":"406: 1D Weird Surface Reaction","text":"beginaligned\npartial_t u_B - nablacdot D_A nabla u_A  = f_A\npartial_t u_B - nablacdot D_B nabla u_B  = 0\nendaligned","category":"page"},{"location":"examples/Example406_WeirdReaction/","page":"406: 1D Weird Surface Reaction","title":"406: 1D Weird Surface Reaction","text":"Here, f(x) is a source term creating A. On Gamma_2, we set boundary conditions","category":"page"},{"location":"examples/Example406_WeirdReaction/","page":"406: 1D Weird Surface Reaction","title":"406: 1D Weird Surface Reaction","text":"beginaligned\nD_A nabla u_A  = 0\nu_B=0\nendaligned","category":"page"},{"location":"examples/Example406_WeirdReaction/","page":"406: 1D Weird Surface Reaction","title":"406: 1D Weird Surface Reaction","text":"describing no normal flux for A and zero concentration of B. On Gamma_1, we use the mass action law to describe the boundary reaction and the evolution of the boundary concentration C. We assume that there is a limited amount of surface sites S for species C, so in fact A has to react with a free surface site in order to become C which reflected by the factor 1-u_C. The same is true for B.","category":"page"},{"location":"examples/Example406_WeirdReaction/","page":"406: 1D Weird Surface Reaction","title":"406: 1D Weird Surface Reaction","text":"beginaligned\nR_AB(u_A u_B)=k_AB^+exp(u_A(0))u_A - k_AB^-exp(-u_A(0))u_B\n- D_A nabla u_A  +  R_AB(u_A u_B) =0 \n- D_B nabla u_B  -  R_AB(u_A u_B) =0 \nendaligned","category":"page"},{"location":"examples/Example406_WeirdReaction/","page":"406: 1D Weird Surface Reaction","title":"406: 1D Weird Surface Reaction","text":"module Example406_WeirdReaction\nusing Printf\nusing VoronoiFVM\nusing SparseArrays\nusing ExtendableGrids\nusing GridVisualize\n\nfunction main(;n=10,\n              Plotter=nothing,\n              verbose=false,\n              tend=1,\n              unknown_storage=:sparse,\n              autodetect_sparsity=true)\n\n    h=1.0/convert(Float64,n)\n    X=collect(0.0:h:1.0)\n    N=length(X)\n\n    grid=VoronoiFVM.Grid(X)\n    # By default, \\Gamma_1 at X[1] and \\Gamma_2 is at X[end]\n\n    # Species numbers\n    iA=1\n    iB=2\n    iC=3\n\n\n    # Diffusion flux for species A and B\n    D_A=1.0\n    D_B=1.0e-2\n    function flux!(f,u,edge)\n        f[iA]=D_A*(u[iA,1]-u[iA,2])\n        f[iB]=D_B*(u[iB,1]-u[iB,2])\n    end\n\n    # Storage term of species A and B\n    function storage!(f,u,node)\n        f[iA]=u[iA]\n        f[iB]=u[iB]\n    end\n\n    # Source term for species a around 0.5\n    function source!(f,node)\n        x1=node[1]-0.5\n        f[iA]=exp(-100*x1^2)\n    end\n\n    # Reaction constants (p = + , m = -)\n    # Choosen to prefer path A-> B\n    kp_AB=1.0\n    km_AB=0.1\n\n\n    function breaction!(f,u,node)\n        if  node.region==1\n            R=kp_AB*exp(u[iC])*u[iA] - exp(-u[iC])*km_AB*u[iB]\n            f[iA]+=R\n            f[iB]-=R\n        end\n    end\n\n    # This generic operator works on the full solution seen as linear vector, and indexing\n    # into it needs to be performed with the help of idx (defined below for a solution vector)\n    # Its sparsity is detected automatically using SparsityDetection.jl\n    # Here, we calculate the gradient of u_A at the boundary and store the value in u_C which\n    # is then used as a parameter in the boundary reaction\n    function generic_operator!(f,u,sys)\n        f.=0\n        f[idx[iC,1]]=u[idx[iC,1]]  + 0.1*(u[idx[iA,1]]-u[idx[iA,2]])/(X[2]-X[1])\n    end","category":"page"},{"location":"examples/Example406_WeirdReaction/","page":"406: 1D Weird Surface Reaction","title":"406: 1D Weird Surface Reaction","text":"If we know the sparsity pattern, we can here create a sparse matrix with values set to 1 in the nonzero slots. This allows to circumvent the autodetection which may takes some time.","category":"page"},{"location":"examples/Example406_WeirdReaction/","page":"406: 1D Weird Surface Reaction","title":"406: 1D Weird Surface Reaction","text":"    function generic_operator_sparsity(sys)\n        idx=unknown_indices(unknowns(sys))\n        sparsity=spzeros(num_dof(sys),num_dof(sys))\n        sparsity[idx[iC,1],idx[iC,1]]=1\n        sparsity[idx[iC,1],idx[iA,1]]=1\n        sparsity[idx[iC,1],idx[iA,2]]=1\n        sparsity\n    end\n\n\n\n\n    if autodetect_sparsity\n        physics=VoronoiFVM.Physics(\n            breaction=breaction!,\n            generic=generic_operator!,\n            flux=flux!,\n            storage=storage!,\n            source=source!\n        )\n    else\n        physics=VoronoiFVM.Physics(\n            breaction=breaction!,\n            generic=generic_operator!,\n            generic_sparsity=generic_operator_sparsity,\n            flux=flux!,\n            storage=storage!,\n            source=source!\n        )\n    end\n\n    sys=VoronoiFVM.System(grid,physics,unknown_storage=unknown_storage)\n\n    # Enable species in bulk resp\n    enable_species!(sys,iA,[1])\n    enable_species!(sys,iB,[1])\n\n    # Enable surface species\n    enable_boundary_species!(sys,iC,[1])\n\n    # Set Dirichlet bc for species B on \\Gamma_2\n    boundary_dirichlet!(sys,iB,2,0.0)\n\n    # Initial values\n    inival=unknowns(sys)\n    inival.=0.0\n    U=unknowns(sys)\n    idx=unknown_indices(U)\n\n    tstep=0.01\n    time=0.0\n    T=Float64[]\n    u_C=Float64[]\n\n    control=VoronoiFVM.NewtonControl()\n    control.verbose=verbose\n    p=GridVisualizer(Plotter=Plotter,layout=(2,1))\n    while time<tend\n        time=time+tstep\n        solve!(U,inival,sys,tstep=tstep,control=control)\n        inival.=U\n        if verbose\n            @printf(\"time=%g\\n\",time)\n        end\n        # Record  boundary pecies\n        push!(T,time)\n        push!(u_C,U[iC,1])\n\n        scalarplot!(p[1,1],grid,U[iA,:],label=\"[A]\",title=@sprintf(\"max_A=%.5f max_B=%.5f u_C=%.5f\",maximum(U[iA,:]),maximum(U[iB,:]),u_C[end]),color=:red)\n        scalarplot!(p[1,1],grid,U[iB,:], label=\"[B]\",clear=false,color=:blue)\n        scalarplot!(p[2,1],copy(T),copy(u_C),label=\"[C]\",clear=true,show=true)\n    end\n    return U[iC,1]\nend\n\nfunction test()\n    testval=0.007027597470502758\n    main(unknown_storage=:sparse) ≈ testval &&\n        main(unknown_storage=:dense) ≈ testval &&\n        main(unknown_storage=:sparse,autodetect_sparsity=false) ≈ testval &&\n        main(unknown_storage=:dense,autodetect_sparsity=false) ≈ testval\nend\n\nend","category":"page"},{"location":"examples/Example406_WeirdReaction/","page":"406: 1D Weird Surface Reaction","title":"406: 1D Weird Surface Reaction","text":"","category":"page"},{"location":"examples/Example406_WeirdReaction/","page":"406: 1D Weird Surface Reaction","title":"406: 1D Weird Surface Reaction","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/Example230_BoundaryFlux/#:-Boundary-flux","page":"103: Boundary flux","title":"103: Boundary flux","text":"","category":"section"},{"location":"examples/Example230_BoundaryFlux/","page":"103: Boundary flux","title":"103: Boundary flux","text":"(source code)","category":"page"},{"location":"examples/Example230_BoundaryFlux/","page":"103: Boundary flux","title":"103: Boundary flux","text":"We consider two test problems.","category":"page"},{"location":"examples/Example230_BoundaryFlux/","page":"103: Boundary flux","title":"103: Boundary flux","text":"Testproblem A: Consider in Omega_1=(01)","category":"page"},{"location":"examples/Example230_BoundaryFlux/","page":"103: Boundary flux","title":"103: Boundary flux","text":"- d_1 Delta u_1  + k_1 u_1 = c_1","category":"page"},{"location":"examples/Example230_BoundaryFlux/","page":"103: Boundary flux","title":"103: Boundary flux","text":"in  with homogeneous Neumann boundary conditons.","category":"page"},{"location":"examples/Example230_BoundaryFlux/","page":"103: Boundary flux","title":"103: Boundary flux","text":"Testproblem B: Consider in \\Omega_2=(0,1) x (0, 1) $","category":"page"},{"location":"examples/Example230_BoundaryFlux/","page":"103: Boundary flux","title":"103: Boundary flux","text":"- d_2 Delta u_2  + k_2 u_2 = c_2","category":"page"},{"location":"examples/Example230_BoundaryFlux/","page":"103: Boundary flux","title":"103: Boundary flux","text":"in  with homogeneous Neumann boundary conditons and at the right boundary, i.e. $ {1} x (0, 1) $","category":"page"},{"location":"examples/Example230_BoundaryFlux/","page":"103: Boundary flux","title":"103: Boundary flux","text":"- d_b Delta v  + k_b v = c_b","category":"page"},{"location":"examples/Example230_BoundaryFlux/","page":"103: Boundary flux","title":"103: Boundary flux","text":"If d1 = db, k1 = kb and c1 = cb, then u and v should coincide.","category":"page"},{"location":"examples/Example230_BoundaryFlux/","page":"103: Boundary flux","title":"103: Boundary flux","text":"module Example230_BoundaryFlux\n\nusing VoronoiFVM\nusing ExtendableGrids\nusing GridVisualize\n\n\nfunction main(;n = 2 * 10, # n musst be an even number\n              d1 = 5.0, db = 5.0, # prefactors (before diffusive part)\n              kmax = 2.0, cmax = 3.0,\n              Plotter = nothing,\n              unknown_storage=:sparse)\n\n    ###########################################################################\n    ######################          1D problem           ######################\n    ###########################################################################\n\n    ispec_1D       = 1\n    bulk_1D        = 1\n\n    X              = range(0.0, stop = 1.0, length = n)\n    length_x       = length(X)\n    length_x_half  = Int(length_x/2)\n\n    grid_1D        = simplexgrid(X)\n\n    k1             = zeros(length_x);       c1 = zeros(length_x);\n\n    k1[ 1:length_x_half ] .= kmax;  k1[ length_x_half+1:length_x ] .= 0.0  # prefactor before reactive part\n    c1[ 1:length_x_half ] .= 0.0;   c1[ length_x_half+1:length_x ] .= cmax # source term\n\n    #### discretization functions ####\n\n    function flux!(f,u,edge)\n        f[1] = d1 *  (u[1,1] - u[1,2])\n    end\n\n    function reaction!(f, u, node)\n        f[1] = k1[node.index] *  u[1]\n    end\n\n    function source!(f, node::VoronoiFVM.Node)\n        f[1] = c1[node.index]\n    end\n\n    sys_1D = VoronoiFVM.System(grid_1D, VoronoiFVM.Physics(flux  = flux!,  reaction  = reaction!, source = source!) )","category":"page"},{"location":"examples/Example230_BoundaryFlux/","page":"103: Boundary flux","title":"103: Boundary flux","text":"enable species in only region","category":"page"},{"location":"examples/Example230_BoundaryFlux/","page":"103: Boundary flux","title":"103: Boundary flux","text":"    enable_species!(sys_1D, ispec_1D, [bulk_1D])\n\n    inival_1D  = unknowns(sys_1D);    inival_1D .= 0.0\n    sol_1D     = unknowns(sys_1D)\n\n    # Create solver control info\n    control   = VoronoiFVM.NewtonControl()\n\n    # Stationary solution of both problems\n    solve!(sol_1D, inival_1D, sys_1D, control = control)\n\n    p = GridVisualizer(;Plotter = Plotter, layout = (2,1), clear = true, resolution = (800,500))\n\n    scalarplot!(p[1,1], grid_1D, sol_1D[1,:], show = true, title =\"1D calculation (d1 = $d1, kmax = $kmax, cmax = $cmax)\")\n\n    ###########################################################################\n    ######################          2D problem           ######################\n    ###########################################################################\n\n    grid_2D         = simplexgrid(X, X)\n\n    ispec_2D        = 1\n    ispec_boundary  = 2\n    bulk_2D         = 1\n    active_boundary = 2","category":"page"},{"location":"examples/Example230_BoundaryFlux/","page":"103: Boundary flux","title":"103: Boundary flux","text":"parameters for the bulk problem","category":"page"},{"location":"examples/Example230_BoundaryFlux/","page":"103: Boundary flux","title":"103: Boundary flux","text":"    d2              = 1.0\n    k2              = 1.0\n    c2              = 1.0\n\n    #### discretization functions for bulk species ####\n    function flux2D!(f,u,edge)\n        f[ispec_2D] = d2 *  (u[ispec_2D, 1] - u[ispec_2D, 2])\n    end\n\n    function reaction2D!(f, u, node)\n        f[ispec_2D] = k2 * u[ispec_2D]\n    end\n\n    function source2D!(f, node)\n        f[ispec_2D] = c2\n    end\n\n    #### discretization functions for boundary species at active boundary ####\n    function bflux!(f,u,bedge)\n        if bedge.region == active_boundary\n            f[ispec_boundary] = db * (u[ispec_boundary, 1] - u[ispec_boundary, 2])\n        end\n    end\n\n    function breaction!(f, u, bnode)\n\n        if bnode.region == active_boundary\n\n             if bnode.coord[2, bnode.index] <= 0.5\n                 kb = kmax\n             else\n                 kb = 0.0\n             end\n\n            f[ispec_boundary] = kb *  u[ispec_boundary]\n        end\n    end\n\n    function bsource!(f, bnode)\n        if bnode.region == active_boundary\n\n            if bnode.coord[2, bnode.index] <= 0.5\n                cb = 0.0\n            else\n                cb = cmax\n            end\n\n            f[ispec_boundary] = cb\n        end\n    end\n\n    sys_2D    = VoronoiFVM.System(grid_2D, VoronoiFVM.Physics(flux = flux2D!, reaction = reaction2D!, source = source2D!,\n                                                              bflux = bflux!, breaction = breaction!, bsource = bsource!),\n                                  unknown_storage=unknown_storage)","category":"page"},{"location":"examples/Example230_BoundaryFlux/","page":"103: Boundary flux","title":"103: Boundary flux","text":"enable species in only region","category":"page"},{"location":"examples/Example230_BoundaryFlux/","page":"103: Boundary flux","title":"103: Boundary flux","text":"    enable_species!(         sys_2D, ispec_2D,       [bulk_2D]        )\n    enable_boundary_species!(sys_2D, ispec_boundary, [active_boundary])\n\n    inival_2D  = unknowns(sys_2D);        inival_2D .= 0.0\n    sol_2D     = unknowns(sys_2D)\n\n    solve!(sol_2D, inival_2D, sys_2D, control = control)","category":"page"},{"location":"examples/Example230_BoundaryFlux/","page":"103: Boundary flux","title":"103: Boundary flux","text":"this is for variable transformation, since we consider right outer boundary and want to transform to x-axis.","category":"page"},{"location":"examples/Example230_BoundaryFlux/","page":"103: Boundary flux","title":"103: Boundary flux","text":"    function tran32!(a,b)\n        a[1] = b[2]\n    end","category":"page"},{"location":"examples/Example230_BoundaryFlux/","page":"103: Boundary flux","title":"103: Boundary flux","text":"note that if adjusting active_boundary to 3 or 4, then transform needs to be deleted.","category":"page"},{"location":"examples/Example230_BoundaryFlux/","page":"103: Boundary flux","title":"103: Boundary flux","text":"    bgrid_2D  = subgrid(grid_2D, [active_boundary], boundary = true, transform = tran32!)\n    sol_bound = view(sol_2D[ispec_boundary, :], bgrid_2D)\n\n    scalarplot!(p[2,1], bgrid_2D, sol_bound, show = true, cellwise = true, title = \"Active boundary in 2D (db = $db, kb = $kmax, cb = $cmax)\")\n\n    errorsol = VoronoiFVM.norm(sys_1D, sol_bound - sol_1D', 2)\n\n    return errorsol\n\nend # main\n\nfunction test()\n    main(unknown_storage=:dense)<1.0e-14 &&\n    main(unknown_storage=:sparse)<1.0e-14\nend\n\n\nend # module","category":"page"},{"location":"examples/Example230_BoundaryFlux/","page":"103: Boundary flux","title":"103: Boundary flux","text":"","category":"page"},{"location":"examples/Example230_BoundaryFlux/","page":"103: Boundary flux","title":"103: Boundary flux","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/Example420_DiscontinuousQuantities/#:-Discontinuous-Quantities","page":"420: Discontinuous Quantities","title":"420: Discontinuous Quantities","text":"","category":"section"},{"location":"examples/Example420_DiscontinuousQuantities/","page":"420: Discontinuous Quantities","title":"420: Discontinuous Quantities","text":"(source code)","category":"page"},{"location":"examples/Example420_DiscontinuousQuantities/","page":"420: Discontinuous Quantities","title":"420: Discontinuous Quantities","text":"Test  jumping species and quantity handling","category":"page"},{"location":"examples/Example420_DiscontinuousQuantities/","page":"420: Discontinuous Quantities","title":"420: Discontinuous Quantities","text":"module Example420_DiscontinuousQuantities\nusing Printf\nusing VoronoiFVM\nusing SparseArrays\nusing ExtendableGrids\nusing GridVisualize\nusing LinearAlgebra\n\n\nfunction main(;N=5, Plotter=nothing,unknown_storage=:sparse)\n    XX=collect(0:0.1:1)\n    xcoord=XX\n    for i=1:N-1\n        xcoord=glue(xcoord,XX.+i)\n    end\n    grid2=simplexgrid(xcoord)\n    for i=1:N\n        cellmask!(grid2,[i-1],[i],i)\n    end\n    for i=1:N-1\n        bfacemask!(grid2,[i],[i],i+2)\n    end\n\n    params=zeros(2,num_cellregions(grid2))\n    for i=1:num_cellregions(grid2)\n        params[1,i]=i\n        params[2,i]=10*i\n    end\n\n\n    system=VoronoiFVM.System(grid2,unknown_storage=unknown_storage)\n\n    # First, we introduce a continuous quantity which we name \"cspec\". Note that the \"species number\" can be assigned automatically if not given explicitely.\n    cspec=ContinuousQuantity(system,1:N;ispec=1,id=1)\n\n    # A discontinuous quantity can be introduced as well. by default, each reagion gets a new species number. This can be overwritten by the user.\n    dspec=DiscontinuousQuantity(system,1:N; regionspec=[2+i%2 for i=1:N],id=2)","category":"page"},{"location":"examples/Example420_DiscontinuousQuantities/","page":"420: Discontinuous Quantities","title":"420: Discontinuous Quantities","text":"check 1D array acces with quantities","category":"page"},{"location":"examples/Example420_DiscontinuousQuantities/","page":"420: Discontinuous Quantities","title":"420: Discontinuous Quantities","text":"    carrierList = [cspec dspec]\n    numberCarriers = length(carrierList)\n\n    params2=zeros(1, numberCarriers)\n\n    for icc ∈ carrierList\n        params2[icc] = 2\n    end\n\n    for i=1:numberCarriers\n        @assert params2[i] == 2\n    end","category":"page"},{"location":"examples/Example420_DiscontinuousQuantities/","page":"420: Discontinuous Quantities","title":"420: Discontinuous Quantities","text":"check 2D array acces with quantities","category":"page"},{"location":"examples/Example420_DiscontinuousQuantities/","page":"420: Discontinuous Quantities","title":"420: Discontinuous Quantities","text":"    for i=1:num_cellregions(grid2)\n        @assert params[cspec,i] == i\n        @assert params[dspec,i] == 10*i\n    end\n\n    for i=1:num_cellregions(grid2)\n        params[cspec,i] = -i\n        params[dspec,i] = -10*i\n    end\n\n    for i=1:num_cellregions(grid2)\n        @assert params[1,i] == -i\n        @assert params[2,i] == -10*i\n    end\n\n\n\n\n\n\n    ##For both quantities, we define simple diffusion fluxes:\n\n    function flux(f,u,edge)\n        f[dspec]=u[dspec,1]-u[dspec,2]\n        f[cspec]=u[cspec,1]-u[cspec,2]\n    end\n\n\n    d1=1\n    q1=0.2\n\n    function breaction(f,u,bnode)","category":"page"},{"location":"examples/Example420_DiscontinuousQuantities/","page":"420: Discontinuous Quantities","title":"420: Discontinuous Quantities","text":"left outer boundary value for dspec","category":"page"},{"location":"examples/Example420_DiscontinuousQuantities/","page":"420: Discontinuous Quantities","title":"420: Discontinuous Quantities","text":"        if bnode.region == 1\n            f[dspec] = u[dspec] + 0.5\n        end\n\n        # Define a thin layer inteface condition for `dspec` and an interface source for `cspec`.\n        if bnode.region>2\n            react=(u[dspec,1]-u[dspec,2])/d1\n            f[dspec,1]= react\n            f[dspec,2]= -react\n            f[cspec]=-q1*u[cspec]\n        end\n    end\n\n\n    physics!(system,VoronoiFVM.Physics(\n        flux=flux,\n        breaction=breaction\n    ))\n\n\n    # Set boundary conditions\n    boundary_dirichlet!(system,dspec,2,0.1)\n    boundary_dirichlet!(system,cspec,1,0.1)\n    boundary_dirichlet!(system,cspec,2,1.0)\n    subgrids=VoronoiFVM.subgrids(dspec,system)\n\n\n    U=solve(unknowns(system,inival=0),system)\n\n    dvws=views(U,dspec,subgrids,system)\n    cvws=views(U,cspec,subgrids,system)\n    vis=GridVisualizer(resolution=(600,300),Plotter=Plotter)\n    for i in eachindex(dvws)\n        scalarplot!(vis,subgrids[i],dvws[i],flimits=(-0.5,1.5),clear=false,color=:red)\n        scalarplot!(vis,subgrids[i],cvws[i],flimits=(-0.5,1.5),clear=false,color=:green)\n    end\n    reveal(vis)\n    I = integrate(system, system.physics.storage, U)\n    sum(I[dspec,:])+sum(I[cspec,:])\nend\n\n\nfunction test()\n    testval=4.2\n    main(unknown_storage=:sparse) ≈ testval && main(unknown_storage=:dense) ≈ testval\nend\n\nend","category":"page"},{"location":"examples/Example420_DiscontinuousQuantities/","page":"420: Discontinuous Quantities","title":"420: Discontinuous Quantities","text":"","category":"page"},{"location":"examples/Example420_DiscontinuousQuantities/","page":"420: Discontinuous Quantities","title":"420: Discontinuous Quantities","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/Example101_Laplace1D/#:-1D-Laplace-equation","page":"101: 1D Laplace equation","title":"101: 1D Laplace equation","text":"","category":"section"},{"location":"examples/Example101_Laplace1D/","page":"101: 1D Laplace equation","title":"101: 1D Laplace equation","text":"(source code)","category":"page"},{"location":"examples/Example101_Laplace1D/","page":"101: 1D Laplace equation","title":"101: 1D Laplace equation","text":"Let Omega=(gamma_1gamma_2) with gamma_1=0, gamma_2=1. This is the simplest second order boundary value problem (BVP) for a partial differential equation  (PDE):","category":"page"},{"location":"examples/Example101_Laplace1D/","page":"101: 1D Laplace equation","title":"101: 1D Laplace equation","text":"-Delta u =0\nu(gamma_1)=g_1\nu(gamma_2)=g_2","category":"page"},{"location":"examples/Example101_Laplace1D/","page":"101: 1D Laplace equation","title":"101: 1D Laplace equation","text":"We replace the Dirichlet boundary condition by a Robin boundary condition with a penalty parameter frac1varepsilon:","category":"page"},{"location":"examples/Example101_Laplace1D/","page":"101: 1D Laplace equation","title":"101: 1D Laplace equation","text":"nabla u(gamma_1) + frac1varepsilon(u(gamma_1)-g_1)=0  \n-nabla u(gamma_2) + frac1varepsilon(u(gamma_2)-g_2)\n=0","category":"page"},{"location":"examples/Example101_Laplace1D/","page":"101: 1D Laplace equation","title":"101: 1D Laplace equation","text":"This penalty method for the implementation of Dirichlet boundary conditions is used throughout VoronoiFVM.","category":"page"},{"location":"examples/Example101_Laplace1D/","page":"101: 1D Laplace equation","title":"101: 1D Laplace equation","text":"In order to discretize it, we choose collocation points gamma_1=x_1  x_2  dots  x_n=gamma_2.","category":"page"},{"location":"examples/Example101_Laplace1D/","page":"101: 1D Laplace equation","title":"101: 1D Laplace equation","text":"For instance, we can choose 6 collocation points in (01): From these, we create a discretization grid structure for working with the method.","category":"page"},{"location":"examples/Example101_Laplace1D/","page":"101: 1D Laplace equation","title":"101: 1D Laplace equation","text":"This implicitely creates a number of control volumes omega_k  around each discretization point x_k: Let sigma_kk+1=fracx_k+x_k+12. Then omega_1=(gamma_1sigma_12), omega_k= (sigma_k-1k sigma_kk+1) for k=2dots n-1, omega_n=(sigma_n-1ngamma_2).","category":"page"},{"location":"examples/Example101_Laplace1D/","page":"101: 1D Laplace equation","title":"101: 1D Laplace equation","text":" x1    x2    x3    x4    x5    x6\n o-----o-----o-----o-----o-----o\n |--|-----|-----|-----|-----|--|\n  ω1  ω2     ω3    ω4    ω5  ω6","category":"page"},{"location":"examples/Example101_Laplace1D/","page":"101: 1D Laplace equation","title":"101: 1D Laplace equation","text":"For each omega_k, we integrate the equation","category":"page"},{"location":"examples/Example101_Laplace1D/","page":"101: 1D Laplace equation","title":"101: 1D Laplace equation","text":"beginaligned\n0=int_omega_k -Delta u domega=  -int_partial omega_k nabla u ds\n= begincases\nu(sigma_12) - u(0) k=1\nu(sigma_kk+1) - u(sigma_k-1k)  1kn\nu(1)- u(sigma_nn+1)k=n\nendcases\napprox begincases\nfrac1x_2-x_1 g(u_1u_2) + frac1varepsilon(u_1-0) k=1\nfrac1x_k-x_k-1g(u_ku_k-1) -frac1x_k+1-x_kg(u_k+1u_k)  1kn\nfrac1varepsilon(u_n-1)+ frac1x_n-x_n-1 g(u_nu_n-1)k=n\nendcases\nendaligned","category":"page"},{"location":"examples/Example101_Laplace1D/","page":"101: 1D Laplace equation","title":"101: 1D Laplace equation","text":"In the last equation, we wrote u_k=u(x_k) and g(u_ku_l)=u_k-u_l. For the interior interfaces between control volumes, we replaced u by a difference quotient. In the boundary control volumes, we replaced u  by the boundary conditions.","category":"page"},{"location":"examples/Example101_Laplace1D/","page":"101: 1D Laplace equation","title":"101: 1D Laplace equation","text":"In the example below, we fix a number of species and  write a Julia function describing g, we create a physics record, and a finite volume system with one unknown species and a dense matrix to describe it's degrees of freedom (the matrix used  to calculate the solution is sparse). We give the species the number 1 and enable it for grid region number one 1. Then, we set boundary conditions for species 1 at gamma_1 gamma_2.","category":"page"},{"location":"examples/Example101_Laplace1D/","page":"101: 1D Laplace equation","title":"101: 1D Laplace equation","text":"We create a zero initial value and a solution vector and initialize them.","category":"page"},{"location":"examples/Example101_Laplace1D/","page":"101: 1D Laplace equation","title":"101: 1D Laplace equation","text":"With these data, we solve the system.","category":"page"},{"location":"examples/Example101_Laplace1D/","page":"101: 1D Laplace equation","title":"101: 1D Laplace equation","text":"We wrap this example and all later ones into a module structure. This allows to load all of them at once into the REPL without name clashes. We shouldn't forget the corresponding end statement.","category":"page"},{"location":"examples/Example101_Laplace1D/","page":"101: 1D Laplace equation","title":"101: 1D Laplace equation","text":"module Example101_Laplace1D\n\nusing VoronoiFVM\n\n\nfunction main()\n    ispec=1    ## Index of species we are working with\n\n    # Flux function which describes the flux\n    # between neigboring control volumes\n    function flux!(f,u,edge)\n        f[1]=u[1,1]-u[1,2]\n    end\n\n    function bcond!(args...)\n        boundary_dirichlet!(args...,region=1,value=0)\n        boundary_dirichlet!(args...,region=2,value=1)\n    end\n\n    # Create a one dimensional discretization grid\n    # Each grid cell belongs to a region marked by a region number\n    # By default, there is only one region numbered with 1\n    grid=VoronoiFVM.Grid(0:0.2:1)\n\n    # Create a finite volume system\n    sys=VoronoiFVM.System(grid; flux=flux!,breaction=bcond!,species=ispec)\n\n    # Solve stationary problem\n    solution=solve(sys;inival=0)\n\n    # Return test value\n    return sum(solution)\nend\n\n# Called by unit test\n\nfunction test()\n    main() ≈ 3.0\nend\n\nend","category":"page"},{"location":"examples/Example101_Laplace1D/","page":"101: 1D Laplace equation","title":"101: 1D Laplace equation","text":"","category":"page"},{"location":"examples/Example101_Laplace1D/","page":"101: 1D Laplace equation","title":"101: 1D Laplace equation","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/Example105_NonlinearPoisson1D/#:-1D-Nonlinear-Poisson-equation","page":"105: 1D Nonlinear Poisson equation","title":"105: 1D Nonlinear Poisson equation","text":"","category":"section"},{"location":"examples/Example105_NonlinearPoisson1D/","page":"105: 1D Nonlinear Poisson equation","title":"105: 1D Nonlinear Poisson equation","text":"(source code)","category":"page"},{"location":"examples/Example105_NonlinearPoisson1D/","page":"105: 1D Nonlinear Poisson equation","title":"105: 1D Nonlinear Poisson equation","text":"Solve the nonlinear Poisson equation","category":"page"},{"location":"examples/Example105_NonlinearPoisson1D/","page":"105: 1D Nonlinear Poisson equation","title":"105: 1D Nonlinear Poisson equation","text":"-nabla varepsilon nabla u + e^u-e^-u = f","category":"page"},{"location":"examples/Example105_NonlinearPoisson1D/","page":"105: 1D Nonlinear Poisson equation","title":"105: 1D Nonlinear Poisson equation","text":"in Omega=(01) with boundary condition u(0)=0 and u(1)=1 with","category":"page"},{"location":"examples/Example105_NonlinearPoisson1D/","page":"105: 1D Nonlinear Poisson equation","title":"105: 1D Nonlinear Poisson equation","text":"f(x)=\n    begincases\n    1x05\n    -1 x05\n    endcases","category":"page"},{"location":"examples/Example105_NonlinearPoisson1D/","page":"105: 1D Nonlinear Poisson equation","title":"105: 1D Nonlinear Poisson equation","text":"This stationary problem is an example of a nonlinear Poisson equation or Poisson-Boltzmann equation. Such equation occur e.g. in simulations of electrochemical systems and semicondutor devices.","category":"page"},{"location":"examples/Example105_NonlinearPoisson1D/","page":"105: 1D Nonlinear Poisson equation","title":"105: 1D Nonlinear Poisson equation","text":"module Example105_NonlinearPoisson1D\nusing Printf\nusing VoronoiFVM\nusing ExtendableGrids\nusing GridVisualize\n\nfunction main(;n=10,Plotter=nothing,verbose=false, unknown_storage=:sparse)\n\n    # Create a one-dimensional discretization\n    h=1.0/convert(Float64,n)\n    grid=VoronoiFVM.Grid(collect(0:h:1))\n\n    # A parameter which is \"passed\" to the flux function via scope\n    ϵ=1.0e-3\n\n    # Flux function which describes the flux\n    # between neigboring control volumes\n    function flux!(f,u,edge)\n        f[1]=ϵ*(u[1,1]-u[1,2])\n    end\n\n    # Source term\n    function source!(f,node)\n        if node[1]<=0.5\n            f[1]=1\n        else\n            f[1]=-1\n        end\n    end\n\n    # Reaction term\n    function reaction!(f,u,node)\n        f[1]=exp(u[1]) - exp(-u[1])\n    end\n\n    # Create a physics structure\n    physics=VoronoiFVM.Physics(\n        flux=flux!,\n        source=source!,\n        reaction=reaction!)\n\n\n    # Create a finite volume system - either\n    # in the dense or  the sparse version.\n    # The difference is in the way the solution object\n    # is stored - as dense or as sparse matrix\n\n    sys=VoronoiFVM.System(grid,physics,unknown_storage=unknown_storage)\n\n    # Add species 1 to region 1\n    enable_species!(sys,1,[1])\n\n    # Set boundary conditions\n    boundary_dirichlet!(sys,1,1,0.0)\n    boundary_dirichlet!(sys,1,2,1.0)\n\n    # Create a solution array\n    inival=unknowns(sys,inival=0.5)\n    solution=unknowns(sys)\n\n    # Create solver control info\n    control=VoronoiFVM.NewtonControl()\n    control.verbose=verbose\n\n    # Stationary solution of the problem\n    solve!(solution,inival,sys, control=control)\n\n    scalarplot(grid,solution[1,:],title=\"Nonlinear Poisson\", Plotter=Plotter)\n\n    return sum(solution)\nend\n\nfunction test()\n    testval=1.5247901344230088\n    main(unknown_storage=:sparse) ≈ testval && main(unknown_storage=:dense) ≈ testval\nend\n\nend","category":"page"},{"location":"examples/Example105_NonlinearPoisson1D/","page":"105: 1D Nonlinear Poisson equation","title":"105: 1D Nonlinear Poisson equation","text":"","category":"page"},{"location":"examples/Example105_NonlinearPoisson1D/","page":"105: 1D Nonlinear Poisson equation","title":"105: 1D Nonlinear Poisson equation","text":"This page was generated using Literate.jl.","category":"page"},{"location":"examples/Example201_Laplace2D/#:-2D-Laplace-equation","page":"201: 2D Laplace equation","title":"201: 2D Laplace equation","text":"","category":"section"},{"location":"examples/Example201_Laplace2D/","page":"201: 2D Laplace equation","title":"201: 2D Laplace equation","text":"(source code)","category":"page"},{"location":"examples/Example201_Laplace2D/","page":"201: 2D Laplace equation","title":"201: 2D Laplace equation","text":"module Example201_Laplace2D\n\nusing VoronoiFVM,ExtendableGrids\nusing GridVisualize\n\n# Flux function which describes the flux\n# between neigboring control volumes\nfunction g!(f,u,edge)\n    f[1]=u[1,1]-u[1,2]\nend\n\n\nfunction main(;Plotter=nothing,n=5)\n    nspecies=1\n    ispec=1\n    X=collect(0:1.0/n:1)\n    grid=VoronoiFVM.Grid(X,X)\n\n\n    physics=VoronoiFVM.Physics(flux=g!)\n    sys=VoronoiFVM.System(grid,physics)\n    enable_species!(sys,ispec,[1])\n    boundary_dirichlet!(sys,ispec,1,0.0)\n    boundary_dirichlet!(sys,ispec,3,1.0)\n    inival=unknowns(sys,inival=0)\n    solution=unknowns(sys)\n    solve!(solution,inival,sys)\n    nf=nodeflux(sys,solution)\n    vis=GridVisualizer(Plotter=Plotter)\n    scalarplot!(vis,grid,solution[1,:],clear=true,colormap=:summer)\n    vectorplot!(vis,grid,nf[:,1,:],clear=false,spacing=0.1,vscale=0.5)\n    reveal(vis)\n    return solution[7]\nend\n\n# Called by unit test\n\nfunction test()\n    main() ≈ 0.2\nend\n\nend","category":"page"},{"location":"examples/Example201_Laplace2D/","page":"201: 2D Laplace equation","title":"201: 2D Laplace equation","text":"","category":"page"},{"location":"examples/Example201_Laplace2D/","page":"201: 2D Laplace equation","title":"201: 2D Laplace equation","text":"This page was generated using Literate.jl.","category":"page"}]
}
