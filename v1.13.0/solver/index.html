<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Built-in solver · VoronoiFVM.jl</title><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../">VoronoiFVM.jl</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><a class="tocitem" href="../changes/">Changes</a></li><li><a class="tocitem" href="../method/">The Voronoi finite volume method</a></li><li><span class="tocitem">API Documentation</span><ul><li><a class="tocitem" href="../system/">System</a></li><li><a class="tocitem" href="../physics/">Physics &amp; special functions</a></li><li><a class="tocitem" href="../solutions/">Solution objects</a></li><li class="is-active"><a class="tocitem" href>Built-in solver</a><ul class="internal"><li><a class="tocitem" href="#Solver-control"><span>Solver control</span></a></li><li><a class="tocitem" href="#Linear-Solver-strategies"><span>Linear Solver strategies</span></a></li><li><a class="tocitem" href="#Block-preconditioning"><span>Block preconditioning</span></a></li><li><a class="tocitem" href="#History-handling"><span>History handling</span></a></li><li><a class="tocitem" href="#Matrix-extraction"><span>Matrix extraction</span></a></li><li><a class="tocitem" href="#Legacy-API"><span>Legacy API</span></a></li><li class="toplevel"><a class="tocitem" href="#diffeq"><span>DifferentialEquations.jl solver</span></a></li></ul></li><li><a class="tocitem" href="../post/">Postprocessing</a></li><li><a class="tocitem" href="../quantities/">Quantities</a></li><li><a class="tocitem" href="../misc/">Miscellaneous</a></li><li><a class="tocitem" href="../internal/">Internal API</a></li><li><a class="tocitem" href="../allindex/">Index</a></li></ul></li><li><span class="tocitem">Tutorial Notebooks</span><ul><li><a class="tocitem" href="../notebooks/">About the notebooks</a></li><li><a class="tocitem" href="../nbhtml/outflow/">Outflow boundary conditions</a></li><li><a class="tocitem" href="../nbhtml/flux-reconstruction/">Obtaining vector fields</a></li><li><a class="tocitem" href="../nbhtml/interfaces1d/">Internal interfaces (1D)</a></li><li><a class="tocitem" href="../nbhtml/problemcase/">A case for caution</a></li><li><a class="tocitem" href="../nbhtml/nonlinear-solvers/">Nonlinear solver control</a></li><li><a class="tocitem" href="../nbhtml/api-update/">API Updates</a></li></ul></li><li><span class="tocitem">Examples</span><ul><li><a class="tocitem" href="../runexamples/">About the examples</a></li><li><a class="tocitem" href="../examples/Example001_Solvers/">001: New linear solver API</a></li><li><a class="tocitem" href="../examples/Example002_EdgeReaction/">002: check edge reaction</a></li><li><a class="tocitem" href="../examples/Example101_Laplace1D/">101: 1D Laplace equation</a></li><li><a class="tocitem" href="../examples/Example102_StationaryConvectionDiffusion1D/">102: 1D Stationary convection-diffusion equation</a></li><li><a class="tocitem" href="../examples/Example103_ConvectionDiffusion1D/">103: 1D Convection-diffusion equation</a></li><li><a class="tocitem" href="../examples/Example105_NonlinearPoisson1D/">105: 1D Nonlinear Poisson equation</a></li><li><a class="tocitem" href="../examples/Example106_NonlinearDiffusion1D/">106: 1D Nonlinear Diffusion equation</a></li><li><a class="tocitem" href="../examples/Example107_NonlinearStorage1D/">107: 1D Nonlinear Storage</a></li><li><a class="tocitem" href="../examples/Example110_ReactionDiffusion1D_TwoSpecies/">110: 1D Reaction Diffusion equation with two species</a></li><li><a class="tocitem" href="../examples/Example115_HeterogeneousCatalysis1D/">115: 1D heterogeneous catalysis</a></li><li><a class="tocitem" href="../examples/Example120_ThreeRegions1D/">120: Differing species sets in regions, 1D</a></li><li><a class="tocitem" href="../examples/Example121_PoissonPointCharge1D/">121: 1D Poisson with point charge</a></li><li><a class="tocitem" href="../examples/Example125_TestFunctions1D/">125: Terminal flux calculation via test functions</a></li><li><a class="tocitem" href="../examples/Example150_Impedance1D/">150: Impedance calculation</a></li><li><a class="tocitem" href="../examples/Example151_Impedance1D/">151: Impedance calculation</a></li><li><a class="tocitem" href="../examples/Example160_UnipolarDriftDiffusion1D/">160: Unipolar degenerate drift-diffusion</a></li><li><a class="tocitem" href="../examples/Example201_Laplace2D/">201: 2D Laplace equation</a></li><li><a class="tocitem" href="../examples/Example203_CoordinateSystems/">203: Various coordinate systems</a></li><li><a class="tocitem" href="../examples/Example204_HagenPoiseuille/">204: 2D Convection in Hagen-Poiseuille flow</a></li><li><a class="tocitem" href="../examples/Example205_StagnationPoint/">205: Convection in axisymmetric stagnation point flow</a></li><li><a class="tocitem" href="../examples/Example206_JouleHeat/">206: 2D Joule heating</a></li><li><a class="tocitem" href="../examples/Example207_NonlinearPoisson2D/">207: 2D Nonlinear Poisson equation</a></li><li><a class="tocitem" href="../examples/Example210_NonlinearPoisson2D_Reaction/">210: 2D Nonlinear Poisson with reaction</a></li><li><a class="tocitem" href="../examples/Example215_NonlinearPoisson2D_BoundaryReaction/">215: 2D Nonlinear Poisson with boundary reaction</a></li><li><a class="tocitem" href="../examples/Example220_NonlinearPoisson2D_BoundarySpecies/">220: 2D Nonlinear Poisson with boundary reaction and boundary species</a></li><li><a class="tocitem" href="../examples/Example225_TestFunctions2D/">225: Terminal flux calculation via test functions, nD</a></li><li><a class="tocitem" href="../examples/Example226_BoundaryIntegral/">226: Terminal flux calculation via test functions, nD, boundary reaction</a></li><li><a class="tocitem" href="../examples/Example230_BoundaryFlux/">103: Boundary flux</a></li><li><a class="tocitem" href="../examples/Example301_Laplace3D/">301: 3D Laplace equation</a></li><li><a class="tocitem" href="../examples/Example311_HeatEquation_BoundaryDiffusion/">311: Heat Equation with boundary diffusion</a></li><li><a class="tocitem" href="../examples/Example405_GenericOperator/">405: Generic operator</a></li><li><a class="tocitem" href="../examples/Example406_WeirdReaction/">406: 1D Weird Surface Reaction</a></li><li><a class="tocitem" href="../examples/Example410_ManySpecies/">410: Many Species</a></li><li><a class="tocitem" href="../examples/Example420_DiscontinuousQuantities/">420: Discontinuous Quantities</a></li><li><a class="tocitem" href="../examples/Example421_AbstractQuantities_TestFunctions/">421: Current Calculation for AbstractQuantities</a></li><li><a class="tocitem" href="../examples/Example422_InterfaceQuantities/">422: Drift-Diffusion with Discontinuous and Interface Potentials</a></li><li><a class="tocitem" href="../examples/Example424_AbstractQuantitiesInit/">424: Initialization of Abstract quantities</a></li><li><a class="tocitem" href="../examples/Example430_ParameterDerivativesStationary/">430: Parameter Derivatives (stationary)</a></li><li><a class="tocitem" href="../examples/Example510_Mixture/">510: Mixture</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">API Documentation</a></li><li class="is-active"><a href>Built-in solver</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Built-in solver</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/j-fu/VoronoiFVM.jl" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Built-in-solver"><a class="docs-heading-anchor" href="#Built-in-solver">Built-in solver</a><a id="Built-in-solver-1"></a><a class="docs-heading-anchor-permalink" href="#Built-in-solver" title="Permalink"></a></h1><p>The package comes with a built-in solve method which solves  stationary problems, simple homotopy embedding problems and transient problems  via the implicit Euler method.  This solver and its default parameters are tuned for robustness, possibly at the expense of solution speed. Careful tuning of the parameters, or – in the case of transient problems – the choice of the <a href="#diffeq">DifferentialEquations.jl solver</a> can significantly improve the performance.</p><article class="docstring"><header><a class="docstring-binding" id="CommonSolve.solve-Tuple{VoronoiFVM.AbstractSystem}" href="#CommonSolve.solve-Tuple{VoronoiFVM.AbstractSystem}"><code>CommonSolve.solve</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">solve(system; kwargs...)</code></pre><p>Solution method for <a href="../system/#VoronoiFVM.System"><code>VoronoiFVM.System</code></a>.   For using ODE solvers from <a href="https://github.com/SciML/DifferentialEquations.jl">DifferentialEquations.jl</a>, see the <a href="https://github.com/j-fu/VoronoiFVMDiffEq.jl">VoronoiFVMDiffEq.jl</a> package.</p><p>Keyword arguments:</p><ul><li><p>General for all solvers </p><ul><li><code>inival</code> (default: 0) : Array created via <a href="../post/#VoronoiFVM.unknowns-Union{Tuple{VoronoiFVM.ImpedanceSystem{Tv}}, Tuple{Tv}} where Tv"><code>unknowns</code></a> or  number giving the initial value.</li><li>All elements of <a href="#VoronoiFVM.SolverControl"><code>SolverControl</code></a> can be used as kwargs.</li><li><code>control</code> (default: nothing): Pass instance of <a href="#VoronoiFVM.SolverControl"><code>SolverControl</code></a></li><li><code>params</code>: Parameters (Parameter handling is experimental and may change)</li></ul></li><li><p><strong>Stationary solver</strong>: Invoked if neither <code>times</code> nor <code>embed</code>, nor <code>tstep</code> are given as keyword argument.</p><ul><li><code>time</code> (default: <code>0.0</code>): Set time value.</li></ul><p>Returns a <a href="../solutions/#VoronoiFVM.DenseSolutionArray"><code>DenseSolutionArray</code></a> or <a href="../solutions/#VoronoiFVM.SparseSolutionArray"><code>SparseSolutionArray</code></a></p></li><li><p><strong>Embedding (homotopy) solver</strong>: Invoked if <code>embed</code> kwarg is given. Use homotopy embedding + damped Newton&#39;s method  to  solve stationary problem or to solve series of parameter dependent problems. Parameter step control is performed according to solver control data.  kwargs and default values are:</p><ul><li><code>embed</code> (default: <code>nothing</code> ): vector of parameter values to be reached exactly</li></ul><p>In addition,  all kwargs of the implicit Euler solver (besides <code>times</code>) are handled.   Returns a transient solution object <code>sol</code> containing the stored solution(s),  see <a href="../solutions/#VoronoiFVM.TransientSolution"><code>TransientSolution</code></a>.</p></li><li><p><strong>Implicit Euler transient solver</strong>: Invoked if <code>times</code> kwarg is given. Use implicit Euler method  + damped   Newton&#39;s method  to  solve time dependent problem. Time step control is performed according to solver control data.  kwargs and default values are:</p><ul><li><code>times</code> (default: <code>nothing</code> ): vector of time values to be reached exactly</li><li><code>pre</code> (default: <code>(sol,t)-&gt;nothing</code> ):  invoked before each time step</li><li><code>post</code>  (default:  <code>(sol,oldsol, t, Δt)-&gt;nothing</code> ):  invoked after each time step</li><li><code>sample</code> (default:  <code>(sol,t)-&gt;nothing</code> ): invoked after timestep for all times in <code>times[2:end]</code>.</li><li><code>delta</code> (default:  <code>(system, u,v,t, Δt)-&gt;norm(sys,u-v,Inf)</code> ):  Value  used to control the time step size <code>Δu</code></li></ul><p>If <code>control.handle_error</code> is true, if step solution  throws an error, stepsize  is lowered, and  step solution is called again with a smaller time value. If <code>control.Δt&lt;control.Δt_min</code>, solution is aborted with error. Returns a transient solution object <code>sol</code> containing the stored solution,  see <a href="../solutions/#VoronoiFVM.TransientSolution"><code>TransientSolution</code></a>.</p></li><li><p><strong>Implicit Euler timestep solver</strong>.  Invoked if <code>tstep</code> kwarg is given. Solve one time step of the implicit Euler method.</p><ul><li><code>time</code> (default: <code>0</code>): Set time value. </li><li><code>tstep</code>: time step</li></ul><p>Returns a <a href="../solutions/#VoronoiFVM.DenseSolutionArray"><code>DenseSolutionArray</code></a> or <a href="../solutions/#VoronoiFVM.SparseSolutionArray"><code>SparseSolutionArray</code></a></p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/j-fu/VoronoiFVM.jl">source</a></section></article><h2 id="Solver-control"><a class="docs-heading-anchor" href="#Solver-control">Solver control</a><a id="Solver-control-1"></a><a class="docs-heading-anchor-permalink" href="#Solver-control" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="VoronoiFVM.SolverControl" href="#VoronoiFVM.SolverControl"><code>VoronoiFVM.SolverControl</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">SolverControl
SolverControl(;kwargs...)
SolverControl(linear_solver_strategy, sys; kwargs...)</code></pre><p>Solver control parameter for time stepping, embedding, Newton method and linear solver control. All field names can be used as keyword arguments for <a href="#CommonSolve.solve-Tuple{VoronoiFVM.AbstractSystem}"><code>solve(system::VoronoiFVM.AbstractSystem; kwargs...)</code></a></p><p>Newton&#39;s method solves <span>$F(u)=0$</span> by the iterative procedure <span>$u_{i+1}=u_{i} - d_i F&#39;(u_i)^{-1}F(u_i)$</span> starting with some initial value <span>$u_0$</span>, where <span>$d_i$</span> is a damping parameter.</p><p>For linear solver strategies, see <a href="#VoronoiFVM.LinearSolverStrategy"><code>VoronoiFVM.LinearSolverStrategy</code></a>.</p><ul><li><code>verbose::Union{Bool, String}</code>: Verbosity control. A collection of output categories is given in a string composed of the following letters:<ul><li>a: allocation warnings</li><li>d: deprecation warnings</li><li>e: time/parameter evolution log</li><li>n: newton solver log</li><li>l: linear solver log</li></ul>Alternatively, a Bool value can be given, resulting in<ul><li>true: &quot;neda&quot;</li><li>false: &quot;da&quot;</li></ul>Switch off all output including deprecation warnings via <code>verbose=&quot;&quot;</code>. In the output, corresponding messages are marked e.g. via &#39;[n]&#39;, <code>[a]</code> etc. (besides of &#39;[l]&#39;)</li></ul><ul><li><code>abstol::Float64</code>: Tolerance (in terms of norm of Newton update): terminate if <span>$\Delta u_i=||u_{i+1}-u_i||_\infty &lt;$</span> <code>abstol</code>.</li></ul><ul><li><code>reltol::Float64</code>: Tolerance (relative to the size of the first update): terminate if <span>$\Delta u_i/\Delta u_1&lt;$</span> <code>reltol</code>.</li></ul><ul><li><code>maxiters::Int64</code>: Maximum number of newton iterations.</li></ul><ul><li><code>tol_round::Float64</code>: Tolerance for roundoff error detection: terminate if   <span>$|\;||u_{i+1}||_1 - ||u_{i}||_1\;|/ ||u_{i}||_1&lt;$</span> <code>tol_round</code> occurred <code>max_round</code> times in a row.</li></ul><ul><li><code>tol_mono::Float64</code>: Tolerance for monotonicity test: terminate with error if <span>$\Delta u_i/\Delta u_{i-1}&gt;$</span> <code>1/tol_mono</code>.</li></ul><ul><li><code>damp_initial::Float64</code>: Initial damping parameter <span>$d_0$</span>. To handle convergence problems, set this to a value less than 1.</li></ul><ul><li><code>damp_growth::Float64</code>: Damping parameter growth factor: <span>$d_{i+1}=\min(d_i\cdot$</span> <code>max_growth</code> <span>$,1)$</span>. It should be larger than 1.</li></ul><ul><li><code>max_round::Int64</code>: Maximum number of consecutive iterations within roundoff error tolerance The default effectively disables this criterion.</li></ul><ul><li><code>unorm::Function</code>: Calculation of Newton update norm</li></ul><ul><li><code>rnorm::Function</code>: Functional for roundoff error calculation</li></ul><ul><li><p><code>method_linear::Union{Nothing, LinearSolve.SciMLLinearSolveAlgorithm}</code>: Solver method for linear systems (see LinearSolve.jl). If given <code>nothing</code>, as default are chosen (for <code>Float64</code> calculations):</p><ul><li>1D:  <code>KLUFactorization()</code></li><li>2D:  <code>SparspakFactorization()</code></li><li>3D:  <code>UMFPACKFactorization()</code></li></ul><p><code>SparspakFactorization()</code> is the default choice for general number types. Users should experiment with what works best for their problem.</p><p>For easy access to this functionality, see see also <a href="#VoronoiFVM.LinearSolverStrategy"><code>VoronoiFVM.LinearSolverStrategy</code></a>.</p></li></ul><ul><li><code>reltol_linear::Float64</code>:     Relative tolerance of iterative linear solver.</li></ul><ul><li><code>abstol_linear::Float64</code>: Absolute tolerance of iterative linear solver.</li></ul><ul><li><code>maxiters_linear::Int64</code>: Maximum number of iterations of linear solver</li></ul><ul><li><p><code>precon_linear::Union{Nothing, Function, ExtendableSparse.AbstractFactorization, LinearSolve.SciMLLinearSolveAlgorithm, Type}</code>: Constructor for preconditioner for linear systems. This should work as a function <code>precon_linear(A)</code> which takes an AbstractSparseMatrixCSC (e.g. an ExtendableSparseMatrix) and returns a preconditioner object in the sense of <code>LinearSolve.jl</code>, i.e. which has an <code>ldiv!(u,A,v)</code> method. Useful examples:</p><ul><li><code>ExtendableSparse.ILUZero</code></li><li><code>ExtendableSparse.Jacobi</code></li></ul><p>For easy access to this functionality, see see also <a href="#VoronoiFVM.LinearSolverStrategy"><code>VoronoiFVM.LinearSolverStrategy</code></a>.</p></li></ul><ul><li><code>keepcurrent_linear::Bool</code>: Update preconditioner in each Newton step ?</li></ul><ul><li><code>Δp::Float64</code>: Initial parameter step for embedding.</li></ul><ul><li><code>Δp_max::Float64</code>: Maximal parameter step size.</li></ul><ul><li><code>Δp_min::Float64</code>: Minimal parameter step size.</li></ul><ul><li><code>Δp_grow::Float64</code>: Maximal parameter step size growth.</li></ul><ul><li><code>Δt::Float64</code>: Initial time step  size.</li></ul><ul><li><code>Δt_max::Float64</code>: Maximal time step size.</li></ul><ul><li><code>Δt_min::Float64</code>: Minimal time step size.</li></ul><ul><li><code>Δt_grow::Float64</code>: Maximal time step size growth.</li></ul><ul><li><code>Δu_opt::Float64</code>: Optimal size of update for time stepping and embeding. The algorithm tries to keep the difference in norm between &quot;old&quot; and &quot;new&quot; solutions  approximately at this value.</li></ul><ul><li><code>force_first_step::Bool</code>: Force first timestep.</li></ul><ul><li><p><code>handle_exceptions::Bool</code>: Handle exceptions during transient solver and parameter embedding. If <code>true</code>, exceptions in Newton solves are caught, the embedding resp. time step is lowered, and solution is retried. Moreover, if embedding or time stepping fails (e.g. due to reaching minimal step size), a warning is issued, and a solution is returned with all steps calculated so far.</p><p>Otherwise (by default) errors are thrown.</p></li></ul><ul><li><code>store_all::Bool</code>: Store all steps of transient/embedding problem:</li></ul><ul><li><code>in_memory::Bool</code>: Store transient/embedding solution in memory</li></ul><ul><li><code>log::Any</code>:    Record history</li></ul><ul><li><code>edge_cutoff::Float64</code>: Edge parameter cutoff for rectangular triangles.</li></ul><ul><li><code>pre::Function</code>: Function <code>pre(sol,t)</code> called before time/embedding step</li></ul><ul><li><code>post::Function</code>: Function <code>post(sol,oldsol,t,Δt)</code> called after successful time/embedding step</li></ul><ul><li><code>sample::Function</code>: Function <code>sample(sol,t)</code> to be called for each <code>t in times[2:end]</code></li></ul><ul><li><code>delta::Function</code>: Time step error estimator</li></ul><ul><li><p><code>tol_absolute::Union{Nothing, Float64}</code></p></li><li><p><code>tol_relative::Union{Nothing, Float64}</code></p></li><li><p><code>damp::Union{Nothing, Float64}</code></p></li><li><p><code>damp_grow::Union{Nothing, Float64}</code></p></li><li><p><code>max_iterations::Union{Nothing, Int64}</code></p></li><li><p><code>tol_linear::Union{Nothing, Float64}</code></p></li><li><p><code>max_lureuse::Union{Nothing, Int64}</code></p></li><li><p><code>mynorm::Union{Nothing, Function}</code></p></li><li><p><code>myrnorm::Union{Nothing, Function}</code></p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/j-fu/VoronoiFVM.jl">source</a></section></article><h2 id="Linear-Solver-strategies"><a class="docs-heading-anchor" href="#Linear-Solver-strategies">Linear Solver strategies</a><a id="Linear-Solver-strategies-1"></a><a class="docs-heading-anchor-permalink" href="#Linear-Solver-strategies" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="VoronoiFVM.LinearSolverStrategy" href="#VoronoiFVM.LinearSolverStrategy"><code>VoronoiFVM.LinearSolverStrategy</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">VoronoiFVM.LinearSolverStrategy</code></pre><p>An linear solver strategy provides the possibility to construct <a href="#VoronoiFVM.SolverControl"><code>SolverControl</code></a> objects as follows:</p><pre><code class="nohighlight hljs">    SolverControl(strategy,sys;kwargs...)</code></pre><p>, e.g.</p><pre><code class="nohighlight hljs">    SolverControl(GMRESIteration(UMFPackFactorization(), EquationBlock()),sys;kwargs...)</code></pre><p>A linear solver strategy combines a Krylov method  with an (incomplete) factorization which by default is calculated from the linearization of the initial value of the Newton iteration.</p><p>Currently available strategies are:</p><ul><li><a href="#VoronoiFVM.DirectSolver"><code>DirectSolver</code></a></li><li><a href="#VoronoiFVM.CGIteration"><code>CGIteration</code></a></li><li><a href="#VoronoiFVM.BICGstabIteration"><code>BICGstabIteration</code></a></li><li><a href="#VoronoiFVM.GMRESIteration"><code>GMRESIteration</code></a></li></ul><p>Notable LU Factorizations are:</p><ul><li><a href="https://docs.sciml.ai/LinearSolve/stable/solvers/solvers/#SuiteSparse.jl"><code>UMFPACKFactorization</code></a></li><li><a href="https://docs.sciml.ai/LinearSolve/stable/solvers/solvers/#SuiteSparse.jl"><code>KLUFactorization</code></a></li><li><a href="https://docs.sciml.ai/LinearSolve/stable/solvers/solvers/#Sparspak.jl"><code>SparspakFactorization</code></a>, <a href="https://j-fu.github.io/ExtendableSparse.jl/stable/iter/#ExtendableSparse.SparspakLU"><code>SparspakLU</code></a></li><li><a href="https://j-fu.github.io/ExtendableSparse.jl/stable/iter/#ExtendableSparse.MKLPardisoLU"><code>MKLPardisoLU</code></a></li></ul><p>Notable incomplete factorizations are:</p><ul><li><a href="https://j-fu.github.io/ExtendableSparse.jl/stable/iter/#ExtendableSparse.ILUZeroPreconditioner"><code>ILUZeroPreconditioner</code></a></li><li><a href="https://j-fu.github.io/ExtendableSparse.jl/stable/iter/#ExtendableSparse.AMGPreconditioner"><code>AMGPreconditioner</code></a>,</li><li><a href="https://j-fu.github.io/ExtendableSparse.jl/stable/iter/#ExtendableSparse.ILUTPreconditioner"><code>ILUTPrecondidtioner</code></a></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/j-fu/VoronoiFVM.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VoronoiFVM.DirectSolver" href="#VoronoiFVM.DirectSolver"><code>VoronoiFVM.DirectSolver</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">DirectSolver(;factorization=UMFPACKFactorization())</code></pre><p>LU Factorization solver.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/j-fu/VoronoiFVM.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VoronoiFVM.CGIteration" href="#VoronoiFVM.CGIteration"><code>VoronoiFVM.CGIteration</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">CGIteration(;factorization=UMFPACKFactorization())
CGIteration(factorization)</code></pre><p>CG Iteration from Krylov.jl via LinearSolve.jl.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/j-fu/VoronoiFVM.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VoronoiFVM.BICGstabIteration" href="#VoronoiFVM.BICGstabIteration"><code>VoronoiFVM.BICGstabIteration</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">BICGstabIteration(;factorization=UMFPACKFactorization())
BICGstabIteration(factorization)</code></pre><p>BICGstab Iteration from Krylov.jl via LinearSolve.jl.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/j-fu/VoronoiFVM.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VoronoiFVM.GMRESIteration" href="#VoronoiFVM.GMRESIteration"><code>VoronoiFVM.GMRESIteration</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">GMRESIteration(;factorization=ILUZeroFactorization(), memory=20, restart=true)
GMRESIteration(factorization; memory=20, restart=true)</code></pre><p>GMRES Iteration from Krylov.jl via LinearSolve.jl.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/j-fu/VoronoiFVM.jl">source</a></section></article><h2 id="Block-preconditioning"><a class="docs-heading-anchor" href="#Block-preconditioning">Block preconditioning</a><a id="Block-preconditioning-1"></a><a class="docs-heading-anchor-permalink" href="#Block-preconditioning" title="Permalink"></a></h2><p>This feature is under development as of 1.6.</p><article class="docstring"><header><a class="docstring-binding" id="VoronoiFVM.BlockStrategy" href="#VoronoiFVM.BlockStrategy"><code>VoronoiFVM.BlockStrategy</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">VoronoiFVM.BlockStrategy</code></pre><p>Abstract supertype for various block preconditioning strategies.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/j-fu/VoronoiFVM.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VoronoiFVM.NoBlock" href="#VoronoiFVM.NoBlock"><code>VoronoiFVM.NoBlock</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">NoBlock()</code></pre><p>No blocking.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/j-fu/VoronoiFVM.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VoronoiFVM.EquationBlock" href="#VoronoiFVM.EquationBlock"><code>VoronoiFVM.EquationBlock</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">EquationBlock()</code></pre><p>Equation-wise blocking. Can be combined with any preconditioner resp. factorization including direct solvers. In the moment, this requires a system with <code>unknown_storage=:dense</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/j-fu/VoronoiFVM.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VoronoiFVM.PointBlock" href="#VoronoiFVM.PointBlock"><code>VoronoiFVM.PointBlock</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">PointBlock()</code></pre><p>Point-wise blocking. Currently only together with ILUZeroFactorization. This requires a system with <code>unknown_storage=:dense</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/j-fu/VoronoiFVM.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VoronoiFVM.Equationwise" href="#VoronoiFVM.Equationwise"><code>VoronoiFVM.Equationwise</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct Equationwise</code></pre><p>Equationwise partitioning mode.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/j-fu/VoronoiFVM.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VoronoiFVM.partitioning" href="#VoronoiFVM.partitioning"><code>VoronoiFVM.partitioning</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">partitioning(system; mode)
</code></pre><p>Calculate partitioning of system unknowns.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/j-fu/VoronoiFVM.jl">source</a></section></article><h2 id="History-handling"><a class="docs-heading-anchor" href="#History-handling">History handling</a><a id="History-handling-1"></a><a class="docs-heading-anchor-permalink" href="#History-handling" title="Permalink"></a></h2><p>If <code>log</code> is set to true in <code>solve</code>, the history of newton iterations and  time/embedding steps is recorded and. For the respective previous solution step it can be obtained via <code>history(system)</code>.</p><article class="docstring"><header><a class="docstring-binding" id="VoronoiFVM.NewtonSolverHistory" href="#VoronoiFVM.NewtonSolverHistory"><code>VoronoiFVM.NewtonSolverHistory</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">mutable struct NewtonSolverHistory &lt;: AbstractVector{Float64}</code></pre><p>History information for one Newton solve of a nonlinear system. As an abstract vector it provides the history of the update norms. See <a href="#Base.summary-Tuple{NewtonSolverHistory}"><code>summary</code></a> and <a href="#VoronoiFVM.details"><code>details</code></a> for other ways to extract information.</p><ul><li><p><code>nlu::Int64</code>:  number of Jacobi matrix factorizations</p></li><li><p><code>nlin::Int64</code>:  number of linear iteration steps / factorization solves</p></li><li><p><code>time::Float64</code>:  Elapsed time for solution</p></li><li><p><code>tasm::Float64</code>:  Elapsed time for assembly</p></li><li><p><code>tlinsolve::Float64</code>:  Elapsed time for linear solve</p></li><li><p><code>updatenorm::Any</code>:  History of norms of <span>$||u_{i+1}-u_i||$</span></p></li><li><p><code>l1normdiff::Any</code>:  History of norms of <span>$|\;||u_{i+1}||_1 - ||u_{i}||_1\;|/ ||u_{i}||_1$</span></p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/j-fu/VoronoiFVM.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VoronoiFVM.TransientSolverHistory" href="#VoronoiFVM.TransientSolverHistory"><code>VoronoiFVM.TransientSolverHistory</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">mutable struct TransientSolverHistory &lt;: AbstractVector{NewtonSolverHistory}</code></pre><p>History information for transient solution/parameter embedding</p><p>As an abstract vector it provides the histories of each implicit Euler/embedding step. See <a href="#Base.summary-Tuple{NewtonSolverHistory}"><code>summary</code></a> and <a href="#VoronoiFVM.details"><code>details</code></a> for other ways to extract information.</p><ul><li><p><code>histories::Any</code>:  Histories of each implicit Euler Newton iteration</p></li><li><p><code>times::Any</code>:  Time values</p></li><li><p><code>updates::Any</code>:  Update norms used for step control</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/j-fu/VoronoiFVM.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.summary-Tuple{NewtonSolverHistory}" href="#Base.summary-Tuple{NewtonSolverHistory}"><code>Base.summary</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">summary(h::NewtonSolverHistory)</code></pre><p>Return named tuple summarizing history.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/j-fu/VoronoiFVM.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.summary-Tuple{TransientSolverHistory}" href="#Base.summary-Tuple{TransientSolverHistory}"><code>Base.summary</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">summary(h::TransientSolverHistory)</code></pre><p>Return named tuple summarizing history.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/j-fu/VoronoiFVM.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VoronoiFVM.details" href="#VoronoiFVM.details"><code>VoronoiFVM.details</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">details(h::NewtonSolverHistory)</code></pre><p>Return array of named tuples  with info on each iteration step</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/j-fu/VoronoiFVM.jl">source</a></section><section><div><pre><code class="nohighlight hljs">details(h::TransientSolverHistory)</code></pre><p>Return array of details of each solver step</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/j-fu/VoronoiFVM.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VoronoiFVM.history" href="#VoronoiFVM.history"><code>VoronoiFVM.history</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">history(sys)</code></pre><p>Return solver history from last <code>solve</code> call, if <code>log</code> was set to true. See  see <a href="#VoronoiFVM.NewtonSolverHistory"><code>NewtonSolverHistory</code></a>, <a href="#VoronoiFVM.TransientSolverHistory"><code>TransientSolverHistory</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/j-fu/VoronoiFVM.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VoronoiFVM.history_details" href="#VoronoiFVM.history_details"><code>VoronoiFVM.history_details</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">history_details(sys)</code></pre><p>Return details of solver history from last <code>solve</code> call, if <code>log</code> was set to true. See <a href="#VoronoiFVM.details"><code>details</code></a>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/j-fu/VoronoiFVM.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VoronoiFVM.history_summary" href="#VoronoiFVM.history_summary"><code>VoronoiFVM.history_summary</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">history_summary(sys)</code></pre><p>Return summary of solver history from last <code>solve</code> call, if <code>log</code> was set to true.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/j-fu/VoronoiFVM.jl">source</a></section></article><h2 id="Matrix-extraction"><a class="docs-heading-anchor" href="#Matrix-extraction">Matrix extraction</a><a id="Matrix-extraction-1"></a><a class="docs-heading-anchor-permalink" href="#Matrix-extraction" title="Permalink"></a></h2><p>For testing and teaching purposes, one can obtain residual and linearization at a given vector of unknowns</p><article class="docstring"><header><a class="docstring-binding" id="VoronoiFVM.evaluate_residual_and_jacobian" href="#VoronoiFVM.evaluate_residual_and_jacobian"><code>VoronoiFVM.evaluate_residual_and_jacobian</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">evaluate_residual_and_jacobian(system,u;
                               t=0.0, tstep=Inf,embed=0.0)</code></pre><p>Evaluate residual and jacobian at solution value u. Returns a solution vector containing the residual, and an ExendableSparseMatrix containing the linearization at u.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/j-fu/VoronoiFVM.jl">source</a></section></article><h2 id="Legacy-API"><a class="docs-heading-anchor" href="#Legacy-API">Legacy API</a><a id="Legacy-API-1"></a><a class="docs-heading-anchor-permalink" href="#Legacy-API" title="Permalink"></a></h2><p>During the development of the code, a number of API variants have been developed which  are supported for backward compatibility.</p><article class="docstring"><header><a class="docstring-binding" id="CommonSolve.solve-Tuple{Any, VoronoiFVM.AbstractSystem, Any}" href="#CommonSolve.solve-Tuple{Any, VoronoiFVM.AbstractSystem, Any}"><code>CommonSolve.solve</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">    solve(inival, system, times; kwargs...)</code></pre><p>Alias for <a href="#CommonSolve.solve-Tuple{VoronoiFVM.AbstractSystem}"><code>solve(system::VoronoiFVM.AbstractSystem; kwargs...)</code></a> with the corresponding keyword arguments.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/j-fu/VoronoiFVM.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CommonSolve.solve-Tuple{Any, VoronoiFVM.AbstractSystem}" href="#CommonSolve.solve-Tuple{Any, VoronoiFVM.AbstractSystem}"><code>CommonSolve.solve</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">    solve(inival, system; control=SolverControl(),params, tstep=Inf)</code></pre><p>Alias for <a href="#CommonSolve.solve-Tuple{VoronoiFVM.AbstractSystem}"><code>solve(system::VoronoiFVM.AbstractSystem; kwargs...)</code></a> with the corresponding keyword arguments.</p><p>Solve stationary problem(if <code>tstep==Inf</code>) or one step implicit Euler step using Newton&#39;s method with <code>inival</code> as initial value. Returns a solution array.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/j-fu/VoronoiFVM.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="CommonSolve.solve!-Tuple{Any, Any, VoronoiFVM.AbstractSystem}" href="#CommonSolve.solve!-Tuple{Any, Any, VoronoiFVM.AbstractSystem}"><code>CommonSolve.solve!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia hljs">solve!(solution, inival, system; 
    control=SolverControl(), 
    tstep=Inf)</code></pre><p>Mutating version of <a href="#CommonSolve.solve-Tuple{VoronoiFVM.AbstractSystem}"><code>solve(inival,system)</code></a></p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/j-fu/VoronoiFVM.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VoronoiFVM.NewtonControl" href="#VoronoiFVM.NewtonControl"><code>VoronoiFVM.NewtonControl</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">NewtonControl</code></pre><p>Legacy name of SolverControl</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/j-fu/VoronoiFVM.jl">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="VoronoiFVM.SolverStrategies" href="#VoronoiFVM.SolverStrategies"><code>VoronoiFVM.SolverStrategies</code></a> — <span class="docstring-category">Module</span></header><section><div><pre><code class="language-julia hljs">SolverStrategies</code></pre><div class="admonition is-compat"><header class="admonition-header">Only available in 1.5</header><div class="admonition-body"><p>Please replace this functionality by the new strategy API in 1.6 as follows:</p><pre><code class="nohighlight hljs">direct_umfpack() = DirectSolver(UMFPACKFactorization())                            
gmres_umfpack() = GMRESIteration(UMFPACKFactorization())                           
gmres_eqnblock_umfpack() = GMRESIteration(UMFPACKFactorization(), EquationBlock()) 
gmres_iluzero() = GMRESIteration(ILUZeroPreconditioner())                          
gmres_eqnblock_iluzero() = GMRESIteration(ILUZeroPreconditioner(), EquationBlock())
gmres_pointblock_iluzero() = GMRESIteration(ILUZeroPreconditioner(), PointBlock()) </code></pre></div></div></div><a class="docs-sourcelink" target="_blank" href="https://github.com/j-fu/VoronoiFVM.jl">source</a></section></article><h1 id="diffeq"><a class="docs-heading-anchor" href="#diffeq">DifferentialEquations.jl solver</a><a id="diffeq-1"></a><a class="docs-heading-anchor-permalink" href="#diffeq" title="Permalink"></a></h1><p>This solver has been being outsourced into the glue package  <a href="https://github.com/j-fu/VoronoiFVMDiffEq.jl">VoronoiFVMDiffEq.jl</a></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../solutions/">« Solution objects</a><a class="docs-footer-nextpage" href="../post/">Postprocessing »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.25 on <span class="colophon-date" title="Monday 24 July 2023 14:27">Monday 24 July 2023</span>. Using Julia version 1.9.2.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
